{"version":3,"sources":["script.js","sectors.js","main.js","jcanvas.js"],"names":["cartesian2Polar","x","y","upX","CenterX","upY","CenterY","distance","Math","sqrt","radians","atan2","degr","PI","polarCoor","cartesian2Dec","radius","tan","pow","decCoor","X","Y","cartesian2DecForBorder","newDegr","hexInArray","h","m","slice","match","parseInt","hexArrayInRgbString","rgb","changeColorLayers","color","numLayers","arColor","tempColor","arRBA","i","difColorRed","difColorGreen","difColorBlue","red","green","blue","floor","console","log","createSectorNew","sector_id","beginAngle","endAngle","circle_id","arColors","difRadius","bigRadius","nameArc","nameSector","nameGroup","canvas","$","drawSlice","layer","mask","groups","fillStyle","start","end","strokeStyle","strokeWidth","restoreCanvas","name","dblclick","polar","eventX","eventY","link","attr","removeClass","addClass","text","click","drawArc","shadowBlur","shadowColor","mouseout","setLayer","drawLayer","createBorderSector","data","endCoord","drawVector","a1","l1","borderForSector","angle","sectorLeftId","sectorRightId","angleMin","angelMax","LabelCoord","leftCoord","rightCoord","draggable","radiusLabel","circlePath","circleRadius","circleCenterX","circleCenterY","xMin","yMin","xMax","yMax","sectorLeft","sectorRight","shadowLabelSize","dragstop","pol","getLayer","circleId","beginAngleL","colorL","endAngleR","colorR","newLeftSectorMinAngle","newRightSectorMinAngle","oldLeftSectorMinAngle","oldRightSectorMinAngle","coefficientLeft","coefficientRight","updateLabelPositionByChangingSector","removeLayerGroup","setHightMoveLayerToLayer","drag","mouseover","rayAndCircleByLabel","id","dec","colorRayAndCircleByLabel","drawLine","x1","y1","x2","y2","createNamePopUpLabel","heightPopUp","widthPopUp","drawRect","width","height","cornerRadius","drawText","fontSize","fontFamily","maxWidth","createLabel","colorLabel","label_radius","label_angle","label_id","updateCoordinateLabel","delRayNamePopUpAndCircleByLabel","Label","colorSelectLabel","delRayNamePopUpAndCircleAllLabels","setLinkLabelsByRadiusAndAngle","removeLinkLabelsByRadiusAndAngle","css","setMoveLayerToLayer","index","array","moveLayer","dragLayers","getLayers","forEach","setFillStyleToLayer","angleBorderMin","angleBorderMax","radiusBorderMin","radiusBorderMax","labels","getLayerGroup","deleteFillStyleToLayer","delNamePopUpByLabel","border","updateLabelPosition","label","sector_left","newAngle","sector_right","labelId","post","done","removeLayer","addTagForm","$collectionHolder","$newLinkLi","prototype","newForm","replace","$newFormLi","append","before","e","preventDefault","this","parent","remove","addTagFormDeleteLink","$tagFormLi","$removeFormA","on","isLocalhost","Boolean","window","location","hostname","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","error","jQuery","global","factory","module","exports","w","jCanvasObject","args","propName","params","Object","hasOwnProperty","call","jCanvasDefaults","extendObject","baseDefaults","isString","operand","typeOf","isNumeric","isNaN","Number","parseFloat","_getContext","getContext","_coerceNumericProps","props","propType","propValue","undefined","String","_cloneTransforms","transforms","masks","_saveCanvas","ctx","save","savedTransforms","push","_restoreCanvas","length","baseTransforms","restore","pop","_setStyle","styleName","isFunction","_setGlobalProps","lineWidth","rounded","lineCap","lineJoin","strokeCap","strokeJoin","miterLimit","strokeDash","setLineDash","webkitLineDash","lineDashOffset","webkitLineDashOffset","mozDashOffset","strokeDashOffset","shadowOffsetX","shadowX","shadowOffsetY","shadowY","globalAlpha","opacity","globalCompositeOperation","compositing","imageSmoothing","imageSmoothingEnabled","_enableMasking","autosave","clip","_args","_restoreTransform","_transformed","_closePath","closed","closePath","shadowStroke","stroke","fill","_getCanvasData","_transformShape","_toRad","inDegrees","fromCenter","_centered","rotate","_rotateCanvas","scale","scaleX","scaleY","_scaleCanvas","translate","translateX","translateY","_translateCanvas","dataCache","caches","_canvas","_data","layers","names","eventHooks","intersecting","lastIntersected","cursor","dragging","event","type","events","animating","animated","pixelRatio","scaled","redrawOnMousemove","_addLayerEvents","$canvas","eventName","jCanvas","cursors","_addExplicitLayerEvent","bind","l","_triggerLayerEvent","_hovered","triggerLayerEvent","drawLayers","_addLayerEvent","_event","_enableDrag","dragHelperEvents","_updateLayerName","nameMap","_updateLayerGroups","group","groupName","g","groupMap","splice","_getIntersectingLayer","_masks","intersects","intangible","_drawLayer","nextLayerIndex","visible","_method","_next","_handleLayerDrag","eventType","dragGroups","newX","newY","bringToFront","_startX","_startY","_endX","_eventX","_endY","_eventY","updateDragX","updateDragY","dx","dy","restrictDragToAxis","centerX","centerY","r","k","tempX","tempY","px","py","qx","qy","rx","ry","Result","absSumMin","abs","absSumMax","originalRedrawOnMousemove","_setCursor","inArray","prefix","_resetCursor","_runEventCallback","callbacks","arg","_running","_layerCanFireEvent","disableEvents","tangibleEvents","_addLayer","method","_layer","fn","maps","drawings","measureText","_showProps","obj","cssProp","p","_hideProps","reset","propsObj","_parseEndValues","endValues","subPropName","subPropValue","isPlainObject","_removeSubPropAliases","indexOf","_colorToRgbArray","originalColor","elem","multiple","document","head","style","_animateColor","fx","n","now","pos","round","join","nodeName","prop","_supportColorProps","step","_getTouchEventName","touchEvents","_getMouseEventName","mouseEvents","_createEvent","eventCallback","eventCache","offsetX","offsetY","helperEventName","resetFire","touchEventName","_createEvents","eventNames","_detectEvents","isPointInPath","isPointInStroke","cos","sin","_getCoterminal","_getArcX","_getArcY","_drawArc","path","x3","y3","x4","y4","diff","ccw","_addStartArrow","arc","_addEndArrow","_addArrow","leftX","leftY","rightX","rightY","arrowRadius","arrowAngle","moveTo","lineTo","_arrowAngleConverted","startArrow","endArrow","_drawLine","lx","ly","_drawQuadratic","lcx","lcy","cx1","cy1","quadraticCurveTo","_drawBezier","lc","lcx1","lcy1","lcx2","lcy2","bezierCurveTo","_getVectorX","_getVectorY","_drawVector","_setCanvasFont","font","fontStyle","_measureText","lines","originalSize","curWidth","propCache","lineHeight","_wrapText","line","words","allText","manualLines","split","allLines","concat","defaults","Image","Array","getComputedStyle","extend","toString","toLowerCase","arraySlice","jQueryEventFix","fix","imageCache","future","align","baseline","concavity","count","cropFromCenter","crossOrigin","letterSpacing","r1","r2","repeat","respectAlign","sHeight","sides","source","spread","sWidth","sx","sy","plugin","self","$canvases","getEventHooks","setEventHooks","callback","matching","layerId","idType","groupId","getLayerIndex","substr","isEmptyObject","setLayers","setLayerGroup","removeLayers","addLayerToGroup","removeLayerFromGroup","styles","documentElement","pre","OLink","lastLayer","lastIndex","isImageLayer","clear","clearCanvas","_fired","drawImage","addLayer","animateLayer","complete","_animating","parts","hidden","_pos","arguments","duration","easing","draw","animate","animateLayerGroup","apply","delayLayer","delay","delayLayerGroup","stopLayer","clearQueue","stop","stopLayerGroup","mousedown","mouseup","mousemove","touchstart","touchend","touchmove","offset","originalEvent","touches","changedTouches","pageX","currentTarget","left","pageY","top","bezier","ellipse","function","image","polygon","quadratic","rectangle","vector","setTransform","clearRect","saveCanvas","rotateCanvas","scaleCanvas","translateCanvas","temp","beginPath","rect","drawEllipse","controlW","controlH","drawPolygon","theta","dtheta","hdtheta","apothem","drawQuadratic","drawBezier","drawPath","lp","nchars","chars","ch","c","constantCloseness","textBaseline","textAlign","flipArcText","reverse","fillText","strokeText","img","onload","load","imgCtx","src","createPattern","pattern","createGradient","gradient","nstops","a","stops","createRadialGradient","createLinearGradient","addColorStop","setPixels","canvasData","imgData","pixelData","len","getImageData","each","b","putImageData","getCanvasImage","quality","dataURL","toDataURL","detectPixelRatio","devicePixelRatio","backingStoreRatio","ratio","oldWidth","oldHeight","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","clearCache","cacheName","support","setGlobalProps","transformShape","detectEvents","setCanvasFont","$addTagLink","ready","html","find"],"mappings":";;;;;;;;;;;;;;;;;;AAqBA,QAAAA,iBAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAAG,QACAC,EAAAH,EAAAI,OAKA,OAJAC,UAAAC,KAAAC,KAAAN,EAAAA,EAAAE,EAAAA,GACAK,QAAAF,KAAAG,MAAAN,EAAAF,GACAS,KAAA,IAAAF,QAAAF,KAAAK,GAAA,GACAC,WAAAP,SAAAA,SAAAK,KAAAA,MACAE,UAUA,QAAAC,eAAAC,EAAAJ,GAYA,MAXAF,UAAAE,EAAA,KAAAJ,KAAAK,GAAA,KACAD,GAAA,GAAAA,GAAA,KACAK,IAAAT,KAAAS,IAAAP,SACAT,EAAAO,KAAAC,KAAAD,KAAAU,IAAAF,EAAA,IAAAR,KAAAU,IAAAD,IAAA,GAAA,IACAf,EAAAD,EAAAgB,MAEAA,IAAAT,KAAAS,KAAAP,SACAT,GAAAO,KAAAC,KAAAD,KAAAU,IAAAF,EAAA,IAAAR,KAAAU,IAAAD,IAAA,GAAA,IACAf,GAAAD,EAAAgB,KAEAE,SAAAC,EAAAnB,EAAAG,QAAAiB,EAAAnB,EAAAI,SACAa,QAUA,QAAAG,wBAAAN,EAAAJ,GACA,GAAAW,GAAAX,EAAA,EAeA,OAdAF,SAAAa,GAAAf,KAAAK,GAAA,KAEAU,GAAA,GAAAA,GAAA,KACAN,IAAAT,KAAAS,IAAAP,SACAT,EAAAO,KAAAC,KAAAO,EAAAA,GAAAC,IAAAA,IAAA,IACAf,EAAAD,EAAAgB,MAEAA,IAAAT,KAAAS,KAAAP,SACAT,EAAAO,KAAAC,KAAAO,EAAAA,GAAAC,IAAAA,IAAA,IACAf,EAAAD,EAAAgB,KAGAE,SAAAC,EAAAnB,EAAAoB,EAAAnB,GAEAiB,QAOA,QAAAK,YAAAC,GACA,GAAAC,GAAAD,EAAAE,MAAA,GAAAC,MAAA,QAIA,OAHAF,GAAA,GAAAG,SAAAH,EAAA,GAAA,IACAA,EAAA,GAAAG,SAAAH,EAAA,GAAA,IACAA,EAAA,GAAAG,SAAAH,EAAA,GAAA,IACAA,EAGA,QAAAI,qBAAAJ,GACA,GAAAK,GAAA,OAAAL,EAAA,GAAA,KAAAA,EAAA,GAAA,KAAAA,EAAA,GAAA,GACA,OAAAK,GAGA,QAAAC,mBAAAC,EAAAC,GACA,GAAAC,GAAAX,WAAAS,GACAG,EAAAD,EACAE,KACAC,EAAA,EACAC,GAAA,IAAAJ,EAAA,IAAAD,EACAM,EAAAL,EAAA,IAAAD,EAAA,GACAO,EAAAN,EAAA,IAAAD,EAAA,GACAQ,EAAAP,EAAA,GAAAI,EACAI,EAAAR,EAAA,GACAS,EAAAT,EAAA,EACA,KAAAO,EAAAA,GAAA,OAAAA,GAAAH,EACAH,EAAA,GAAA5B,KAAAqC,MAAAH,GACAN,EAAA,GAAA5B,KAAAqC,MAAAF,GACAP,EAAA,GAAA5B,KAAAqC,MAAAD,GACAP,EAAAC,GAAAR,oBAAAM,GACAO,GAAAH,EACAI,GAAAH,EACAH,GAGA,OADAQ,SAAAC,IAAAV,GACAA,EAOA,QAAAW,iBAAAC,EAAAC,EAAAC,EAAAC,EAAAlB,EAAAD,GACA,GAAAK,GAEAW,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAlB,EAAAA,EACAD,EAAAA,EAEAoB,EAAArB,kBAAAC,EAAAC,GACAoB,EAAAC,UAAArB,EACAlB,EAAAuC,UAEAC,EAAA,WAAAP,EACAQ,EAAA,eAAAR,EACAS,EAAA,UAAAT,EACAU,EAAAC,EAAA,SAEA,KAAAtB,EAAA,EAAAA,GAAAJ,EAAAI,IACAqB,EAAAE,WACAC,OAAA,EACAC,MAAA,EACAC,QAAAN,GACAO,UAAAZ,EAAAf,EAAA,GACArC,EAAAG,QAAAF,EAAAI,QACA4D,MAAAhB,EACAiB,IAAAhB,EACAnC,OAAAA,EACAoD,YAAA,OACAC,YAAA,IACAC,eACAR,OAAA,IAGA9C,GAAAsC,CAGAK,GAAAE,WACAC,OAAA,EACAC,MAAA,EACA9D,EAAAG,QAAAF,EAAAI,QACA4D,MAAAhB,EACAiB,IAAAhB,EACAoB,KAAAd,EACAO,QAAAN,GACAN,UAAAA,EACAH,UAAAA,EACAjC,OAAAuC,UACArB,UAAAA,EACAD,MAAAA,EACAuC,SAAA,SAAAV,GACA,GAAAW,GAAAzE,gBAAA8D,EAAAY,OAAAZ,EAAAa,QACAC,EAAAhB,EAAA,sBAAAiB,KAAA,OAAA,0BAAAf,EAAAV,UAAA,WAAAqB,EAAAlE,SAAAgD,UAAA,SAAAkB,EAAA7D,KACAgE,GAAAE,YAAA,eAAAC,SAAA,cACAH,EAAAI,KAAA,uCAEAC,MAAA,SAAAnB,GACAF,EAAA,UAAAsB,SACAC,WAAA,GACAC,YAAA,QACAhB,YAAA,QACAG,KAAAf,EACAQ,QAAAN,GACAW,YAAA,EACApE,EAAAG,QAAAF,EAAAI,QACAU,OAAAuC,UACAW,MAAAhB,EACAiB,IAAAhB,IACAmB,eACAR,OAAA,KAGAuB,SAAA,SAAAvB,GACAF,EAAA,UAAA0B,SAAA9B,GACA2B,WAAA,IACAI,eAIA5B,EAAAW,eACAR,OAAA,IAIA,QAAA0B,oBAAAC,GACA,GAAAC,GAAApE,uBAAAiC,UAAAkC,EAAAvC,WACAU,GAAA,UAAA+B,YACAvB,YAAA,QACAC,YAAA,EACApE,EAAAG,QAAAF,EAAAI,QACAsF,GAAAF,EAAAtE,EAAAyE,GAAAH,EAAArE,IAIA,QAAAyE,iBAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAArF,cAAAwC,UAAAwC,GACAM,EAAAtF,cAAAwC,UAAA2C,EAAA,GACAI,EAAAvF,cAAAwC,UAAA4C,EAAA,EACAvC,GAAA,UAAAsB,SACApB,OAAA,EACAyC,WAAA,EACAP,aAAAA,EACAC,cAAAA,EACA1B,KAAA,UAAAyB,EAAA,IAAAC,EACAhC,UAAA,SACAhE,EAAAmG,EAAAhF,EAAAlB,EAAAkG,EAAA/E,EACAL,OAAAwF,YACAC,YAAA,EACAC,aAAAnD,UACAoD,cAAAvG,QACAwG,cAAAtG,QACAuG,KAAAR,EAAAjF,EAAA0F,KAAAT,EAAAhF,EACA0F,KAAAT,EAAAlF,EAAA4F,KAAAV,EAAAjF,EACAoE,MAAAwB,WAAAjB,EAAAkB,YAAAjB,GACAb,YAAAA,YACAD,WAAAgC,gBACAC,SAAA,SAAAtD,GACA,GAAAuD,GAAArH,gBAAA8D,EAAA7D,EAAA6D,EAAA5D,GACA+G,EAAArD,EAAA,UAAA0D,SAAA,eAAAxD,EAAAkC,cACAkB,EAAAtD,EAAA,UAAA0D,SAAA,eAAAxD,EAAAmC,eAEAsB,EAAAN,EAAA7D,UACAlB,EAAA+E,EAAA/E,UAEAsF,EAAAP,EAAA/C,MACAuD,EAAAR,EAAAhF,MAEAyF,EAAAR,EAAA/C,IACAwD,EAAAT,EAAAjF,MAKA2F,EAAAX,EAAA/C,MACA2D,EAAAR,EAAAzG,KACAkH,EAAAb,EAAA/C,MACA6D,EAAAb,EAAAhD,MACA8D,GAAAX,EAAAzG,KAAA4G,IAAAP,EAAA9C,IAAA8C,EAAA/C,OACA+D,GAAAP,EAAAL,EAAAzG,OAAAsG,EAAA/C,IAAA+C,EAAAhD,MAEAgE,qCAAApE,EAAAkE,EAAAC,EAAAL,EAAAC,EAAAC,EAAAC,GAEAnE,EAAA,UAAAuE,iBAAA,UAAAnC,GACAhD,gBAAAgD,EAAAwB,EAAAH,EAAAzG,KAAA2G,EAAArF,EAAAuF,GAEA7D,EAAA,UAAAuE,iBAAA,UAAAlC,GACAjD,gBAAAiD,EAAAoB,EAAAzG,KAAA8G,EAAAH,EAAArF,EAAAyF,GAEAS,4BASAC,KAAA,SAAAvE,GACA,GAAAuD,GAAArH,gBAAA8D,EAAA7D,EAAA6D,EAAA5D,EAEA0D,GAAA,UAAA+B,YACAvB,YAAA,QACAC,YAAA,EACApE,EAAAG,QAAAF,EAAAI,QACAsF,GAAAyB,EAAAzG,KAAAiF,GAAAwB,EAAA9G,YAGA+H,UAAA,SAAAxE,GACAF,EAAA,UAAA+B,YACAvB,YAAA,QACAC,YAAA,EACApE,EAAAG,QAAAF,EAAAI,QACAsF,GAAAG,EAAAF,GAAAtC,aAGA8B,SAAA,SAAAvB,KAKAU,SAAA,SAAAV,OAUA,QAAAyE,qBAAAzE,EAAA0E,GACA,GAAAnB,GAAArH,gBAAA8D,EAAA7D,EAAA6D,EAAA5D,GACAuI,EAAA1H,cAAAwC,IAAA8D,EAAAzG,KACAgD,GAAA,UAAAsB,SACApB,OAAA,EACAM,YAAAsE,yBACArE,YAAA,EACAE,KAAA,gBAAAiE,EACAxE,QAAA,iBACA/D,EAAAG,QAAAF,EAAAI,QACAU,OAAAqG,EAAA9G,WAEAqD,EAAA,UAAA+E,UACA7E,OAAA,EACAO,YAAA,EACAE,KAAA,cAAAiE,EACAxE,QAAA,eACAI,YAAAsE,yBACAE,GAAAxI,QAAAyI,GAAAvI,QACAwI,GAAAL,EAAArH,EAAA2H,GAAAN,EAAApH,IAIA,QAAA2H,sBAAAR,EAAAvI,EAAAC,EAAA8E,GACA,GAAAiE,GAAA,GACAC,EAAA,GAEAtF,GAAA,UAAAuF,UACArF,OAAA,EACAG,UAAA,QACAG,YAAA,OACAC,YAAA,EACAE,KAAA,iBAAAiE,EACAxE,QAAA,kBACA/D,EAAAA,EAAAiJ,EAAA,EAAAhJ,EAAAA,EAAA+I,EAAA,EAAA,GACAG,MAAAF,EACAG,OAAAJ,EACAK,aAAA,KAEA1F,EAAA,UAAA2F,UACAzF,OAAA,EACAS,KAAA,qBAAAiE,EACAxE,QAAA,sBACAC,UAAA,QACAI,YAAA,EACApE,EAAAA,EAAAiJ,EAAA,EAAAhJ,EAAAA,EAAA+I,EAAA,EAAA,GACAO,SAAA,OACAC,WAAA,sBACAC,SAAAR,EACAlE,KAAAA,IAKA,QAAA2E,aAAAlE,GACA,GAAAW,GAAArF,cAAA0E,EAAAzE,OAAAuC,UAAAkC,EAAA7E,KAEAgD,GAAA,UAAAsB,SACApB,OAAA,EACAyC,WAAA,EACAvC,QAAA,eACAO,KAAA,UAAAkB,EAAA+C,GACAvE,UAAA2F,WACA3J,EAAAmG,EAAAhF,EAAAlB,EAAAkG,EAAA/E,EACAL,OAAAwF,YACAf,MAAA+C,GAAA/C,EAAA+C,GAAAjE,KAAAkB,EAAAlB,KAAAgD,SAAA9B,EAAA8B,UACAsC,aAAApE,EAAAzE,OACA8I,YAAArE,EAAA7E,KACAmJ,SAAAtE,EAAA+C,GACApD,YAAAA,YACAD,WAAAgC,gBACAC,SAAA,SAAAtD,GACA,GAAAuD,GAAArH,gBAAA8D,EAAA7D,EAAA6D,EAAA5D,EACAa,eAAAsG,EAAA9G,SAAA8G,EAAAzG,KAEAkD,GAAA+F,aAAAxC,EAAA9G,SAAAgD,UACAO,EAAAgG,YAAAzC,EAAAzG,KAGAoJ,sBAAAlG,EAAA2B,KAAA8B,SAAAzD,EAAA2B,KAAA+C,GAAAnB,EAAA9G,SAAAgD,UAAA8D,EAAAzG,MACAqJ,gCAAAnG,EAAA2B,KAAA+C,KAEAH,KAAA,SAAAvE,GACAmG,gCAAAnG,EAAA2B,KAAA+C,IACAD,oBAAAzE,EAAAA,EAAA2B,KAAA+C,KAEAF,UAAA,SAAAxE,GACA,GAAAoG,GAAAtG,EAAA,UAAA0D,SAAAxD,EAAAS,KACA2F,GAAAjG,UAAAkG,iBACAC,oCACA7B,oBAAAzE,EAAAA,EAAA2B,KAAA+C,IACA6B,8BAAAvG,EAAA+F,aAAA/F,EAAAgG,YAAAhG,EAAAiG,UACAf,qBAAAlF,EAAA2B,KAAA+C,GAAA1E,EAAA7D,EAAA6D,EAAA5D,EAAA4D,EAAA2B,KAAAlB,OAEAc,SAAA,SAAAvB,GACA,GAAAoG,GAAAtG,EAAA,UAAA0D,SAAAxD,EAAAS,KACA2F,GAAAjG,UAAA2F,WACAK,gCAAAnG,EAAA2B,KAAA+C,IACA8B,iCAAAxG,EAAA+F,aAAA/F,EAAAgG,YAAAhG,EAAAiG,WAEAvF,SAAA,SAAAV,GACAF,EAAA,mBAAA2G,IAAA,UAAA,SAAA1F,KAAA,OAAA,2BAAAf,EAAA2B,KAAA8B,SAAA,IAAAzD,EAAA2B,KAAA+C,GAAA,QAKA,QAAAJ,4BAMA,QAAAoC,GAAA1G,EAAA2G,EAAAC,GACA9G,EAAA,UAAA+G,UAAA7G,EAAAS,KAAA,KALA,GAAAqG,GAAAhH,EAAA,UAAAiH,UAAA,SAAA/G,GACA,MAAAA,GAAAyC,aAAA,GAMAqE,GAAAE,QAAAN,GAGA,QAAAH,+BAAArJ,EAAA+E,EAAAgE,GAQA,QAAAgB,GAAAjH,EAAA2G,EAAAC,GACA5G,EAAA0E,KAAAuB,IACAjG,EAAAgG,YAAAkB,GAAAlH,EAAAgG,YAAAmB,GACAnH,EAAA+F,aAAAqB,GAAApH,EAAA+F,aAAAsB,KAEAnC,qBAAAlF,EAAAiG,SAAAjG,EAAA7D,EAAA6D,EAAA5D,EAAA4D,EAAA2B,KAAAlB,MACAT,EAAAG,UAAAkG,kBAbA,GAAAiB,GAAAxH,EAAA,UAAAyH,cAAA,eACAH,EAAAlK,EAAA,IACAmK,EAAAnK,EAAA,IACAgK,EAAAjF,EAAA,GACAkF,EAAAlF,EAAA,EAaAqF,GAAAN,QAAAC,GAGA,QAAAT,kCAAAtJ,EAAA+E,EAAAgE,GAQA,QAAAuB,GAAAxH,EAAA2G,EAAAC,GACA5G,EAAAiG,WAAAA,IACAjG,EAAAgG,YAAAkB,GAAAlH,EAAAgG,YAAAmB,GACAnH,EAAA+F,aAAAqB,GAAApH,EAAA+F,aAAAsB,KAEArH,EAAAG,UAAA2F,WACA2B,oBAAAzH,EAAAiG,WAbA,GAAAqB,GAAAxH,EAAA,UAAAyH,cAAA,eACAH,EAAAlK,EAAA,IACAmK,EAAAnK,EAAA,IACAgK,EAAAjF,EAAA,GACAkF,EAAAlF,EAAA,EAaAqF,GAAAN,QAAAQ,GAGA,QAAApD,qCAAAsD,EAAAxD,EAAAC,EAAAL,EAAAC,EAAAC,EAAAC,GAMA,QAAA0D,GAAAC,EAAAjB,EAAAC,GAEA,GAAAgB,EAAA5B,YAAA6B,EAAAzH,OAAAwH,EAAA5B,YAAA6B,EAAAxH,IAAA,CACA,GAAAyH,IAAAF,EAAA5B,YAAAhC,GAAAE,EAAAJ,EACAxB,EAAArF,cAAA2K,EAAA7B,aAAAtG,UAAAqI,EACAF,GAAAzL,EAAAmG,EAAAhF,EACAsK,EAAAxL,EAAAkG,EAAA/E,EACAyB,QAAAC,IAAA2I,EAAAnH,KAAAmH,EAAA5B,YAAA8B,EAAAD,EAAA/D,EAAAC,EAAAC,EAAAC,EAAAC,GACA0D,EAAA5B,YAAA8B,MACA,IAAAF,EAAA5B,YAAA+B,EAAA3H,OAAAwH,EAAA5B,YAAA+B,EAAA1H,IAAA,CACA,GAAAyH,IAAAF,EAAA5B,YAAA/B,GAAAE,EAAAJ,EACAzB,EAAArF,cAAA2K,EAAA7B,aAAAtG,UAAAqI,EACAF,GAAAzL,EAAAmG,EAAAhF,EACAsK,EAAAxL,EAAAkG,EAAA/E,EACAqK,EAAA5B,YAAA8B,GAnBA,GAAAD,GAAA/H,EAAA,UAAA0D,SAAA,eAAAkE,EAAAxF,cACA6F,EAAAjI,EAAA,UAAA0D,SAAA,eAAAkE,EAAAvF,eACAmF,EAAAxH,EAAA,UAAAyH,cAAA,cAEA,oBAAAD,IAkBAA,EAAAN,QAAAW,GAOA,QAAAzB,uBAAAzC,EAAAuE,EAAA9K,EAAA+E,GACAnC,EAAAmI,KACA,qCAEAxE,SAAAA,EACAuE,QAAAA,EACA9K,OAAAA,EACA+E,MAAAA,IACAiG,KACA,SAAAvG,GACA3C,QAAAC,IAAA0C,KAKA,QAAAwE,iCAAAzB,GACA5E,EAAA,UAAAqI,YAAA,gBAAAzD,GACA5E,EAAA,UAAAqI,YAAA,cAAAzD,GACA5E,EAAA,UAAAqI,YAAA,iBAAAzD,GACA5E,EAAA,UAAAqI,YAAA,qBAAAzD,GAGA,QAAA+C,qBAAA/C,GACA5E,EAAA,UAAAqI,YAAA,iBAAAzD,GACA5E,EAAA,UAAAqI,YAAA,qBAAAzD,GAGA,QAAA4B,qCACAxG,EAAA,UAAAuE,iBAAA,iBACAvE,EAAA,UAAAuE,iBAAA,eACAvE,EAAA,UAAAuE,iBAAA,kBACAvE,EAAA,UAAAuE,iBAAA,sBClfA,QAAA+D,YAAAC,EAAAC,GAEA,GAAAC,GAAAF,EAAA1G,KAAA,aAGAgF,EAAA0B,EAAA1G,KAAA,SAIA6G,EAAAD,EAAAE,QAAA,YAAA9B,EAGA0B,GAAA1G,KAAA,QAAAgF,EAAA,EAGA,IAAA+B,GAAA5I,EAAA0I,EAGAE,GAAAC,OAAA,yFAEAL,EAAAM,OAAAF,GAGA5I,EAAA,eAAAqB,MAAA,SAAA0H,GAKA,MAJAA,GAAAC,iBAEAhJ,EAAAiJ,MAAAC,SAAAC,UAEA,IAOA,QAAAC,sBAAAC,GACA,GAAAC,GAAAtJ,EAAA,kCACAqJ,GAAAR,OAAAS,GAEAA,EAAAC,GAAA,QAAA,SAAAR,GAEAA,EAAAC,iBAGAK,EAAAF,YC/DA,WACA,YAMA,IAAAK,GAAAC,QAAA,cAAAC,OAAAC,SAAAC,UAEA,UAAAF,OAAAC,SAAAC,UAEAF,OAAAC,SAAAC,SAAA5L,MACA,0DAIA,kBAAA6L,aACA,WAAAH,OAAAC,SAAAG,UAAAN,IACAK,UAAAE,cAAAC,SAAA,qBACAC,KAAA,SAAAC,GAEAA,EAAAC,cAAA,WAKA,GAAAN,UAAAE,cAAAK,WAAA,CAGA,GAAAC,GAAAH,EAAAI,UAEAD,GAAAE,cAAA,WACA,OAAAF,EAAAG,OACA,IAAA,YAKA,KAEA,KAAA,YACA,KAAA,IAAAC,OAAA,yDAvBAZ,SAgCA,SAAAd,GACA7J,QAAAwL,MAAA,4CAAA3B;;;;;ACjEA,SAAA4B,EAAAC,EAAAC,GACA,YAEA,iBAAAC,SAAA,gBAAAA,QAAAC,QACAD,OAAAC,QAAA,SAAAJ,EAAAK,GACA,MAAAH,GAAAF,EAAAK,IAGAH,EAAAF,EAAAC,IAIA,mBAAAlB,QAAAA,OAAAiB,UAAA,mBAAAjB,QAAAA,OAAAT,KAAA,SAAAjJ,EAAA0J,GACA,YAgEA,SAAAuB,GAAAC,GACA,GACAC,GADAC,EAAAnC,IAGA,KAAAkC,IAAAD,GAEAG,OAAA5C,UAAA6C,eAAAC,KAAAL,EAAAC,KACAC,EAAAD,GAAAD,EAAAC,GAGA,OAAAC,GAcA,QAAAI,KACAC,GAAAxC,KAAAuC,EAAAE,cA4FA,QAAAC,GAAAC,GACA,MAAA,WAAAC,GAAAD,GAIA,QAAAE,GAAAF,GACA,OAAAG,MAAAC,GAAAJ,MAAAG,MAAAE,GAAAL,IAIA,QAAAM,GAAAnM,GACA,MAAAA,IAAAA,EAAAoM,WAAApM,EAAAoM,WAAA,MAAA,KAIA,QAAAC,GAAAC,GACA,GAAAlB,GAAAmB,EAAAC,CAEA,KAAApB,IAAAkB,GACAhB,OAAA5C,UAAA6C,eAAAC,KAAAc,EAAAlB,KACAoB,EAAAF,EAAAlB,GACAmB,EAAAT,GAAAU,GAEA,WAAAD,GAAAR,EAAAS,IAAA,SAAApB,IAEAkB,EAAAlB,GAAAc,GAAAM,IAKAC,UAAAH,EAAAjL,OACAiL,EAAAjL,KAAAqL,OAAAJ,EAAAjL,OAKA,QAAAsL,GAAAC,GAKA,MAHAA,GAAAlB,MAAAkB,GAEAA,EAAAC,MAAAD,EAAAC,MAAA7O,MAAA,GACA4O,EAIA,QAAAE,GAAAC,EAAAjL,GACA,GAAA8K,EACAG,GAAAC,OACAJ,EAAAD,EAAA7K,EAAA8K,YACA9K,EAAAmL,gBAAAC,KAAAN,GAIA,QAAAO,GAAAJ,EAAAjL,GACA,IAAAA,EAAAmL,gBAAAG,OAEAtL,EAAA8K,WAAAD,EAAAU,KAGAN,EAAAO,UAEAxL,EAAA8K,WAAA9K,EAAAmL,gBAAAM,OAKA,QAAAC,GAAAxN,EAAA+M,EAAA1B,EAAAoC,GACApC,EAAAoC,KACAC,GAAArC,EAAAoC,IAEAV,EAAAU,GAAApC,EAAAoC,GAAAjC,KAAAxL,EAAAqL,GAGA0B,EAAAU,GAAApC,EAAAoC,IAMA,QAAAE,GAAA3N,EAAA+M,EAAA1B,GACAmC,EAAAxN,EAAA+M,EAAA1B,EAAA,aACAmC,EAAAxN,EAAA+M,EAAA1B,EAAA,eACA0B,EAAAa,UAAAvC,EAAA3K,YAEA2K,EAAAwC,QACAd,EAAAe,QAAAf,EAAAgB,SAAA,SAEAhB,EAAAe,QAAAzC,EAAA2C,UACAjB,EAAAgB,SAAA1C,EAAA4C,WACAlB,EAAAmB,WAAA7C,EAAA6C,YAGA7C,EAAA8C,aACA9C,EAAA8C,eAGApB,EAAAqB,aACArB,EAAAqB,YAAA/C,EAAA8C,YAEApB,EAAAsB,eAAAhD,EAAA8C,WACApB,EAAAuB,eAAAvB,EAAAwB,qBAAAxB,EAAAyB,cAAAnD,EAAAoD,iBAEA1B,EAAA2B,cAAArD,EAAAsD,QACA5B,EAAA6B,cAAAvD,EAAAwD,QACA9B,EAAAvL,WAAA6J,EAAA7J,WACAuL,EAAAtL,YAAA4J,EAAA5J,YAEAsL,EAAA+B,YAAAzD,EAAA0D,QACAhC,EAAAiC,yBAAA3D,EAAA4D,YAEA5D,EAAA6D,iBACAnC,EAAAoC,sBAAA9D,EAAA6D,gBAKA,QAAAE,GAAArC,EAAAjL,EAAAuJ,GACAA,EAAAjL,OAEAiL,EAAAgE,UAEAvC,EAAAC,EAAAjL,GAGAiL,EAAAuC,OAEAxN,EAAA8K,WAAAC,MAAAK,KAAA7B,EAAAkE,QAKA,QAAAC,GAAAzC,EAAA1B,GAEAA,EAAAoE,cAEA1C,EAAAO,UAKA,QAAAoC,GAAA1P,EAAA+M,EAAA1B,GACA,GAAAvJ,EAGAuJ,GAAAsE,QACA5C,EAAA6C,YAGAvE,EAAAwE,cAAA,IAAAxE,EAAA3K,aAIAqM,EAAA+C,SACA/C,EAAAgD,OAEAhD,EAAAtL,YAAA,cACAsL,EAAAvL,WAAA,EAEAuL,EAAA+C,WAKA/C,EAAAgD,OAEA,gBAAA1E,EAAA/K,YACAyM,EAAAtL,YAAA,eAEA,IAAA4J,EAAA3K,aAEAqM,EAAA+C,UAMAzE,EAAAsE,QACA5C,EAAA6C,YAIAJ,EAAAzC,EAAA1B,GAGAA,EAAAjL,OAEA0B,EAAAkO,EAAAhQ,GACAoP,EAAArC,EAAAjL,EAAAuJ,IAMA,QAAA4E,GAAAjQ,EAAA+M,EAAA1B,EAAA5F,EAAAC,GAGA2F,EAAA6E,OAAA7E,EAAA8E,UAAAjT,GAAA,IAAA,EAEAmO,EAAAoE,cAAA,EACA1C,EAAAC,OAGA3B,EAAA+E,YAAA/E,EAAAgF,WAAA5D,SAAAhH,IAEAgH,SAAA/G,IACAA,EAAAD,GAEA4F,EAAA/O,GAAAmJ,EAAA,EACA4F,EAAA9O,GAAAmJ,EAAA,EACA2F,EAAAgF,WAAA,GAGAhF,EAAAiF,QACAC,EAAAxD,EAAA1B,EAAA,MAGA,IAAAA,EAAAmF,OAAA,IAAAnF,EAAAoF,QAAA,IAAApF,EAAAqF,QACAC,EAAA5D,EAAA1B,EAAA,OAGAA,EAAAuF,WAAAvF,EAAAwF,YAAAxF,EAAAyF,aACAC,EAAAhE,EAAA1B,EAAA,MA+CA,QAAA2E,GAAAhQ,GACA,GAAA8B,GAAAkP,EAAAC,GAAAD,SAkEA,OAjEAA,GAAAE,UAAAlR,GAAAgR,EAAAG,MAGArP,EAAAkP,EAAAG,OAKArP,EAAA7B,EAAA6B,KAAA9B,EAAA,WACA8B,IAGAA,GAEA9B,OAAAA,EAEAoR,UAEAjR,OACAkR,SACAhR,WAEAiR,cAEAC,gBAEAC,gBAAA,KACAC,OAAAxR,EAAAD,GAAA4G,IAAA,UAEAlC,MACAvE,MAAA,KACAuR,UAAA,GAGAC,OACAC,KAAA,KACAtV,EAAA,KACAC,EAAA,MAGAsV,UAEAjF,WAAAD,EAAAU,IACAJ,mBAEA6E,WAAA,EAEAC,SAAA,KAEAC,WAAA,EAEAC,QAAA,EAGAC,mBAAA,GAGAjS,EAAA6B,KAAA9B,EAAA,UAAA8B,IAIAkP,EAAAE,QAAAlR,EACAgR,EAAAG,MAAArP,GAGAA,EAIA,QAAAqQ,GAAAC,EAAAtQ,EAAA3B,GACA,GAAAkS,EAEA,KAAAA,IAAAC,IAAAT,OACAvG,OAAA5C,UAAA6C,eAAAC,KAAA8G,GAAAT,OAAAQ,KAEAlS,EAAAkS,IAAAlS,EAAAoS,SAAApS,EAAAoS,QAAAF,KAEAG,EAAAJ,EAAAtQ,EAAA3B,EAAAkS,EAIAvQ,GAAA+P,OAAAnQ,WACA0Q,EAAAK,KAAA,mBAAA,WAEA,GAAAC,GAAAvS,EAAA2B,EAAA4C,KAAAvE,KAQA,KANAA,IAEA2B,EAAA4C,QACAiO,EAAAP,EAAAtQ,EAAA3B,EAAA,eAGAuS,EAAA,EAAAA,EAAA5Q,EAAAsP,OAAAhE,OAAAsF,GAAA,EACAvS,EAAA2B,EAAAsP,OAAAsB,GAEAvS,EAAAyS,UAEAR,EAAAS,kBAAA/Q,EAAAsP,OAAAsB,GAAA,WAIAN,GAAAU,eAGAhR,EAAA+P,OAAAnQ,UAAA,GAKA,QAAAqR,GAAAX,EAAAtQ,EAAA3B,EAAAkS,GAIAC,GAAAT,OAAAQ,GAAAD,EAAAtQ,GACA3B,EAAA6S,QAAA,EAMA,QAAAR,GAAAJ,EAAAtQ,EAAA3B,EAAAkS,GACAU,EAAAX,EAAAtQ,EAAA3B,EAAAkS,GACA,cAAAA,GAAA,aAAAA,GAAA,cAAAA,IACAvQ,EAAAoQ,mBAAA,GAKA,QAAAe,GAAAb,EAAAtQ,EAAA3B,GACA,GAAA+S,GAAAb,EAAA1T,CAEA,IAAAwB,EAAAyC,WAAAzC,EAAAoS,QAAA,CAMA,IAHAW,GAAA,YAAA,YAAA,WAGAvU,EAAA,EAAAA,EAAAuU,EAAA9F,OAAAzO,GAAA,EAEA0T,EAAAa,EAAAvU,GAEAoU,EAAAX,EAAAtQ,EAAA3B,EAAAkS,EAGAlS,GAAA6S,QAAA,GAMA,QAAAG,GAAAf,EAAAtQ,EAAA3B,EAAAmM,GACA,GAAA8G,GAAAtR,EAAA3B,MAAAkR,KAGA/E,GAOAG,SAAAH,EAAA1L,MAAAgL,EAAAzL,EAAAS,OAAAT,EAAAS,OAAA0L,EAAA1L,YACAwS,GAAAjT,EAAAS,MANA0L,EAAAnM,EAYAyL,EAAAU,EAAA1L,QACAwS,EAAA9G,EAAA1L,MAAAT,GAKA,QAAAkT,GAAAjB,EAAAtQ,EAAA3B,EAAAmM,GACA,GACAgH,GAAAC,EAAAC,EACA1M,EAAA4L,EAFAe,EAAA3R,EAAA3B,MAAAE,MAKA,IAAAiM,GAOA,GAAAG,SAAAH,EAAAjM,QAAA,OAAAF,EAAAE,OACA,IAAAmT,EAAA,EAAAA,EAAArT,EAAAE,OAAA+M,OAAAoG,GAAA,EAGA,GAFAD,EAAApT,EAAAE,OAAAmT,GACAF,EAAAG,EAAAF,GACA,CAEA,IAAAb,EAAA,EAAAA,EAAAY,EAAAlG,OAAAsF,GAAA,EACA,GAAAY,EAAAZ,KAAAvS,EAAA,CAEA2G,EAAA4L,EAEAY,EAAAI,OAAAhB,EAAA,EACA,OAIA,IAAAY,EAAAlG,cACAqG,GAAAF,QAtBAjH,GAAAnM,CA+BA,IAAAsM,SAAAH,EAAAjM,QAAA,OAAAiM,EAAAjM,OAEA,IAAAmT,EAAA,EAAAA,EAAAlH,EAAAjM,OAAA+M,OAAAoG,GAAA,EAEAD,EAAAjH,EAAAjM,OAAAmT,GAEAF,EAAAG,EAAAF,GACAD,IAEAA,EAAAG,EAAAF,MACAD,EAAA1S,KAAA2S,GAEA9G,SAAA3F,IAEAA,EAAAwM,EAAAlG,QAGAkG,EAAAI,OAAA5M,EAAA,EAAA3G,GAgdA,QAAAwT,GAAA7R,GACA,GAAA3B,GAAAxB,EACAyB,EAAArC,CAMA,KAHAoC,EAAA,KAGAxB,EAAAmD,EAAAyP,aAAAnE,OAAA,EAAAzO,GAAA,EAAAA,GAAA,EAMA,GAHAwB,EAAA2B,EAAAyP,aAAA5S,GAGAwB,EAAAyT,OAAA,CAIA,IAAA7V,EAAAoC,EAAAyT,OAAAxG,OAAA,EAAArP,GAAA,EAAAA,GAAA,EAGA,GAFAqC,EAAAD,EAAAyT,OAAA7V,IAEAqC,EAAAyT,WAAA,CAGA1T,EAAA0T,YAAA,CAEA,OAOA,GAAA1T,EAAA0T,aAAA1T,EAAA2T,WAEA,MAWA,MAJA3T,IAAAA,EAAA2T,aAEA3T,EAAA,MAEAA,EAIA,QAAA4T,GAAA3B,EAAArF,EAAA5M,EAAA6T,GACA7T,GAAAA,EAAA8T,SAAA9T,EAAA+T,UACAF,EACA7T,EAAAgU,MAAAH,EAEA7T,EAAAgU,MAAA,KAGAhU,EAAA+T,SACA/T,EAAA+T,QAAA1I,KAAA4G,EAAAjS,IAMA,QAAAiU,GAAAhC,EAAAtQ,EAAAuS,GACA,GAAAjD,GAAAjR,EAAAuS,EACAhO,EAAA4P,EACAhB,EAAAC,EAAAC,EACAe,EAAAC,CAOA,IALA9P,EAAA5C,EAAA4C,KACAvE,EAAAuE,EAAAvE,MACAmU,EAAAnU,GAAAA,EAAAmU,eACAlD,EAAAtP,EAAAsP,OAEA,cAAAiD,GAAA,cAAAA,GA8BA,GA3BA3P,EAAAgN,WAIAhN,EAAAgN,UAAA,EACAvR,EAAAuR,UAAA,EAGAvR,EAAAsU,eAEArD,EAAAsC,OAAAvT,EAAA2G,MAAA,GAGA3G,EAAA2G,MAAAsK,EAAAlE,KAAA/M,IAIAA,EAAAuU,QAAAvU,EAAA7D,EACA6D,EAAAwU,QAAAxU,EAAA5D,EACA4D,EAAAyU,MAAAzU,EAAA0U,QACA1U,EAAA2U,MAAA3U,EAAA4U,QAGApC,EAAAP,EAAAtQ,EAAA3B,EAAA,cAIAuE,EAAAgN,SAAA,CAqBA,GAlBA6C,EAAApU,EAAA0U,SAAA1U,EAAAyU,MAAAzU,EAAAuU,SACAF,EAAArU,EAAA4U,SAAA5U,EAAA2U,MAAA3U,EAAAwU,SACAxU,EAAA6U,cACAT,EAAApU,EAAA6U,YAAAxJ,KAAA4G,EAAA,GAAAjS,EAAAoU,IAEApU,EAAA8U,cACAT,EAAArU,EAAA8U,YAAAzJ,KAAA4G,EAAA,GAAAjS,EAAAqU,IAEArU,EAAA+U,GAAAX,EAAApU,EAAA7D,EACA6D,EAAAgV,GAAAX,EAAArU,EAAA5D,EAEA,MAAA4D,EAAAiV,qBACAjV,EAAA7D,EAAAiY,GAEA,MAAApU,EAAAiV,qBACAjV,EAAA5D,EAAAiY,GAGArU,EAAA2C,cAAA,EAAA,CACA,GAAAuS,GAAAlV,EAAA6C,cACAsS,EAAAnV,EAAA8C,cACAsS,EAAApV,EAAA4C,aACAkC,EAAA9E,EAAA7D,EAAA+Y,EACAnQ,EAAA/E,EAAA5D,EAAA+Y,EACAE,EAAAtQ,EAAAD,CAEA,IAAAA,EAAA,EACA,GAAAwQ,IAAA5Y,GAAAC,KAAAD,GAAAU,IAAAgY,EAAA,IAAA,EAAA1Y,GAAAU,IAAA,EAAA,SAEA,IAAAkY,GAAA5Y,GAAAC,KAAAD,GAAAU,IAAAgY,EAAA,IAAA,EAAA1Y,GAAAU,IAAA,EAAA,IAEA,IAAAmY,GAAAD,EAAAD,EAEAG,EAAAxV,EAAA+C,KACA0S,EAAAzV,EAAAgD,KACA0S,EAAA1V,EAAAiD,KACA0S,EAAA3V,EAAAkD,KACA0S,EAAAxB,EACAyB,EAAAxB,EACAyB,GAAApZ,GAAAU,IAAAoY,EAAA,GAAA9Y,GAAAU,IAAAqY,EAAA,KAAAC,EAAAG,EAAAF,EAAAC,IACAlZ,GAAAU,IAAAsY,EAAA,GAAAhZ,GAAAU,IAAAuY,EAAA,KAAAH,EAAAK,EAAAJ,EAAAG,IACAlZ,GAAAU,IAAAwY,EAAA,GAAAlZ,GAAAU,IAAAyY,EAAA,KAAAL,EAAAG,EAAAF,EAAAC,EAEA,IAAAI,GAAA,EAAA,CACA,GAAAC,GAAArZ,GAAAsZ,IAAAhW,EAAA+C,KAAAqR,GAAA1X,GAAAsZ,IAAAhW,EAAAgD,KAAAqR,GACA4B,EAAAvZ,GAAAsZ,IAAAhW,EAAAiD,KAAAmR,GAAA1X,GAAAsZ,IAAAhW,EAAAkD,KAAAmR,EACA0B,GAAAE,GACAX,EAAAtV,EAAA+C,KAAAmS,EACAK,EAAAvV,EAAAgD,KAAAmS,IAEAG,EAAAtV,EAAAiD,KAAAiS,EACAK,EAAAvV,EAAAkD,KAAAiS,GAIA,GAAAf,GAAAkB,EAAAJ,EACAb,EAAAkB,EAAAJ,CAEAnV,GAAA7D,EAAAiY,EACApU,EAAA5D,EAAAiY,EAQA,IAHA7B,EAAAP,EAAAtQ,EAAA3B,EAAA,QAGAqT,EAAA,EAAAA,EAAAc,EAAAlH,OAAAoG,GAAA,EAIA,GAFAD,EAAAe,EAAAd,GACAF,EAAAxR,EAAA3B,MAAAE,OAAAkT,GACApT,EAAAE,QAAAiT,EAEA,IAAAZ,EAAA,EAAAA,EAAAY,EAAAlG,OAAAsF,GAAA,EACAY,EAAAZ,KAAAvS,IACA,MAAAA,EAAAiV,oBAAA,MAAA9B,EAAAZ,GAAA0C,qBACA9B,EAAAZ,GAAApW,GAAA6D,EAAA+U,IAEA,MAAA/U,EAAAiV,oBAAA,MAAA9B,EAAAZ,GAAA0C,qBACA9B,EAAAZ,GAAAnW,GAAA4D,EAAAgV,UAWA,YAAAd,GAAA,aAAAA,IAGA3P,EAAAgN,WACAvR,EAAAuR,UAAA,EACAhN,EAAAgN,UAAA,EACA5P,EAAAoQ,kBAAApQ,EAAAuU,0BAEA1D,EAAAP,EAAAtQ,EAAA3B,EAAA,aAIA2B,EAAA4C,SAuBA,QAAA4R,GAAAlE,EAAAjS,EAAAkU,GACA,GAAA5C,EACAtR,GAAAoS,UAEAd,EAAAtR,EAAAoS,QAAA8B,IAGApU,EAAAsW,QAAA9E,EAAA7K,GAAA2L,gBACAd,EAAA7K,GAAA4P,OAAA/E,GAGAA,GAEAW,EAAAxL,KACA6K,OAAAA,IAMA,QAAAgF,GAAArE,EAAAtQ,GACAsQ,EAAAxL,KACA6K,OAAA3P,EAAA2P,SAKA,QAAAiF,GAAAtE,EAAAjS,EAAAkU,EAAAsC,EAAAC,GAEAD,EAAAtC,IAAAlU,EAAA0W,WAAA1W,EAAA0W,SAAAxC,KAEAlU,EAAA0W,SAAAxC,IAAA,EAEAsC,EAAAtC,GAAA7I,KAAA4G,EAAA,GAAAjS,EAAAyW,GAEAzW,EAAA0W,SAAAxC,IAAA,GAKA,QAAAyC,GAAA3W,EAAAkU,GAGA,QAAAlU,EAAA4W,eACA5W,EAAA2T,YAAA7T,EAAAsW,QAAAlC,EAAA2C,UAIA,QAAArE,GAAAP,EAAAtQ,EAAA3B,EAAAkU,EAAAuC,GAEAE,EAAA3W,EAAAkU,KAGA,aAAAA,GAEAiC,EAAAlE,EAAAjS,EAAAkU,GAIAqC,EAAAtE,EAAAjS,EAAAkU,EAAAlU,EAAAyW,GAEAF,EAAAtE,EAAAjS,EAAAkU,EAAAvS,EAAAwP,WAAAsF,GAEAF,EAAAtE,EAAAjS,EAAAkU,EAAA/B,GAAAhB,WAAAsF,IAsMA,QAAAK,GAAAjX,EAAAqL,EAAAF,EAAA+L,GACA,GAAA9E,GAAAtQ,EACAsP,EAAAjR,EAAAkL,EAAA8L,OAAAhM,EAAAE,CAmGA,OAhGAA,GAAAkE,MAAApE,GAGAE,EAAAzI,WAAAyI,EAAAiJ,cACAjJ,EAAAlL,OAAA,EACAkL,EAAAzI,WAAA,GAIAyI,EAAA6I,UACAgD,EACA7L,EAAA6I,QAAAgD,EACA7L,EAAA6L,OACA7L,EAAA6I,QAAAjU,EAAAmX,GAAA/L,EAAA6L,QACA7L,EAAAuG,OACAvG,EAAA6I,QAAAjU,EAAAmX,GAAAC,GAAAC,SAAAjM,EAAAuG,SAKAvG,EAAAlL,QAAAkL,EAAA8L,QAGA/E,EAAAnS,EAAAD,GAEA8B,EAAAkO,EAAAhQ,GACAoR,EAAAtP,EAAAsP,QAGA,OAAAjR,EAAAS,MAAAgL,EAAAzL,EAAAS,OAAA6L,SAAA3K,EAAA3B,MAAAkR,MAAAlR,EAAAS,SAGAyL,EAAAhB,GAGAlL,EAAA,GAAA+K,GAAAG,GACAlL,EAAAH,OAAAA,EAEAG,EAAAA,OAAA,EACAA,EAAAgX,QAAA,EACAhX,EAAA0W,YAEA,OAAA1W,EAAA2B,KAEA3B,EAAA2B,KAAA4J,MAAAvL,EAAA2B,MAGA3B,EAAA2B,QAGA,OAAA3B,EAAAE,OAEAF,EAAAE,OAAAF,EAAAE,OAAArC,MAAA,GAGAmC,EAAAE,UAIA8S,EAAAf,EAAAtQ,EAAA3B,GACAkT,EAAAjB,EAAAtQ,EAAA3B,GAGAgS,EAAAC,EAAAtQ,EAAA3B,GAGA8S,EAAAb,EAAAtQ,EAAA3B,GAGAkL,EAAA2H,OAAA7S,EAAA6S,OAGA7S,EAAA+T,UAAAjU,EAAAmX,GAAAxR,UACAwM,EAAAmF,YAAApX,GAIA,OAAAA,EAAA2G,QACA3G,EAAA2G,MAAAsK,EAAAhE,QAIAgE,EAAAsC,OAAAvT,EAAA2G,MAAA,EAAA3G,GAGAkL,EAAAkE,MAAApP,EAGAwS,EAAAP,EAAAtQ,EAAA3B,EAAA,SAIAkL,EAAAlL,OACAkM,EAAAhB,GAGAlL,EAiCA,QAAAqX,GAAAC,GACA,GAAAC,GAAAC,CACA,KAAAA,EAAA,EAAAA,EAAA/Q,GAAA0F,MAAAc,OAAAuK,GAAA,EACAD,EAAA9Q,GAAA0F,MAAAqL,GACAF,EAAAC,GAAAD,EAAA,IAAAC,GAGA,QAAAE,GAAAH,EAAAI,GACA,GAAAH,GAAAC,CACA,KAAAA,EAAA,EAAAA,EAAA/Q,GAAA0F,MAAAc,OAAAuK,GAAA,EACAD,EAAA9Q,GAAA0F,MAAAqL,GAEAlL,SAAAgL,EAAAC,KACAD,EAAA,IAAAC,GAAAD,EAAAC,GACA9Q,GAAAkR,SAAAJ,IAAA,EACAG,SACAJ,GAAAC,IAOA,QAAAK,GAAA/X,EAAAG,EAAA6X,GACA,GAAA5M,GAAAoB,EACAyL,EAAAC,CAEA,KAAA9M,IAAA4M,GACA,GAAA1M,OAAA5C,UAAA6C,eAAAC,KAAAwM,EAAA5M,KACAoB,EAAAwL,EAAA5M,GAEAsC,GAAAlB,KAEAwL,EAAA5M,GAAAoB,EAAAhB,KAAAxL,EAAAG,EAAAiL,IAGA,WAAAU,GAAAU,IAAA2L,GAAA3L,IAAA,CAEA,IAAAyL,IAAAzL,GACAlB,OAAA5C,UAAA6C,eAAAC,KAAAgB,EAAAyL,KACAC,EAAA1L,EAAAyL,GAEAxL,SAAAtM,EAAAiL,KACAjL,EAAAiL,EAAA,IAAA6M,GAAA9X,EAAAiL,GAAA6M,GAEAD,EAAA5M,EAAA,IAAA6M,GAAAC,UAKAF,GAAA5M,GAIA,MAAA4M,GAIA,QAAAI,GAAAjY,GACA,GAAAiL,EACA,KAAAA,IAAAjL,GACAmL,OAAA5C,UAAA6C,eAAAC,KAAArL,EAAAiL,IACAA,EAAAiN,QAAA,iBACAlY,GAAAiL,GAOA,QAAAkN,GAAAha,GACA,GAAAia,GAAAC,EACApa,KACAqa,EAAA,CA8BA,OA3BA,gBAAAna,EACAA,EAAA,mBACAA,EAAAL,MAAA,6BAEAua,EAAAE,GAAAC,KACAJ,EAAAC,EAAAI,MAAAta,MACAka,EAAAI,MAAAta,MAAAA,EACAA,EAAA2B,EAAA2G,IAAA4R,EAAA,SACAA,EAAAI,MAAAta,MAAAia,GAGAja,EAAAL,MAAA,YACAG,EAAAE,EAAAL,MAAA,mBAEAK,EAAAL,MAAA,SACAwa,EAAA,MAEAra,EAAA,IAAAqa,EACAra,EAAA,IAAAqa,EACAra,EAAA,IAAAqa,EAEAhM,SAAArO,EAAA,GACAA,EAAA,GAAA8N,GAAA9N,EAAA,IAEAA,EAAA,GAAA,GAGAA,EAIA,QAAAya,GAAAC,GACA,GACAna,GADAoa,EAAA,CAeA,KAZA,UAAAjN,GAAAgN,EAAAvY,SACAuY,EAAAvY,MAAA+X,EAAAQ,EAAAvY,OACAuY,EAAAtY,IAAA8X,EAAAQ,EAAAtY,MAEAsY,EAAAE,OAGA,IAAAF,EAAAvY,MAAA,IAAA,IAAAuY,EAAAtY,IAAA,KACAuY,EAAA,GAIApa,EAAA,EAAAA,EAAAoa,EAAApa,GAAA,EACAma,EAAAE,IAAAra,GAAAma,EAAAvY,MAAA5B,IAAAma,EAAAtY,IAAA7B,GAAAma,EAAAvY,MAAA5B,IAAAma,EAAAG,IAEAta,EAAA,IACAma,EAAAE,IAAAra,GAAAua,GAAAJ,EAAAE,IAAAra,IAGA,KAAAma,EAAAvY,MAAA,IAAA,IAAAuY,EAAAtY,IAAA,GAEAsY,EAAAE,IAAA,QAAAF,EAAAE,IAAAG,KAAA,KAAA,KAGAL,EAAAE,IAAAhb,MAAA,EAAA,GACA8a,EAAAE,IAAA,OAAAF,EAAAE,IAAAG,KAAA,KAAA,KAGAL,EAAAN,KAAAY,SACAN,EAAAN,KAAAI,MAAAE,EAAAO,MAAAP,EAAAE,IAEAF,EAAAN,KAAAM,EAAAO,MAAAP,EAAAE,IA0SA,QAAAM,GAAAhN,GACA,GAAAqL,EACA,KAAAA,EAAA,EAAAA,EAAArL,EAAAc,OAAAuK,GAAA,EACA1X,EAAA6Y,GAAAS,KAAAjN,EAAAqL,IAAAkB,EAmCA,QAAAW,GAAAnH,GAKA,MAHAgF,IAAAoC,YAAApH,KACAA,EAAAgF,GAAAoC,YAAApH,IAEAA,EAGA,QAAAqH,GAAArH,GAIA,MAHAgF,IAAAsC,YAAAtH,KACAA,EAAAgF,GAAAsC,YAAAtH,IAEAA,EAIA,QAAAuH,GAAAvH,GAEAC,GAAAT,OAAAQ,GAAA,SAAAD,EAAAtQ,GAUA,QAAA+X,GAAAlI,GAEAmI,EAAAxd,EAAAqV,EAAAoI,QACAD,EAAAvd,EAAAoV,EAAAqI,QACAF,EAAAlI,KAAAqI,EACAH,EAAAnI,MAAAA,GAIA,cAAAA,EAAAC,MAAA9P,EAAAoQ,mBAAApQ,EAAA4C,KAAAgN,WACAU,EAAAU,YACAoH,WAAA,IAIAvI,EAAA1I,iBAxBA,GAAAgR,GAAAE,EAAAL,CAGAA,GAAAhY,EAAA6P,MAGAsI,EAAA,cAAA5H,GAAA,aAAAA,EAAA,YAAAA,EACA8H,EAAAX,EAAAS,GAqBAnY,EAAA+P,OAAAoI,KAEAE,IAAAF,EACA7H,EAAAK,KAAAwH,EAAA,YAAAE,EAAA,WAAAN,GAEAzH,EAAAK,KAAAwH,EAAA,WAAAJ,GAGA/X,EAAA+P,OAAAoI,IAAA,IAIA,QAAAG,GAAAC,GACA,GAAAtB,EACA,KAAAA,EAAA,EAAAA,EAAAsB,EAAAjN,OAAA2L,GAAA,EACAa,EAAAS,EAAAtB,IAsBA,QAAAuB,GAAAta,EAAA+M,EAAA1B,GACA,GAAAlL,GAAA2B,EAAAgY,EAAAjG,EACAjH,EAAAtQ,EAAAC,EAAA6F,CAGAjC,GAAAkL,EAAAkE,MAEApP,IAEA2B,EAAAkO,EAAAhQ,GACA8Z,EAAAhY,EAAA6P,MACA,OAAAmI,EAAAxd,GAAA,OAAAwd,EAAAvd,IAEAD,EAAAwd,EAAAxd,EAAAwF,EAAAkQ,WACAzV,EAAAud,EAAAvd,EAAAuF,EAAAkQ,WAEA6B,EAAA9G,EAAAwN,cAAAje,EAAAC,IAAAwQ,EAAAyN,iBAAAzN,EAAAyN,gBAAAle,EAAAC,IAEAqQ,EAAA9K,EAAA8K,WAGAzM,EAAAY,OAAA+Y,EAAAxd,EACA6D,EAAAa,OAAA8Y,EAAAvd,EACA4D,EAAAwR,MAAAmI,EAAAnI,MAKAvP,EAAAN,EAAA8K,WAAA0D,OACAhU,EAAA6D,EAAAY,OACAxE,EAAA4D,EAAAa,OAEA,IAAAoB,GAEAjC,EAAA0U,QAAAvY,EAAAme,IAAArY,GAAA7F,EAAAme,IAAAtY,GACAjC,EAAA4U,QAAAxY,EAAAke,IAAArY,GAAA9F,EAAAoe,IAAAtY,KAGAjC,EAAA0U,QAAAvY,EACA6D,EAAA4U,QAAAxY,GAIA4D,EAAA0U,SAAAjI,EAAA6D,OACAtQ,EAAA4U,SAAAnI,EAAA8D,OAGAmD,GAEA/R,EAAAyP,aAAArE,KAAA/M,GAEAA,EAAA0T,WAAAnK,QAAAmK,IA4LA,QAAAtD,GAAAxD,EAAA1B,EAAAuB,GAGAvB,EAAA6E,OAAA7E,EAAA8E,UAAAjT,GAAA,IAAA,EAGA6P,EAAA6D,UAAAvF,EAAA/O,EAAA+O,EAAA9O,GACAwQ,EAAAuD,OAAAjF,EAAAiF,OAAAjF,EAAA6E,QACAnD,EAAA6D,WAAAvF,EAAA/O,GAAA+O,EAAA9O,GAGAqQ,IAEAA,EAAA0D,QAAAjF,EAAAiF,OAAAjF,EAAA6E,QAKA,QAAAS,GAAA5D,EAAA1B,EAAAuB,GAGA,IAAAvB,EAAAmF,QACAnF,EAAAoF,OAAApF,EAAAqF,OAAArF,EAAAmF,OAIAzD,EAAA6D,UAAAvF,EAAA/O,EAAA+O,EAAA9O,GACAwQ,EAAAyD,MAAAnF,EAAAoF,OAAApF,EAAAqF,QACA3D,EAAA6D,WAAAvF,EAAA/O,GAAA+O,EAAA9O,GAGAqQ,IAEAA,EAAA6D,QAAApF,EAAAoF,OACA7D,EAAA8D,QAAArF,EAAAqF,QAKA,QAAAK,GAAAhE,EAAA1B,EAAAuB,GAGAvB,EAAAuF,YACAvF,EAAAwF,WAAAxF,EAAAyF,WAAAzF,EAAAuF,WAIA7D,EAAA6D,UAAAvF,EAAAwF,WAAAxF,EAAAyF,YAGAlE,IAEAA,EAAAiE,YAAAxF,EAAAwF,WACAjE,EAAAkE,YAAAzF,EAAAyF,YAuKA,QAAA6J,GAAAvY,GACA,KAAAA,EAAA,GACAA,GAAA,EAAAlF,EAEA,OAAAkF,GAIA,QAAAwY,GAAAvP,EAAAjJ,GACA,MAAAiJ,GAAA/O,EAAA+O,EAAAhO,OAAAod,GAAArY,GAGA,QAAAyY,GAAAxP,EAAAjJ,GACA,MAAAiJ,GAAA9O,EAAA8O,EAAAhO,OAAAqd,GAAAtY,GAIA,QAAA0Y,GAAA9a,EAAA+M,EAAA1B,EAAA0P,GACA,GAAA9V,GAAAC,EAAAC,EAAAC,EACA4V,EAAAC,EAAAC,EAAAC,EACApB,EAAAC,EACAoB,CAGA/P,KAAA0P,GACAhB,EAAA,EACAC,EAAA,IAEAD,EAAA1O,EAAA/O,EACA0d,EAAA3O,EAAA9O,GAIAwe,EAAA5K,WAAA,MAAA4K,EAAAva,MACAua,EAAAva,IAAA,EAAAtD,IAIA6d,EAAAxa,OAAA8K,EAAA6E,OACA6K,EAAAva,KAAA6K,EAAA6E,OAEA6K,EAAAxa,OAAArD,GAAA,EACA6d,EAAAva,KAAAtD,GAAA,EAGAke,EAAAle,GAAA,IACA6d,EAAAM,MACAD,OAIAnW,EAAA2V,EAAAG,EAAAA,EAAAxa,MAAA6a,GACAlW,EAAA2V,EAAAE,EAAAA,EAAAxa,MAAA6a,GACAjW,EAAAyV,EAAAG,EAAAA,EAAAxa,OACA6E,EAAAyV,EAAAE,EAAAA,EAAAxa,OAEA+a,EACAtb,EAAA+M,EACA1B,EAAA0P,EACA9V,EAAAC,EACAC,EAAAC,GAIA2H,EAAAwO,IAAAR,EAAAze,EAAAyd,EAAAgB,EAAAxe,EAAAyd,EAAAe,EAAA1d,OAAA0d,EAAAxa,MAAAwa,EAAAva,IAAAua,EAAAM,KAGAL,EAAAJ,EAAAG,EAAAA,EAAAva,IAAA4a,GACAH,EAAAJ,EAAAE,EAAAA,EAAAva,IAAA4a,GACAF,EAAAN,EAAAG,EAAAA,EAAAva,KACA2a,EAAAN,EAAAE,EAAAA,EAAAva,KAEAgb,GACAxb,EAAA+M,EACA1B,EAAA0P,EACAG,EAAAC,EACAH,EAAAC,GA2MA,QAAAQ,GAAAzb,EAAA+M,EAAA1B,EAAA0P,EAAA9V,EAAAC,EAAAC,EAAAC,GACA,GAAAsW,GAAAC,EACAC,EAAAC,EACA9B,EAAAC,EACA5X,CAGA2Y,GAAAe,cAAAzQ,EAAAsE,SAGAvN,EAAApF,GAAAoI,EAAAF,EAAAC,EAAAF,GAEA7C,GAAAlF,GAEA6c,EAAA1O,EAAA3K,YAAA+Z,GAAArY,GACA4X,EAAA3O,EAAA3K,YAAAga,GAAAtY,GAGAsZ,EAAAvW,EAAA4V,EAAAe,YAAArB,GAAArY,EAAA2Y,EAAAgB,WAAA,GACAJ,EAAAvW,EAAA2V,EAAAe,YAAApB,GAAAtY,EAAA2Y,EAAAgB,WAAA,GAEAH,EAAAzW,EAAA4V,EAAAe,YAAArB,GAAArY,EAAA2Y,EAAAgB,WAAA,GACAF,EAAAzW,EAAA2V,EAAAe,YAAApB,GAAAtY,EAAA2Y,EAAAgB,WAAA,GAGAhP,EAAAiP,OAAAN,EAAA3B,EAAA4B,EAAA3B,GACAjN,EAAAkP,OAAA9W,EAAA4U,EAAA3U,EAAA4U,GAEAjN,EAAAkP,OAAAL,EAAA7B,EAAA8B,EAAA7B,GAGAjN,EAAAiP,OAAA7W,EAAA4U,EAAA3U,EAAA4U,GACAjN,EAAAkP,OAAA9W,EAAA4U,EAAA3U,EAAA4U,GAEAjN,EAAAiP,OAAA7W,EAAAC,IAMA,QAAAkW,GAAAtb,EAAA+M,EAAA1B,EAAA0P,EAAA9V,EAAAC,EAAAC,EAAAC,GACA2V,EAAAmB,uBACAnB,EAAAgB,YAAA1Q,EAAA6E,OACA6K,EAAAmB,sBAAA,GAEAnB,EAAAoB,YACAV,EAAAzb,EAAA+M,EAAA1B,EAAA0P,EAAA9V,EAAAC,EAAAC,EAAAC,GAKA,QAAAoW,IAAAxb,EAAA+M,EAAA1B,EAAA0P,EAAA9V,EAAAC,EAAAC,EAAAC,GACA2V,EAAAmB,uBACAnB,EAAAgB,YAAA1Q,EAAA6E,OACA6K,EAAAmB,sBAAA,GAEAnB,EAAAqB,UACAX,EAAAzb,EAAA+M,EAAA1B,EAAA0P,EAAA9V,EAAAC,EAAAC,EAAAC,GAKA,QAAAiX,IAAArc,EAAA+M,EAAA1B,EAAA0P,GACA,GAAArI,GACA4J,EAAAC,CAaA,KAZA7J,EAAA,EACA4I,EACAtb,EAAA+M,EACA1B,EAAA0P,EACAA,EAAA5V,GAAAkG,EAAA/O,EACAye,EAAA3V,GAAAiG,EAAA9O,EACAwe,EAAA9V,GAAAoG,EAAA/O,EACAye,EAAA7V,GAAAmG,EAAA9O,GAEAkQ,SAAAsO,EAAA9V,IAAAwH,SAAAsO,EAAA7V,IACA6H,EAAAiP,OAAAjB,EAAA9V,GAAAoG,EAAA/O,EAAAye,EAAA7V,GAAAmG,EAAA9O,KAEA,CAKA,GAHA+f,EAAAvB,EAAA,IAAArI,GACA6J,EAAAxB,EAAA,IAAArI,GAEAjG,SAAA6P,GAAA7P,SAAA8P,EAMA,KAJAxP,GAAAkP,OAAAK,EAAAjR,EAAA/O,EAAAigB,EAAAlR,EAAA9O,GACAmW,GAAA,EAMAA,GAAA,EAEA8I,GACAxb,EAAA+M,EACA1B,EACA0P,EACAA,EAAA,KAAArI,EAAA,IAAArH,EAAA/O,EACAye,EAAA,KAAArI,EAAA,IAAArH,EAAA9O,EACAwe,EAAA,IAAArI,GAAArH,EAAA/O,EACAye,EAAA,IAAArI,GAAArH,EAAA9O,GAoCA,QAAAigB,IAAAxc,EAAA+M,EAAA1B,EAAA0P,GACA,GAAArI,GACA4J,EAAAC,EACAE,EAAAC,CAkBA,KAhBAhK,EAAA,EAEA4I,EACAtb,EACA+M,EACA1B,EACA0P,EACAA,EAAA4B,IAAAtR,EAAA/O,EACAye,EAAA6B,IAAAvR,EAAA9O,EACAwe,EAAA9V,GAAAoG,EAAA/O,EACAye,EAAA7V,GAAAmG,EAAA9O,GAGAkQ,SAAAsO,EAAA9V,IAAAwH,SAAAsO,EAAA7V,IACA6H,EAAAiP,OAAAjB,EAAA9V,GAAAoG,EAAA/O,EAAAye,EAAA7V,GAAAmG,EAAA9O,KAEA,CAOA,GALA+f,EAAAvB,EAAA,IAAArI,GACA6J,EAAAxB,EAAA,IAAArI,GACA+J,EAAA1B,EAAA,MAAArI,EAAA,IACAgK,EAAA3B,EAAA,MAAArI,EAAA,IAEAjG,SAAA6P,GAAA7P,SAAA8P,GAAA9P,SAAAgQ,GAAAhQ,SAAAiQ,EAMA,KAJA3P,GAAA8P,iBAAAJ,EAAApR,EAAA/O,EAAAogB,EAAArR,EAAA9O,EAAA+f,EAAAjR,EAAA/O,EAAAigB,EAAAlR,EAAA9O,GACAmW,GAAA,EAMAA,GAAA,EACA8I,GACAxb,EACA+M,EACA1B,EACA0P,EACAA,EAAA,MAAArI,EAAA,IAAArH,EAAA/O,EACAye,EAAA,MAAArI,EAAA,IAAArH,EAAA9O,EACAwe,EAAA,IAAArI,GAAArH,EAAA/O,EACAye,EAAA,IAAArI,GAAArH,EAAA9O,GAmCA,QAAAugB,IAAA9c,EAAA+M,EAAA1B,EAAA0P,GACA,GAAArI,GAAAqK,EACAT,EAAAC,EACAS,EAAAC,EACAC,EAAAC,CAmBA,KAjBAzK,EAAA,EACAqK,EAAA,EAEAzB,EACAtb,EACA+M,EACA1B,EACA0P,EACAA,EAAA4B,IAAAtR,EAAA/O,EACAye,EAAA6B,IAAAvR,EAAA9O,EACAwe,EAAA9V,GAAAoG,EAAA/O,EACAye,EAAA7V,GAAAmG,EAAA9O,GAGAkQ,SAAAsO,EAAA9V,IAAAwH,SAAAsO,EAAA7V,IACA6H,EAAAiP,OAAAjB,EAAA9V,GAAAoG,EAAA/O,EAAAye,EAAA7V,GAAAmG,EAAA9O,KAEA,CASA,GAPA+f,EAAAvB,EAAA,IAAArI,GACA6J,EAAAxB,EAAA,IAAArI,GACAsK,EAAAjC,EAAA,KAAAgC,GACAE,EAAAlC,EAAA,KAAAgC,GACAG,EAAAnC,EAAA,MAAAgC,EAAA,IACAI,EAAApC,EAAA,MAAAgC,EAAA,IAEAtQ,SAAA6P,GAAA7P,SAAA8P,GAAA9P,SAAAuQ,GAAAvQ,SAAAwQ,GAAAxQ,SAAAyQ,GAAAzQ,SAAA0Q,EAOA,KALApQ,GAAAqQ,cAAAJ,EAAA3R,EAAA/O,EAAA2gB,EAAA5R,EAAA9O,EAAA2gB,EAAA7R,EAAA/O,EAAA6gB,EAAA9R,EAAA9O,EAAA+f,EAAAjR,EAAA/O,EAAAigB,EAAAlR,EAAA9O,GACAmW,GAAA,EACAqK,GAAA,EAMArK,GAAA,EACAqK,GAAA,EACAvB,GACAxb,EACA+M,EACA1B,EACA0P,EACAA,EAAA,MAAAgC,EAAA,IAAA1R,EAAA/O,EACAye,EAAA,MAAAgC,EAAA,IAAA1R,EAAA9O,EACAwe,EAAA,IAAArI,GAAArH,EAAA/O,EACAye,EAAA,IAAArI,GAAArH,EAAA9O,GAmCA,QAAA8gB,IAAAhS,EAAAjJ,EAAAgL,GAGA,MAFAhL,IAAAiJ,EAAA6E,OACA9N,GAAAlF,GAAA,EACAkQ,EAAAqN,GAAArY,GAGA,QAAAkb,IAAAjS,EAAAjJ,EAAAgL,GAGA,MAFAhL,IAAAiJ,EAAA6E,OACA9N,GAAAlF,GAAA,EACAkQ,EAAAsN,GAAAtY,GAIA,QAAAmb,IAAAvd,EAAA+M,EAAA1B,EAAA0P,GACA,GAAArI,GAAAtQ,EAAAgL,EACA2M,EAAAC,EACA1d,EAAAC,EACAye,EAAAC,EACAC,EAAAC,CA4BA,KAzBA9P,IAAA0P,GACAhB,EAAA,EACAC,EAAA,IAEAD,EAAA1O,EAAA/O,EACA0d,EAAA3O,EAAA9O,GAGAmW,EAAA,EACApW,EAAA0e,EAAAE,EAAAH,EAAAze,EAAAyd,EACAxd,EAAA0e,EAAAE,EAAAJ,EAAAxe,EAAAyd,EAEAsB,EACAtb,EAAA+M,EACA1B,EAAA0P,EACAze,EAAA+gB,GAAAhS,EAAA0P,EAAA9Y,GAAA8Y,EAAA7Y,IACA3F,EAAA+gB,GAAAjS,EAAA0P,EAAA9Y,GAAA8Y,EAAA7Y,IACA5F,EACAC,GAIAkQ,SAAAsO,EAAAze,GAAAmQ,SAAAsO,EAAAxe,GACAwQ,EAAAiP,OAAA1f,EAAAC,KAEA,CAKA,GAHA6F,EAAA2Y,EAAA,IAAArI,GACAtF,EAAA2N,EAAA,IAAArI,GAEAjG,SAAArK,GAAAqK,SAAAW,EAYA,KATA4N,GAAAE,EACAD,EAAAE,EAEAD,GAAAmC,GAAAhS,EAAAjJ,EAAAgL,GACA+N,GAAAmC,GAAAjS,EAAAjJ,EAAAgL,GACAL,EAAAkP,OAAAf,EAAAC,GACAzI,GAAA,EAOA8I,GACAxb,EAAA+M,EACA1B,EAAA0P,EACAC,EAAAC,EACAC,EAAAC,GAyFA,QAAAqC,IAAAxd,EAAA+M,EAAA1B,GAEAW,MAAAC,GAAAZ,EAAAxF,aAEAwF,EAAAxF,UAAA,MAGAkH,EAAA0Q,KAAApS,EAAAqS,UAAA,IAAArS,EAAAxF,SAAA,IAAAwF,EAAAvF,WAIA,QAAA6X,IAAA3d,EAAA+M,EAAA1B,EAAAuS,GACA,GAAAC,GAAAC,EAAApL,EACAqL,EAAA9M,GAAA8M,SAGA,IAAAA,EAAA1c,OAAAgK,EAAAhK,MAAA0c,EAAAL,YAAArS,EAAAqS,WAAAK,EAAAlY,WAAAwF,EAAAxF,UAAAkY,EAAAjY,aAAAuF,EAAAvF,YAAAiY,EAAAhY,WAAAsF,EAAAtF,UAAAgY,EAAAC,aAAA3S,EAAA2S,WAEA3S,EAAA5F,MAAAsY,EAAAtY,MACA4F,EAAA3F,OAAAqY,EAAArY,WAEA,CAOA,IAHA2F,EAAA5F,MAAAsH,EAAAwK,YAAAqG,EAAA,IAAAnY,MAGAiN,EAAA,EAAAA,EAAAkL,EAAAxQ,OAAAsF,GAAA,EAEAoL,EAAA/Q,EAAAwK,YAAAqG,EAAAlL,IAAAjN,MAEAqY,EAAAzS,EAAA5F,QACA4F,EAAA5F,MAAAqY,EAMAD,GAAA7d,EAAA4Y,MAAA/S,SAEA7F,EAAA4Y,MAAA/S,SAAAwF,EAAAxF,SAEAwF,EAAA3F,OAAAwG,GAAAjM,EAAA2G,IAAA5G,EAAA,aAAA4d,EAAAxQ,OAAA/B,EAAA2S,WAEAhe,EAAA4Y,MAAA/S,SAAAgY,GAKA,QAAAI,IAAAlR,EAAA1B,GACA,GAQAuS,GAAAM,EAAAxL,EACArR,EAAA8c,EAAAlT,EATAmT,EAAA1R,OAAArB,EAAAhK,MAEA0E,EAAAsF,EAAAtF,SAEAsY,EAAAD,EAAAE,MAAA,MAEAC,IAMA,KAAA7L,EAAA,EAAAA,EAAA2L,EAAAjR,OAAAsF,GAAA,EAAA,CAUA,GARArR,EAAAgd,EAAA3L,GAEAyL,EAAA9c,EAAAid,MAAA,KACAV,KACAM,EAAA,GAIA,IAAAC,EAAA/Q,QAAAL,EAAAwK,YAAAlW,GAAAoE,MAAAM,EAGA6X,GAAAvc,OAEA,CAGA,IAAA4J,EAAA,EAAAA,EAAAkT,EAAA/Q,OAAAnC,GAAA,EAGA8B,EAAAwK,YAAA2G,EAAAC,EAAAlT,IAAAxF,MAAAM,IAEA,KAAAmY,GACAN,EAAA1Q,KAAAgR,GAGAA,EAAA,IAGAA,GAAAC,EAAAlT,GAEAA,IAAAkT,EAAA/Q,OAAA,IACA8Q,GAAA,IAIAN,GAAA1Q,KAAAgR,GAIAK,EAAAA,EAAAC,OACAZ,EACAzE,KAAA,MACAvQ,QAAA,eAAA,MACA0V,MAAA,OAKA,MAAAC,GAjkHA,GASAE,IATA/F,GAAA/O,EAAA+O,SACAgG,GAAA/U,EAAA+U,MACAC,GAAAhV,EAAAgV,MACAC,GAAAjV,EAAAiV,iBACA/hB,GAAA8M,EAAA9M,KACAoP,GAAAtC,EAAAsC,OACAC,GAAAvC,EAAAuC,WAKAR,GAAAzL,EAAA4e,OACAtI,GAAAtW,EAAAsW,QACAzK,GAAA,SAAAD,GACA,MAAAP,QAAA5C,UAAAoW,SAAAtT,KAAAK,GACA7N,MAAA,MAAA+gB,eAEArR,GAAAzN,EAAAyN,WACAyK,GAAAlY,EAAAkY,cAEAjb,GAAAL,GAAAK,GACAgc,GAAArc,GAAAqc,MACA/C,GAAAtZ,GAAAsZ,IACAuE,GAAA7d,GAAA6d,IACAD,GAAA5d,GAAA4d,IACAzd,GAAAH,GAAAG,MAEAgiB,GAAAL,GAAAjW,UAAA1K,MAEAihB,GAAAhf,EAAA0R,MAAAuN,IAEA7H,MAEApG,IACAD,aACA+M,aACAoB,eAGA9R,IACAiD,OAAA,EACAG,OAAA,EACAC,OAAA,EACAG,WAAA,EACAC,WAAA,EAEAjE,UAGAjG,MACAoQ,IACA,YACA,YACA,UACA,YACA,WACA,aACA,YACA,YAkBA1E,IAEAT,UAEAP,cAEA8N,UAOA3T,GAAAE,cACA0T,MAAA,SACAtD,WAAA,GACAD,YAAA,EACAzM,UAAA,EACAiQ,SAAA,SACA7K,cAAA,EACA4G,KAAA,EACA1L,QAAA,EACAV,YAAA,cACAsQ,UAAA,EACA5Z,aAAA,EACA6Z,MAAA,EACAC,gBAAA,EACAC,YAAA,KACAnN,QAAA,KACAwE,eAAA,EACAnU,WAAA,EACA0R,WAAA,KACAjU,OAAA,KACAyB,KAAA,KACAoT,GAAA,KACAC,GAAA,KACA3U,IAAA,IACAO,OAAA,KACAC,OAAA,KACAV,UAAA,cACAod,UAAA,SACA7X,SAAA,OACAC,WAAA,aACAsK,YAAA,EACA1K,OAAA,KACAwJ,gBAAA,EACAiB,WAAA,EACA2D,YAAA,EACAhN,MAAA,KACA6Y,cAAA,KACA3B,WAAA,EACA7d,OAAA,EACAC,MAAA,EACA2F,SAAA,KACAmI,WAAA,GACAtN,KAAA,KACAmO,QAAA,EACA6Q,GAAA,KACAC,GAAA,KACAxiB,OAAA,EACAyiB,OAAA,SACAC,cAAA,EACA3K,mBAAA,KACA9E,OAAA,EACAzC,SAAA,EACA2C,MAAA,EACAC,OAAA,EACAC,OAAA,EACAlP,WAAA,EACAC,YAAA,cACAoO,cAAA,EACAlB,QAAA,EACAE,QAAA,EACAmR,QAAA,KACAC,MAAA,EACAC,OAAA,GACAC,OAAA,EACA5f,MAAA,EACAyN,UAAA,OACAG,WAAA,KACAM,iBAAA,EACAR,WAAA,QACAxN,YAAA,cACAC,YAAA,EACA0f,OAAA,KACAC,GAAA,KACAC,GAAA,KACAjf,KAAA,GACAuP,UAAA,EACAC,WAAA,EACAC,WAAA,EACAc,KAAA,KACAqC,SAAA,EACAxO,MAAA,KACAnJ,EAAA,EACAC,EAAA,GAEAkiB,GAAA,GAAAhT,GACAP,EAAAxC,UAAA+V,GA0OAnM,GAAAuM,OAAA,SAAA0B,GAiCA,MA9BAA,GAAA3f,OAEA2f,EAAAjU,OACAZ,GAAA+S,GAAA8B,EAAAjU,OAGArM,EAAAmX,GAAAmJ,EAAA3f,MAAA,QAAA4f,GAAArV,GACA,GAAAnL,GAAAgJ,EAAA+D,EACA1B,EADAoV,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAhJ,EAAAygB,EAAAzX,GACA+D,EAAAZ,EAAAnM,GACA+M,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAjX,EAAAqL,EAAAF,EAAAqV,GAEA7S,EAAA3N,EAAA+M,EAAA1B,GACAkV,EAAAnJ,GAAA5L,KAAAxL,EAAA+M,EAAA1B,GAIA,OAAAoV,IAGAF,EAAA3O,OACAyF,GAAAC,SAAAiJ,EAAA3O,MAAA2O,EAAA3f,OAGAX,EAAAmX,GAAAmJ,EAAA3f,OAsPAX,EAAAmX,GAAAsJ,cAAA,WACA,GAAA1gB,GAAA8B,EAAA2e,EAAAvX,KACAoI,IAOA,OALA,KAAAmP,EAAArT,SACApN,EAAAygB,EAAA,GACA3e,EAAAkO,EAAAhQ,GACAsR,EAAAxP,EAAAwP,YAEAA,GAIArR,EAAAmX,GAAAuJ,cAAA,SAAArP,GACA,GAAAtI,GACAlH,EADA2e,EAAAvX,IAEA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAlH,EAAAkO,EAAAyQ,EAAAzX,IACA0C,GAAA5J,EAAAwP,WAAAA,EAEA,OAAAmP,IAIAxgB,EAAAmX,GAAAlQ,UAAA,SAAA0Z,GACA,GAAA5gB,GAAA8B,EACAsP,EAAAjR,EAAAuS,EADA+N,EAAAvX,KAEA2X,IAEA,IAAA,IAAAJ,EAAArT,OAQA,GANApN,EAAAygB,EAAA,GACA3e,EAAAkO,EAAAhQ,GAEAoR,EAAAtP,EAAAsP,OAGA1D,GAAAkT,GAGA,IAAAlO,EAAA,EAAAA,EAAAtB,EAAAhE,OAAAsF,GAAA,EACAvS,EAAAiR,EAAAsB,GACAkO,EAAApV,KAAAxL,EAAAG,IAEA0gB,EAAA3T,KAAA/M,OAOA0gB,GAAAzP,CAKA,OAAAyP,IAIA5gB,EAAAmX,GAAAzT,SAAA,SAAAmd,GACA,GAAA9gB,GACA8B,EAAAsP,EAAAjR,EAAAuS,EACAqO,EAFAN,EAAAvX,IAIA,IAAA,IAAAuX,EAAArT,OAOA,GALApN,EAAAygB,EAAA,GACA3e,EAAAkO,EAAAhQ,GACAoR,EAAAtP,EAAAsP,OACA2P,EAAAjV,GAAAgV,GAEAA,GAAAA,EAAA3gB,MAGAA,EAAA2gB,MAEA,IAAA,WAAAC,EAKAD,EAAA,IACAA,EAAA1P,EAAAhE,OAAA0T,GAGA3gB,EAAAiR,EAAA0P,OAEA,IAAA,WAAAC,GAGA,IAAArO,EAAA,EAAAA,EAAAtB,EAAAhE,OAAAsF,GAAA,EAEA,GAAA9G,EAAAwF,EAAAsB,GAAA9R,OAAAwQ,EAAAsB,GAAA9R,KAAA3C,MAAA6iB,GAAA,CACA3gB,EAAAiR,EAAAsB,EACA,YAOAvS,GAAA2B,EAAA3B,MAAAkR,MAAAyP,EAKA,OAAA3gB,IAIAF,EAAAmX,GAAA1P,cAAA,SAAAsZ,GACA,GAAAhhB,GAAA8B,EACAzB,EAAAkT,EAAAD,EADAmN,EAAAvX,KAEA6X,EAAAjV,GAAAkV,EAEA,IAAA,IAAAP,EAAArT,OAIA,GAFApN,EAAAygB,EAAA,GAEA,UAAAM,EAGAzN,EAAA0N,MAEA,IAAA,WAAAD,EAAA,CAGAjf,EAAAkO,EAAAhQ,GACAK,EAAAyB,EAAA3B,MAAAE,MAEA,KAAAkT,IAAAlT,GAEA,GAAAkT,EAAAtV,MAAA+iB,GAAA,CACA1N,EAAAjT,EAAAkT,EAEA,YAOAzR,GAAAkO,EAAAhQ,GACAsT,EAAAxR,EAAA3B,MAAAE,OAAA2gB,EAIA,OAAA1N,IAIArT,EAAAmX,GAAA6J,cAAA,SAAAH,GACA,GAAAL,GAAAvX,KACAkI,EAAAqP,EAAAvZ,YACA/G,EAAAsgB,EAAA9c,SAAAmd,EAEA,OAAAvK,IAAApW,EAAAiR,IAIAnR,EAAAmX,GAAAzV,SAAA,SAAAmf,EAAAxU,GACA,GAAA8F,GAAApJ,EACAlH,EAAA3B,EACAiL,EAAAoB,EAAAD,EAFAkU,EAAAvX,IAIA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAKA,GAJAoJ,EAAAnS,EAAAwgB,EAAAzX,IACAlH,EAAAkO,EAAAyQ,EAAAzX,IAEA7I,EAAAF,EAAAwgB,EAAAzX,IAAArF,SAAAmd,GACA,CAGA3N,EAAAf,EAAAtQ,EAAA3B,EAAAmM,GACA+G,EAAAjB,EAAAtQ,EAAA3B,EAAAmM,GAEAD,EAAAC,EAGA,KAAAlB,IAAAkB,GACAhB,OAAA5C,UAAA6C,eAAAC,KAAAc,EAAAlB,KACAoB,EAAAF,EAAAlB,GACAmB,EAAAT,GAAAU,GACA,WAAAD,GAAA4L,GAAA3L,IAEArM,EAAAiL,GAAAM,MAAAc,GACAH,EAAAlM,EAAAiL,KACA,UAAAmB,EAEApM,EAAAiL,GAAAoB,EAAAxO,MAAA,GACA,WAAAuO,EACA,IAAAC,EAAA6L,QAAA,MAEAlY,EAAAiL,IAAAc,GAAAM,EAAA0U,OAAA,IACA,IAAA1U,EAAA6L,QAAA,MAEAlY,EAAAiL,IAAAc,GAAAM,EAAA0U,OAAA,KACAlV,MAAAQ,IAAAT,EAAAS,IAAA,SAAApB,EAEAjL,EAAAiL,GAAAc,GAAAM,GAGArM,EAAAiL,GAAAoB,EAIArM,EAAAiL,GAAAoB,EAMA2F,GAAAC,EAAAtQ,EAAA3B,GACA8S,EAAAb,EAAAtQ,EAAA3B,GAGAF,EAAAkhB,cAAA7U,MAAA,GACAqG,EAAAP,EAAAtQ,EAAA3B,EAAA,SAAAmM,GAKA,MAAAmU,IAIAxgB,EAAAmX,GAAAgK,UAAA,SAAA9U,EAAAsU,GACA,GAAAxO,GAAApJ,EACAoI,EAAAsB,EADA+N,EAAAvX,IAEA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAKA,IAJAoJ,EAAAnS,EAAAwgB,EAAAzX,IAEAoI,EAAAgB,EAAAlL,UAAA0Z,GAEAlO,EAAA,EAAAA,EAAAtB,EAAAhE,OAAAsF,GAAA,EAEAN,EAAAzQ,SAAAyP,EAAAsB,GAAApG,EAGA,OAAAmU,IAIAxgB,EAAAmX,GAAAiK,cAAA,SAAAL,EAAA1U,GACA,GAAA8F,GAAApJ,EACAsK,EAAAZ,EADA+N,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAMA,GAJAoJ,EAAAnS,EAAAwgB,EAAAzX,IAEAsK,EAAAlB,EAAA1K,cAAAsZ,GAKA,IAAAtO,EAAA,EAAAA,EAAAY,EAAAlG,OAAAsF,GAAA,EAEAN,EAAAzQ,SAAA2R,EAAAZ,GAAApG,EAKA,OAAAmU,IAIAxgB,EAAAmX,GAAApQ,UAAA,SAAA8Z,EAAAha,GACA,GAAAsL,GAAApJ,EACAlH,EAAAsP,EAAAjR,EADAsgB,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACAlH,EAAAkO,EAAAyQ,EAAAzX,IAGAoI,EAAAtP,EAAAsP,OACAjR,EAAAiS,EAAAzO,SAAAmd,GACA3gB,IAGAA,EAAA2G,MAAAyP,GAAApW,EAAAiR,GAGAA,EAAAsC,OAAAvT,EAAA2G,MAAA,GAEAsK,EAAAsC,OAAA5M,EAAA,EAAA3G,GAGA2G,EAAA,IACAA,EAAAsK,EAAAhE,OAAAtG,GAGA3G,EAAA2G,MAAAA,EAEA6L,EAAAP,EAAAtQ,EAAA3B,EAAA,QAIA,OAAAsgB,IAIAxgB,EAAAmX,GAAA9O,YAAA,SAAAwY,GACA,GAAA1O,GAAApJ,EAAAlH,EACAsP,EAAAjR,EADAsgB,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACAlH,EAAAkO,EAAAyQ,EAAAzX,IAGAoI,EAAAgB,EAAAlL,YACA/G,EAAAiS,EAAAzO,SAAAmd,GAEA3gB,IAGAA,EAAA2G,MAAAyP,GAAApW,EAAAiR,GAEAA,EAAAsC,OAAAvT,EAAA2G,MAAA,SACA3G,GAAAgX,OAGAhE,EAAAf,EAAAtQ,EAAA3B,GACAS,KAAA,OAGAyS,EAAAjB,EAAAtQ,EAAA3B,GACAE,OAAA,OAIAsS,EAAAP,EAAAtQ,EAAA3B,EAAA,UAIA,OAAAsgB,IAIAxgB,EAAAmX,GAAAkK,aAAA,SAAAV,GACA,GAAAxO,GAAApJ,EACAlH,EAAAsP,EAAAjR,EAAAuS,EADA+N,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAAA,CAKA,IAJAoJ,EAAAnS,EAAAwgB,EAAAzX,IACAlH,EAAAkO,EAAAyQ,EAAAzX,IACAoI,EAAAgB,EAAAlL,UAAA0Z,GAEAlO,EAAA,EAAAA,EAAAtB,EAAAhE,OAAAsF,GAAA,EACAvS,EAAAiR,EAAAsB,GACAN,EAAA9J,YAAAnI,GAEAuS,GAAA,CAGA5Q,GAAA3B,MAAAkR,SACAvP,EAAA3B,MAAAE,UAEA,MAAAogB,IAIAxgB,EAAAmX,GAAA5S,iBAAA,SAAAwc,GACA,GAAA5O,GAAApJ,EAAAsK,EAAAZ,EAAA+N,EAAAvX,IAEA,IAAAuD,SAAAuU,EACA,IAAAhY,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAKA,GAJAoJ,EAAAnS,EAAAwgB,EAAAzX,IAEAsK,EAAAlB,EAAA1K,cAAAsZ,GAQA,IAHA1N,EAAAA,EAAAtV,MAAA,GAGA0U,EAAA,EAAAA,EAAAY,EAAAlG,OAAAsF,GAAA,EACAN,EAAA9J,YAAAgL,EAAAZ,GAMA,OAAA+N,IAIAxgB,EAAAmX,GAAAmK,gBAAA,SAAAT,EAAAvN,GACA,GAAAnB,GAAApJ,EACA7I,EADAsgB,EAAAvX,KACA7I,GAAAkT,EAEA,KAAAvK,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACA7I,EAAAiS,EAAAzO,SAAAmd,GAGA3gB,EAAAE,SAEAA,EAAAF,EAAAE,OAAArC,MAAA,GAEAuY,GAAAhD,EAAApT,EAAAE,cAEAA,EAAA6M,KAAAqG,IAIAnB,EAAAzQ,SAAAxB,GACAE,OAAAA,GAIA,OAAAogB,IAIAxgB,EAAAmX,GAAAoK,qBAAA,SAAAV,EAAAvN,GACA,GAAAnB,GAAApJ,EACA7I,EACA2G,EAFA2Z,EAAAvX,KACA7I,IAGA,KAAA2I,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACA7I,EAAAiS,EAAAzO,SAAAmd,GAEA3gB,EAAAE,SAGAyG,EAAAyP,GAAAhD,EAAApT,EAAAE,QAGAyG,SAGAzG,EAAAF,EAAAE,OAAArC,MAAA,GAGAqC,EAAAqT,OAAA5M,EAAA,GAGAsL,EAAAzQ,SAAAxB,GACAE,OAAAA,KAQA,OAAAogB,IA8NA7Z,GAAA2L,SAAA,OAAA,WAAA,UAAA,YAKA3L,GAAA4P,OAAA,WACA,GAAAiL,GAAA7C,GAAAlG,GAAAgJ,gBAAA,IACAC,GAAA3C,GACAxT,KAAAiW,GACAtI,KAAA,IACAlb,MAAA,sBAAA,KAAAwjB,EAAAG,QAAA,GAAA,MACA,EACA,OAAA,IAAAD,EAAA,OAyEA1hB,EAAAmX,GAAAvE,kBAAA,SAAA1S,EAAAkU,GACA,GAAAjC,GAAApJ,EACAlH,EADA2e,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACAlH,EAAAkO,EAAAyQ,EAAAzX,IACA7I,EAAAiS,EAAAzO,SAAAxD,GACAA,GACAwS,EAAAP,EAAAtQ,EAAA3B,EAAAkU,EAGA,OAAAoM,IAIAxgB,EAAAmX,GAAAxV,UAAA,SAAAkf,GACA,GAAA9X,GAAA+D,EACAqF,EAAAjS,EADAsgB,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IACA5M,EAAAiS,EAAAzO,SAAAmd,GACA/M,EAAA3B,EAAArF,EAAA5M,GAGA,OAAAsgB,IAIAxgB,EAAAmX,GAAAtE,WAAA,SAAA3H,GACA,GAAAiH,GAAApJ,EAAA+D,EAIAqE,EAAAjR,EAAA0hB,EAAAnP,EAAA5L,EAAAgb,EACAhgB,EAAAgY,EAAAzF,EAAA0N,EALAtB,EAAAvX,KAEAmC,EAAAF,KAWA,KALArE,EAAAuE,EAAAvE,MACAA,IACAA,EAAA,GAGAkC,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAGA,GAFAoJ,EAAAnS,EAAAwgB,EAAAzX,IACA+D,EAAAZ,EAAAsU,EAAAzX,IACA,CAaA,IAXAlH,EAAAkO,EAAAyQ,EAAAzX,IAGAqC,EAAA2W,SAAA,GACA5P,EAAA6P,cAIA7Q,EAAAtP,EAAAsP,OAGAsB,EAAA5L,EAAA4L,EAAAtB,EAAAhE,OAAAsF,GAAA,EAgBA,GAfAvS,EAAAiR,EAAAsB,GAGAvS,EAAA2G,MAAA4L,EAGArH,EAAA6O,YACA/Z,EAAA+hB,QAAA,GAGAnO,EAAA3B,EAAArF,EAAA5M,EAAAuS,EAAA,GAEAvS,EAAAyT,OAAA9R,EAAA8K,WAAAC,MAAA7O,MAAA,GAGAmC,EAAA+T,UAAAjU,EAAAmX,GAAA+K,WAAAhiB,EAAA8T,QAAA,CACA8N,GAAA,CACA,OAMA,GAAAA,EAEA,KAIAD,GAAApP,EAGAvS,EAAAwT,EAAA7R,GAEAgY,EAAAhY,EAAA6P,MACA0C,EAAAyF,EAAAlI,KAGA9P,EAAA4C,KAAAvE,OAEAiU,EAAAhC,EAAAtQ,EAAAuS,GAIAwN,EAAA/f,EAAA0P,gBACA,OAAAqQ,GAAA1hB,IAAA0hB,IAAAA,EAAAjP,UAAAiP,EAAAK,QAAApgB,EAAA4C,KAAAgN,WAEA5P,EAAA0P,gBAAA,KACAqQ,EAAAK,QAAA,EACAL,EAAAjP,UAAA,EACAD,EAAAP,EAAAtQ,EAAA+f,EAAA,YACApL,EAAArE,EAAAtQ,IAIA3B,IAGAA,EAAAkU,KACAA,EAAAqF,EAAArF,IAIAlU,EAAA6S,QAAA7S,EAAA0T,aAEA/R,EAAA0P,gBAAArR,GAGAA,EAAAwE,WAAAxE,EAAAuB,UAAAvB,EAAAoS,WAAAzQ,EAAA4C,KAAAgN,WAEAvR,EAAAyS,UAAAzS,EAAA+hB,SAGA/hB,EAAA+hB,QAAA,EACA/hB,EAAAyS,UAAA,EACAD,EAAAP,EAAAtQ,EAAA3B,EAAA,eAOAA,EAAA+hB,SAGA/hB,EAAA+hB,QAAA,EACApI,EAAAlI,KAAA,KAEAe,EAAAP,EAAAtQ,EAAA3B,EAAAkU,KAKAlU,EAAAyC,WAAAzC,EAAA4W,eAAA,cAAA1C,GAAA,eAAAA,IAGAvS,EAAA4C,KAAAvE,MAAAA,EACA2B,EAAAuU,0BAAAvU,EAAAoQ,kBACApQ,EAAAoQ,mBAAA,KASA,OAAA/R,GAAA2B,EAAA4C,KAAAgN,UAEA+E,EAAArE,EAAAtQ,GAIAggB,IAAA1Q,EAAAhE,SAGAtL,EAAAyP,aAAAnE,OAAA,EAEAtL,EAAA8K,WAAAD,EAAAU,IACAvL,EAAAmL,gBAAAG,OAAA,GAMA,MAAAqT,IA6GAxgB,EAAAmX,GAAAgL,SAAA,SAAAjX,GACA,GAAAnC,GAAA+D,EACA1B,EADAoV,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACAE,EAAAlL,OAAA,EACA8W,EAAAwJ,EAAAzX,GAAAqC,EAAAF,GAIA,OAAAsV,IAMA7Z,GAAA0F,OACA,QACA,SACA,UACA,cAEA1F,GAAAkR,YAsJA7X,EAAAmX,GAAAiL,aAAA,WA+CA,QAAAC,GAAAlQ,EAAAtQ,EAAA3B,GAEA,MAAA,YAEAqX,EAAArX,GACAiY,EAAAjY,GAGA2B,EAAAgQ,WAAAhQ,EAAAiQ,WAAA5R,GAEAiS,EAAAU,aAIA3S,EAAAoiB,YAAA,EACAzgB,EAAAgQ,WAAA,EACAhQ,EAAAiQ,SAAA,KAGA5G,EAAA,IAEAA,EAAA,GAAAK,KAAA4G,EAAA,GAAAjS,GAGAwS,EAAAP,EAAAtQ,EAAA3B,EAAA,eAOA,QAAAoZ,GAAAnH,EAAAtQ,EAAA3B,GAEA,MAAA,UAAA6Y,EAAAF,GACA,GAAA0J,GAAApX,EAAA6M,EACAwK,GAAA,CAGA,OAAA3J,EAAAO,KAAA,KACAoJ,GAAA,EAEA3J,EAAAO,KAAAP,EAAAO,KAAAzQ,QAAA,IAAA,IACAzI,EAAA2Y,EAAAO,MAAAlZ,EAAA,IAAA2Y,EAAAO,OAIAP,EAAAO,KAAAhB,QAAA,YACAmK,EAAA1J,EAAAO,KAAAiF,MAAA,KACAlT,EAAAoX,EAAA,GACAvK,EAAAuK,EAAA,GACAriB,EAAAiL,KACAjL,EAAAiL,GAAA6M,GAAAa,EAAAE,MAKA7Y,EAAAuiB,OAAA5J,EAAAG,MAEA9Y,EAAAuiB,KAAA5J,EAAAG,IAGA9Y,EAAAoiB,YAAAzgB,EAAAgQ,YACA3R,EAAAoiB,YAAA,EACAzgB,EAAAgQ,WAAA,EACAhQ,EAAAiQ,SAAA5R,GAIA2B,EAAAgQ,WAAAhQ,EAAAiQ,WAAA5R,GAEAiS,EAAAU,cAMA3H,EAAA,IAEAA,EAAA,GAAAK,KAAA4G,EAAA,GAAA4G,EAAAF,EAAA3Y,GAGAwS,EAAAP,EAAAtQ,EAAA3B,EAAA,UAAA2Y,GAGA2J,IAEA3J,EAAAO,KAAA,IAAAP,EAAAO,OApIA,GAAAjH,GAAApJ,EAAA+D,EAEAjL,EAAA3B,EAAAmM,EAFAmU,EAAAvX,KACAiC,EAAA6T,GAAAxT,KAAAmX,UAAA,EA0IA,KA7HA,WAAA7W,GAAAX,EAAA,KAGAA,EAAAuI,OAAA,EAAA,EAAAvI,EAAA,GAAAyX,UAAA,MACAzX,EAAAuI,OAAA,EAAA,EAAAvI,EAAA,GAAA0X,QAAA,MACA1X,EAAAuI,OAAA,EAAA,EAAAvI,EAAA,GAAAmX,UAAA,MACAnX,EAAAuI,OAAA,EAAA,EAAAvI,EAAA,GAAAoO,MAAA,QAIA9M,SAAAtB,EAAA,IAEAA,EAAAuI,OAAA,EAAA,EAAA,MACAvI,EAAAuI,OAAA,EAAA,EAAA,MACAvI,EAAAuI,OAAA,EAAA,EAAA,OACAhG,GAAAvC,EAAA,MAEAA,EAAAuI,OAAA,EAAA,EAAA,MACAvI,EAAAuI,OAAA,EAAA,EAAA,OAEAjH,SAAAtB,EAAA,IAEAA,EAAA,GAAA,KACAA,EAAAuI,OAAA,EAAA,EAAA,OACAhG,GAAAvC,EAAA,KAEAA,EAAAuI,OAAA,EAAA,EAAA,OAmGA1K,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEAjL,EAAAkO,EAAAyQ,EAAAzX,IAGA7I,EAAAiS,EAAAzO,SAAAwH,EAAA,IAGAhL,GAAAA,EAAA+T,UAAAjU,EAAAmX,GAAA0L,OAGAxW,EAAAZ,MAAAP,EAAA,IAEAmB,EAAAyL,EAAA0I,EAAAzX,GAAA7I,EAAAmM,GAGAsL,EAAAtL,GAAA,GACAsL,EAAAzX,GAGAA,EAAAyY,MAAAhS,GAAAkR,SAGA7X,EAAAE,GAAA4iB,QAAAzW,GACAsW,SAAAzX,EAAA,GACA0X,OAAA5iB,EAAA4iB,OAAA1X,EAAA,IAAAA,EAAA,GAAA,KAEAmX,SAAAA,EAAAlQ,EAAAtQ,EAAA3B,GAEAoZ,KAAAA,EAAAnH,EAAAtQ,EAAA3B,KAEAwS,EAAAP,EAAAtQ,EAAA3B,EAAA,iBAKA,OAAAsgB,IAIAxgB,EAAAmX,GAAA4L,kBAAA,SAAAhC,GACA,GAAA5O,GAAApJ,EAEAsK,EAAAZ,EAFA+N,EAAAvX,KACAiC,EAAA6T,GAAAxT,KAAAmX,UAAA,EAEA,KAAA3Z,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAGA,GAFAoJ,EAAAnS,EAAAwgB,EAAAzX,IACAsK,EAAAlB,EAAA1K,cAAAsZ,GAIA,IAAAtO,EAAA,EAAAA,EAAAY,EAAAlG,OAAAsF,GAAA,EAGAvH,EAAA,GAAAmI,EAAAZ,GACAN,EAAAiQ,aAAAY,MAAA7Q,EAAAjH,EAMA,OAAAsV,IAIAxgB,EAAAmX,GAAA8L,WAAA,SAAApC,EAAA8B,GACA,GAAAxQ,GAAApJ,EACAlH,EAAA3B,EADAsgB,EAAAvX,IAIA,KAFA0Z,EAAAA,GAAA,EAEA5Z,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACAlH,EAAAkO,EAAAyQ,EAAAzX,IACA7I,EAAAiS,EAAAzO,SAAAmd,GAEA3gB,IAEAF,EAAAE,GAAAgjB,MAAAP,GACAjQ,EAAAP,EAAAtQ,EAAA3B,EAAA,SAGA,OAAAsgB,IAIAxgB,EAAAmX,GAAAgM,gBAAA,SAAApC,EAAA4B,GACA,GAAAxQ,GAAApJ,EACAsK,EAAAnT,EAAAuS,EADA+N,EAAAvX,IAIA,KAFA0Z,EAAAA,GAAA,EAEA5Z,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAKA,GAJAoJ,EAAAnS,EAAAwgB,EAAAzX,IAEAsK,EAAAlB,EAAA1K,cAAAsZ,GAIA,IAAAtO,EAAA,EAAAA,EAAAY,EAAAlG,OAAAsF,GAAA,EAEAvS,EAAAmT,EAAAZ,GACAN,EAAA8Q,WAAA/iB,EAAAyiB,EAKA,OAAAnC,IAIAxgB,EAAAmX,GAAAiM,UAAA,SAAAvC,EAAAwC,GACA,GAAAlR,GAAApJ,EACAlH,EAAA3B,EADAsgB,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAoJ,EAAAnS,EAAAwgB,EAAAzX,IACAlH,EAAAkO,EAAAyQ,EAAAzX,IACA7I,EAAAiS,EAAAzO,SAAAmd,GAEA3gB,IAEAF,EAAAE,GAAAojB,KAAAD,GACA3Q,EAAAP,EAAAtQ,EAAA3B,EAAA,QAGA,OAAAsgB,IAIAxgB,EAAAmX,GAAAoM,eAAA,SAAAxC,EAAAsC,GACA,GAAAlR,GAAApJ,EACAsK,EAAAnT,EAAAuS,EADA+N,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAKA,GAJAoJ,EAAAnS,EAAAwgB,EAAAzX,IAEAsK,EAAAlB,EAAA1K,cAAAsZ,GAIA,IAAAtO,EAAA,EAAAA,EAAAY,EAAAlG,OAAAsF,GAAA,EAEAvS,EAAAmT,EAAAZ,GACAN,EAAAiR,UAAAljB,EAAAmjB,EAKA,OAAA7C,IAYAnH,GACA,QACA,kBACA,cACA,iBACA,mBACA,oBACA,kBACA,YACA,eACA,cACA,gBAMAjC,GAAAoC,aACAgK,UAAA,aACAC,QAAA,WACAC,UAAA,aAGAtM,GAAAsC,aACAiK,WAAA,YACAC,SAAA,UACAC,UAAA,aAsEA1J,GACA,QACA,WACA,YACA,UACA,YACA,YACA,WACA,aACA,YACA,WACA,cACA,cACA,YACA,gBA4DAna,EAAA0R,MAAAuN,IAAA,SAAAvN,GACA,GAAAoS,GAAAC,EAAAC,CAMA,IAJAtS,EAAAsN,GAAAzT,KAAAvL,EAAA0R,MAAAA,GACAqS,EAAArS,EAAAqS,cAQA,GAHAC,EAAAD,EAAAE,eAGAzX,SAAAkF,EAAAwS,OAAA1X,SAAAkF,EAAAoI,QACA,IACAgK,EAAA9jB,EAAA0R,EAAAyS,eAAAL,SACAA,IACApS,EAAAoI,QAAApI,EAAAwS,MAAAJ,EAAAM,KACA1S,EAAAqI,QAAArI,EAAA2S,MAAAP,EAAAQ,KAEA,MAAA5Z,QAGA,IAAAsZ,EACA,IAEAF,EAAA9jB,EAAA0R,EAAAyS,eAAAL,SACAA,IACApS,EAAAoI,QAAAkK,EAAA,GAAAE,MAAAJ,EAAAM,KACA1S,EAAAqI,QAAAiK,EAAA,GAAAK,MAAAP,EAAAQ,KAEA,MAAA5Z,IAMA,MAAAgH,IAMA0F,GAAAC,UACAiE,IAAA,UACAiJ,OAAA,aACAC,QAAA,cACAC,WAAA,OACAC,MAAA,YACAzG,KAAA,WACAnD,KAAA,WACA6J,QAAA,cACA5mB,MAAA,YACA6mB,UAAA,gBACAC,UAAA,WACAzjB,KAAA,WACA0jB,OAAA,aACA/X,KAAA,aACAM,QAAA,gBACAgD,OAAA,eACAE,MAAA,cACAI,UAAA,mBAIA3Q,EAAAmX,GAAA0L,KAAA,QAAAA,IAAA3X,GACA,GAAAnC,GAAA+D,EAAA0T,EAAAvX,KACAmC,EAAA,GAAAH,GAAAC,EAGA,IAAAkM,GAAAC,SAAAjM,EAAAuG,OAAA,aAAAvG,EAAAuG,KAEA6O,EAAApJ,GAAAC,SAAAjM,EAAAuG,OAAAzG,OAIA,KAAAnC,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAA2X,IACAzX,EAAA4I,SAEA5I,EAAA+L,IAEA/L,EAAA+L,GAAA5L,KAAAiV,EAAAzX,GAAA+D,EAAA1B,GASA,OAAAoV,IAIAxgB,EAAAmX,GAAA6K,YAAA,QAAAA,IAAA9W,GACA,GAAAnC,GAAA+D,EAAA0T,EAAAvX,KACAmC,EAAA,GAAAH,GAAAC,EAEA,KAAAnC,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA,OAAA1B,EAAA5F,OAAA,OAAA4F,EAAA3F,QAIAqH,EAAAC,OACAD,EAAAiY,aAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACAjY,EAAAkY,UAAA,EAAA,EAAAxE,EAAAzX,GAAAvD,MAAAgb,EAAAzX,GAAAtD,QACAqH,EAAAO,YAMA2J,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAA8W,IACAhS,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,EAAAA,EAAA5F,MAAA4F,EAAA3F,QACAqH,EAAAkY,UAAA5Z,EAAA/O,EAAA+O,EAAA5F,MAAA,EAAA4F,EAAA9O,EAAA8O,EAAA3F,OAAA,EAAA2F,EAAA5F,MAAA4F,EAAA3F,QAEA8J,EAAAzC,EAAA1B,IAMA,OAAAoV,IAMAxgB,EAAAmX,GAAA8N,WAAA,QAAAA,IAAA/Z,GACA,GAAAnC,GAAA+D,EACA1B,EAAAvJ,EAAAnD,EADA8hB,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAEA,GADA+D,EAAAZ,EAAAsU,EAAAzX,IASA,IANAlH,EAAAkO,EAAAyQ,EAAAzX,IAEAqC,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAA+Z,IAGAvmB,EAAA,EAAAA,EAAA0M,EAAAmU,MAAA7gB,GAAA,EACAmO,EAAAC,EAAAjL,EAKA,OAAA2e,IAIAxgB,EAAAmX,GAAAzW,cAAA,QAAAA,IAAAwK,GACA,GAAAnC,GAAA+D,EACA1B,EAAAvJ,EAAAnD,EADA8hB,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAEA,GADA+D,EAAAZ,EAAAsU,EAAAzX,IASA,IANAlH,EAAAkO,EAAAyQ,EAAAzX,IAEAqC,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAxK,IAGAhC,EAAA,EAAAA,EAAA0M,EAAAmU,MAAA7gB,GAAA,EACAwO,EAAAJ,EAAAjL,EAKA,OAAA2e,IA8DAxgB,EAAAmX,GAAA+N,aAAA,QAAAA,IAAAha,GACA,GAAAnC,GAAA+D,EACA1B,EAAAvJ,EADA2e,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEAjL,EAAAkO,EAAAyQ,EAAAzX,IAEAqC,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAga,IAGA9Z,EAAAgE,UAEAvC,EAAAC,EAAAjL,GAEAyO,EAAAxD,EAAA1B,EAAAvJ,EAAA8K,YAIA,OAAA6T,IAIAxgB,EAAAmX,GAAAgO,YAAA,QAAAA,IAAAja,GACA,GAAAnC,GAAA+D,EACA1B,EAAAvJ,EADA2e,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEAjL,EAAAkO,EAAAyQ,EAAAzX,IAEAqC,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAia,IAGA/Z,EAAAgE,UAEAvC,EAAAC,EAAAjL,GAEA6O,EAAA5D,EAAA1B,EAAAvJ,EAAA8K,YAIA,OAAA6T,IAIAxgB,EAAAmX,GAAAiO,gBAAA,QAAAA,IAAAla,GACA,GAAAnC,GAAA+D,EACA1B,EAAAvJ,EADA2e,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEAjL,EAAAkO,EAAAyQ,EAAAzX,IAEAqC,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAka,IAGAha,EAAAgE,UAEAvC,EAAAC,EAAAjL,GAEAiP,EAAAhE,EAAA1B,EAAAvJ,EAAA8K,YAIA,OAAA6T,IAMAxgB,EAAAmX,GAAA5R,SAAA,QAAAA,IAAA2F,GACA,GAAAnC,GAAA+D,EACA1B,EACApG,EAAAC,EACAC,EAAAC,EACAmQ,EAAA+P,EAJA7E,EAAAvX,IAMA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAA3F,IACA6F,EAAA4I,UAEAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,EAAAA,EAAA5F,MAAA4F,EAAA3F,QACAiI,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAEA0B,EAAAwY,YACAla,EAAA5F,OAAA4F,EAAA3F,SACAT,EAAAoG,EAAA/O,EAAA+O,EAAA5F,MAAA,EACAP,EAAAmG,EAAA9O,EAAA8O,EAAA3F,OAAA,EACA6P,EAAAY,GAAA9K,EAAA1F,cAEA4P,GAGApQ,EAAAkG,EAAA/O,EAAA+O,EAAA5F,MAAA,EACAL,EAAAiG,EAAA9O,EAAA8O,EAAA3F,OAAA,EAGA2F,EAAA5F,MAAA,IACA6f,EAAArgB,EACAA,EAAAE,EACAA,EAAAmgB,GAGAja,EAAA3F,OAAA,IACA4f,EAAApgB,EACAA,EAAAE,EACAA,EAAAkgB,GAIAngB,EAAAF,EAAA,EAAAsQ,EAAA,IACAA,GAAApQ,EAAAF,GAAA,GAEAG,EAAAF,EAAA,EAAAqQ,EAAA,IACAA,GAAAnQ,EAAAF,GAAA,GAIA6H,EAAAiP,OAAA/W,EAAAsQ,EAAArQ,GACA6H,EAAAkP,OAAA9W,EAAAoQ,EAAArQ,GACA6H,EAAAwO,IAAApW,EAAAoQ,EAAArQ,EAAAqQ,EAAAA,EAAA,EAAArY,GAAA,EAAA,EAAAA,IAAA,GACA6P,EAAAkP,OAAA9W,EAAAC,EAAAmQ,GACAxI,EAAAwO,IAAApW,EAAAoQ,EAAAnQ,EAAAmQ,EAAAA,EAAA,EAAArY,GAAA,GAAA,GACA6P,EAAAkP,OAAAhX,EAAAsQ,EAAAnQ,GACA2H,EAAAwO,IAAAtW,EAAAsQ,EAAAnQ,EAAAmQ,EAAAA,EAAArY,GAAA,EAAAA,IAAA,GACA6P,EAAAkP,OAAAhX,EAAAC,EAAAqQ,GACAxI,EAAAwO,IAAAtW,EAAAsQ,EAAArQ,EAAAqQ,EAAAA,EAAArY,GAAA,EAAAA,GAAA,GAAA,GAEAmO,EAAAsE,QAAA,GAKA5C,EAAAyY,KAAAvgB,EAAAC,EAAAmG,EAAA5F,MAAA4F,EAAA3F,SAKA4U,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAqE,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,IAIA,OAAAoV,IAqFAxgB,EAAAmX,GAAA7V,QAAA,QAAAA,IAAA4J,GACA,GAAAnC,GAAA+D,EACA1B,EADAoV,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAA5J,IACA8J,EAAA4I,UAEAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,EAAA,EAAAA,EAAAhO,QACAsQ,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAEA0B,EAAAwY,YACAzK,EAAA2F,EAAAzX,GAAA+D,EAAA1B,EAAAA,GAEAiP,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAqE,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,IAMA,OAAAoV,IAIAxgB,EAAAmX,GAAAqO,YAAA,QAAAA,IAAAta,GACA,GAAAnC,GAAA+D,EACA1B,EACAqa,EACAC,EAHAlF,EAAAvX,IAKA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAsa,IACApa,EAAA4I,UAEAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,EAAAA,EAAA5F,MAAA4F,EAAA3F,QACAiI,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAGAqa,EAAAra,EAAA5F,OAAA,EAAA,GACAkgB,EAAAta,EAAA3F,OAGAqH,EAAAwY,YACAxY,EAAAiP,OAAA3Q,EAAA/O,EAAA+O,EAAA9O,EAAAopB,EAAA,GAEA5Y,EAAAqQ,cAAA/R,EAAA/O,EAAAopB,EAAA,EAAAra,EAAA9O,EAAAopB,EAAA,EAAAta,EAAA/O,EAAAopB,EAAA,EAAAra,EAAA9O,EAAAopB,EAAA,EAAAta,EAAA/O,EAAA+O,EAAA9O,EAAAopB,EAAA,GAEA5Y,EAAAqQ,cAAA/R,EAAA/O,EAAAopB,EAAA,EAAAra,EAAA9O,EAAAopB,EAAA,EAAAta,EAAA/O,EAAAopB,EAAA,EAAAra,EAAA9O,EAAAopB,EAAA,EAAAta,EAAA/O,EAAA+O,EAAA9O,EAAAopB,EAAA,GAEArL,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAA,EAAAsE,QAAA,EACAD,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,IAKA,OAAAoV,IAIAxgB,EAAAmX,GAAAwO,YAAA,QAAAA,IAAAza,GACA,GAAAnC,GAAA+D,EACA1B,EACAwa,EAAAC,EAAAC,EACAC,EACA1pB,EAAAC,EAAAoC,EAJA8hB,EAAAvX,IAMA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAEA,GADA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAya,IACAva,EAAA4I,SAAA,CAgBA,IAdAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,EAAA,EAAAA,EAAAhO,QACAsQ,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAGAya,EAAA,EAAA5oB,GAAAmO,EAAA4U,MAEA8F,EAAAD,EAAA,EAEAD,EAAAE,EAAA7oB,GAAA,EAEA8oB,EAAA3a,EAAAhO,OAAAod,GAAAsL,GAGAhZ,EAAAwY,YACA5mB,EAAA,EAAAA,EAAA0M,EAAA4U,MAAAthB,GAAA,EAGArC,EAAA+O,EAAA/O,EAAA+O,EAAAhO,OAAAod,GAAAoL,GACAtpB,EAAA8O,EAAA9O,EAAA8O,EAAAhO,OAAAqd,GAAAmL,GAGA9Y,EAAAkP,OAAA3f,EAAAC,GAGA8O,EAAAkU,YAEAjjB,EAAA+O,EAAA/O,GAAA0pB,GAAAA,EAAA3a,EAAAkU,WAAA9E,GAAAoL,EAAAE,GACAxpB,EAAA8O,EAAA9O,GAAAypB,GAAAA,EAAA3a,EAAAkU,WAAA7E,GAAAmL,EAAAE,GACAhZ,EAAAkP,OAAA3f,EAAAC,IAIAspB,GAAAC,CAIAxL,GAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAA,EAAAsE,QAAA,EACAD,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,GAKA,MAAAoV,IAIAxgB,EAAAmX,GAAAlX,UAAA,QAAAA,IAAAiL,GACA,GAAAnC,GAAA+D,EACA1B,EACAjJ,EAAA8S,EAAAC,EAFAsL,EAAAvX,IAIA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAjL,IACAmL,EAAA4I,UAEAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,EAAA,EAAAA,EAAAhO,QACAsQ,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAKAA,EAAA9K,OAAA8K,EAAA6E,OACA7E,EAAA7K,KAAA6K,EAAA6E,OAEA7E,EAAA9K,OAAArD,GAAA,EACAmO,EAAA7K,KAAAtD,GAAA,EAGAmO,EAAA9K,MAAAoa,EAAAtP,EAAA9K,OACA8K,EAAA7K,IAAAma,EAAAtP,EAAA7K,KAEA6K,EAAA7K,IAAA6K,EAAA9K,QACA8K,EAAA7K,KAAA,EAAAtD,IAIAkF,GAAAiJ,EAAA9K,MAAA8K,EAAA7K,KAAA,EAGA0U,EAAA7J,EAAAhO,OAAAgO,EAAA8U,OAAA1F,GAAArY,GACA+S,EAAA9J,EAAAhO,OAAAgO,EAAA8U,OAAAzF,GAAAtY,GAGAiJ,EAAA/O,GAAA4Y,EACA7J,EAAA9O,GAAA4Y,EAGApI,EAAAwY,YACAxY,EAAAwO,IAAAlQ,EAAA/O,EAAA+O,EAAA9O,EAAA8O,EAAAhO,OAAAgO,EAAA9K,MAAA8K,EAAA7K,IAAA6K,EAAAgQ,KACAtO,EAAAkP,OAAA5Q,EAAA/O,EAAA+O,EAAA9O,GAEA+d,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAA,EAAAsE,QAAA,EACAD,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,IAMA,OAAAoV,IA+GAxgB,EAAAmX,GAAApS,SAAA,QAAAA,IAAAmG,GACA,GAAAnC,GAAA+D,EACA1B,EADAoV,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAnG,IACAqG,EAAA4I,UAEAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,GACAsC,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAGA0B,EAAAwY,YACAlJ,GAAAoE,EAAAzX,GAAA+D,EAAA1B,EAAAA,GAEAiP,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAqE,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,IAMA,OAAAoV,IAuDAxgB,EAAAmX,GAAA6O,cAAA,QAAAA,IAAA9a,GACA,GAAAnC,GAAA+D,EACA1B,EADAoV,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAA8a,IACA5a,EAAA4I,UAEAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,GACAsC,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAGA0B,EAAAwY,YACA/I,GAAAiE,EAAAzX,GAAA+D,EAAA1B,EAAAA,GAEAiP,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAqE,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,IAKA,OAAAoV,IA6DAxgB,EAAAmX,GAAA8O,WAAA,QAAAA,IAAA/a,GACA,GAAAnC,GAAA+D,EACA1B,EADAoV,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAA+a,IACA7a,EAAA4I,UAEAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,GACAsC,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAGA0B,EAAAwY,YACAzI,GAAA2D,EAAAzX,GAAA+D,EAAA1B,EAAAA,GAEAiP,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAqE,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,IAKA,OAAAoV,IAgFAxgB,EAAAmX,GAAApV,WAAA,QAAAA,IAAAmJ,GACA,GAAAnC,GAAA+D,EACA1B,EADAoV,EAAAvX,IAGA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAnJ,IACAqJ,EAAA4I,UAEAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,GACAsC,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAGA0B,EAAAwY,YACAhI,GAAAkD,EAAAzX,GAAA+D,EAAA1B,EAAAA,GAEAiP,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAqE,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,IAKA,OAAAoV,IAIAxgB,EAAAmX,GAAA+O,SAAA,QAAAA,IAAAhb,GACA,GAAAnC,GAAA+D,EACA1B,EACAqH,EAAA0T,EAFA3F,EAAAvX,IAIA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAEA,GADA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAgb,IACA9a,EAAA4I,SAAA,CAOA,IALAhE,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,GACAsC,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAEA0B,EAAAwY,YACA7S,EAAA,IACA,CAEA,GADA0T,EAAA/a,EAAA,IAAAqH,GACAjG,SAAA2Z,EAeA,KAdAA,GAAA,GAAAlb,GAAAkb,GACA,SAAAA,EAAAxU,KACAyK,GAAAoE,EAAAzX,GAAA+D,EAAA1B,EAAA+a,GACA,cAAAA,EAAAxU,KACA4K,GAAAiE,EAAAzX,GAAA+D,EAAA1B,EAAA+a,GACA,WAAAA,EAAAxU,KACAkL,GAAA2D,EAAAzX,GAAA+D,EAAA1B,EAAA+a,GACA,WAAAA,EAAAxU,KACA2L,GAAAkD,EAAAzX,GAAA+D,EAAA1B,EAAA+a,GACA,QAAAA,EAAAxU,MACAkJ,EAAA2F,EAAAzX,GAAA+D,EAAA1B,EAAA+a,GAEA1T,GAAA,EAOA4H,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEAqE,EAAA+Q,EAAAzX,GAAA+D,EAAA1B,GAMA,MAAAoV,IA2HAxgB,EAAAmX,GAAAxR,SAAA,QAAAA,IAAAuF,GACA,GAAAnC,GAAA+D,EACA1B,EAAAlL,EACAyd,EAAAM,EAAAxL,EACA7M,EACAwgB,EAAAC,EAAAC,EAAAC,EACAlqB,EAAAC,EALAkkB,EAAAvX,KAGAud,EAAA,GAIA,KAAAzd,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAEA,GADA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAvF,IACAyF,EAAA4I,SAAA,CAoDA,GAjDAlH,EAAA2Z,aAAArb,EAAAiU,SACAvS,EAAA4Z,UAAAtb,EAAAgU,MAGA7B,GAAAiD,EAAAzX,GAAA+D,EAAA1B,GAIAuS,EAFA,OAAAvS,EAAAtF,SAEAkY,GAAAlR,EAAA1B,GAGAA,EAAAhK,KACAyd,WACAR,MAAA,MAIAX,GAAA8C,EAAAzX,GAAA+D,EAAA1B,EAAAuS,GAGAzd,IAEAA,EAAAsF,MAAA4F,EAAA5F,MACAtF,EAAAuF,OAAA2F,EAAA3F,QAGAuK,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,EAAAA,EAAA5F,MAAA4F,EAAA3F,QACAiI,EAAA8S,EAAAzX,GAAA+D,EAAA1B,GAGA/O,EAAA+O,EAAA/O,EACA,SAAA+O,EAAAgU,MACAhU,EAAA0U,aAEA1U,EAAA/O,GAAA+O,EAAA5F,MAAA,EAGAnJ,GAAA+O,EAAA5F,MAAA,EAEA,UAAA4F,EAAAgU,QACAhU,EAAA0U,aAEA1U,EAAA/O,GAAA+O,EAAA5F,MAAA,EAGAnJ,GAAA+O,EAAA5F,MAAA,GAIA4F,EAAAhO,OAUA,IARAwI,EAAAqG,GAAAb,EAAAxF,UAGA,OAAAwF,EAAAsU,gBACAtU,EAAAsU,cAAA9Z,EAAA4gB,GAIA/T,EAAA,EAAAA,EAAAkL,EAAAxQ,OAAAsF,GAAA,EAAA,CAYA,IAXA3F,EAAAC,OACAD,EAAA6D,UAAAvF,EAAA/O,EAAA+O,EAAA9O,GACA2hB,EAAAN,EAAAlL,GACArH,EAAAub,cACAN,EAAApI,EAAAI,MAAA,IACAgI,EAAAO,UACA3I,EAAAoI,EAAAnN,KAAA,KAEAkN,EAAAnI,EAAA9Q,OACAL,EAAAuD,SAAApT,GAAAmO,EAAAsU,eAAA0G,EAAA,IAAA,GAEAG,EAAA,EAAAA,EAAAH,EAAAG,GAAA,EACAD,EAAArI,EAAAsI,GAEA,IAAAA,GAEAzZ,EAAAuD,OAAApT,GAAAmO,EAAAsU,eAEA5S,EAAAC,OACAD,EAAA6D,UAAA,GAAAvF,EAAAhO,QACAgO,EAAAub,aACA7Z,EAAAyD,aAEAzD,EAAA+Z,SAAAP,EAAA,EAAA,GAEA,gBAAAlb,EAAA/K,YACAyM,EAAAtL,YAAA,eAEA,IAAA4J,EAAA3K,aAEAqM,EAAAga,WAAAR,EAAA,EAAA,GAEAxZ,EAAAO,SAEAjC,GAAAhO,QAAAwI,EACAwF,EAAAsU,eAAA9Z,GAAA,EAAA4gB,EAAAvpB,IACA6P,EAAAO,cAMA,KAAAoF,EAAA,EAAAA,EAAAkL,EAAAxQ,OAAAsF,GAAA,EACAwL,EAAAN,EAAAlL,GAEAnW,EAAA8O,EAAA9O,EAAAmW,EAAArH,EAAA3F,OAAAkY,EAAAxQ,QAAAwQ,EAAAxQ,OAAA,GAAA/B,EAAA3F,OAAAkY,EAAAxQ,OAAA,EAEAL,EAAAtL,YAAA4J,EAAA5J,YAGAsL,EAAA+Z,SAAA5I,EAAA5hB,EAAAC,GAEA,gBAAA8O,EAAA/K,YACAyM,EAAAtL,YAAA,eAEA,IAAA4J,EAAA3K,aAEAqM,EAAAga,WAAA7I,EAAA5hB,EAAAC,EAQAA,GAAA,EACA,QAAA8O,EAAAiU,SACA/iB,GAAA8O,EAAA3F,OAAA,EACA,WAAA2F,EAAAiU,WACA/iB,GAAA8O,EAAA3F,OAAA,GAIA2F,EAAA2H,SACAjG,EAAAwY,YACAxY,EAAAyY,KACAna,EAAA/O,EAAA+O,EAAA5F,MAAA,EACA4F,EAAA9O,EAAA8O,EAAA3F,OAAA,EAAAnJ,EACA8O,EAAA5F,MACA4F,EAAA3F,QAEA4U,EAAAmG,EAAAzX,GAAA+D,EAAA1B,GAEA0B,EAAA6C,aAEAJ,EAAAzC,EAAA1B,GAOA,MADA4F,IAAA8M,UAAA1S,EACAoV,GAIAxgB,EAAAmX,GAAAG,YAAA,SAAApM,GACA,GAAA4B,GACA1B,EAAAuS,EADA6C,EAAAvX,IA0BA,OAtBAmC,GAAAoV,EAAA9c,SAAAwH,KAEAE,GAAAA,IAAAA,EAAA8L,UACA9L,EAAA,GAAAH,GAAAC,IAGA4B,EAAAZ,EAAAsU,EAAA,IACA1T,IAGAyQ,GAAAiD,EAAA,GAAA1T,EAAA1B,GAGAuS,EADA,OAAAvS,EAAAtF,SACAkY,GAAAlR,EAAA1B,GAEAA,EAAAhK,KAAAid,MAAA,MAEAX,GAAA8C,EAAA,GAAA1T,EAAA1B,EAAAuS,IAKAvS,GAMApL,EAAAmX,GAAA+K,UAAA,QAAAA,IAAAhX,GAOA,QAAA2X,GAAA9iB,EAAA+M,EAAAjL,EAAAuJ,EAAAlL,GAGA,OAAAkL,EAAA5F,OAAA,OAAA4F,EAAA+U,SACA/U,EAAA5F,MAAA4F,EAAA+U,OAAA4G,EAAAvhB,OAGA,OAAA4F,EAAA3F,QAAA,OAAA2F,EAAA2U,UACA3U,EAAA3F,OAAA2F,EAAA2U,QAAAgH,EAAAthB,QAIAvF,IACAA,EAAAsF,MAAA4F,EAAA5F,MACAtF,EAAAuF,OAAA2F,EAAA3F,QAIA,OAAA2F,EAAA+U,QAAA,OAAA/U,EAAA2U,SAAA,OAAA3U,EAAAgV,IAAA,OAAAhV,EAAAiV,IAGA,OAAAjV,EAAA5F,QACA4F,EAAA5F,MAAA4F,EAAA+U,QAGA,OAAA/U,EAAA3F,SACA2F,EAAA3F,OAAA2F,EAAA2U,SAIA3U,EAAAoU,iBACApU,EAAAgV,IAAAhV,EAAA+U,OAAA,EACA/U,EAAAiV,IAAAjV,EAAA2U,QAAA,GAMA3U,EAAAiV,GAAAjV,EAAA2U,QAAA,EAAA,IACA3U,EAAAiV,GAAAjV,EAAA2U,QAAA,GAGA3U,EAAAiV,GAAAjV,EAAA2U,QAAA,EAAAgH,EAAAthB,SACA2F,EAAAiV,GAAA0G,EAAAthB,OAAA2F,EAAA2U,QAAA,GAGA3U,EAAAgV,GAAAhV,EAAA+U,OAAA,EAAA,IACA/U,EAAAgV,GAAAhV,EAAA+U,OAAA,GAGA/U,EAAAgV,GAAAhV,EAAA+U,OAAA,EAAA4G,EAAAvhB,QACA4F,EAAAgV,GAAA2G,EAAAvhB,MAAA4F,EAAA+U,OAAA,GAGAnQ,EAAAjQ,EAAA+M,EAAA1B,EAAAA,EAAA5F,MAAA4F,EAAA3F,QACAiI,EAAA3N,EAAA+M,EAAA1B,GAGA0B,EAAAoV,UACA6E,EACA3b,EAAAgV,GAAAhV,EAAA+U,OAAA,EACA/U,EAAAiV,GAAAjV,EAAA2U,QAAA,EACA3U,EAAA+U,OACA/U,EAAA2U,QACA3U,EAAA/O,EAAA+O,EAAA5F,MAAA,EACA4F,EAAA9O,EAAA8O,EAAA3F,OAAA,EACA2F,EAAA5F,MACA4F,EAAA3F,UAMAuK,EAAAjQ,EAAA+M,EAAA1B,EAAAA,EAAA5F,MAAA4F,EAAA3F,QACAiI,EAAA3N,EAAA+M,EAAA1B,GAGA0B,EAAAoV,UACA6E,EACA3b,EAAA/O,EAAA+O,EAAA5F,MAAA,EACA4F,EAAA9O,EAAA8O,EAAA3F,OAAA,EACA2F,EAAA5F,MACA4F,EAAA3F,SAMAqH,EAAAwY,YACAxY,EAAAyY,KACAna,EAAA/O,EAAA+O,EAAA5F,MAAA,EACA4F,EAAA9O,EAAA8O,EAAA3F,OAAA,EACA2F,EAAA5F,MACA4F,EAAA3F,QAGA4U,EAAAta,EAAA+M,EAAA1B,GAEA0B,EAAA6C,YACAJ,EAAAzC,EAAA1B,GACA+D,EAAArC,EAAAjL,EAAAuJ,GAGA,QAAA4b,GAAAjnB,EAAA+M,EAAAjL,EAAAuJ,EAAAlL,GACA,MAAA,YACA,GAAAiS,GAAAnS,EAAAD,EACA8iB,GAAA9iB,EAAA+M,EAAAjL,EAAAuJ,EAAAlL,GACAkL,EAAAlL,MAEAwS,EAAAP,EAAAtQ,EAAA3B,EAAA,QACAkL,EAAA6b,MAEA7b,EAAA6b,KAAA1b,KAAA4G,EAAA,GAAAjS,GAGAkL,EAAAlL,QAEAA,EAAAyT,OAAA9R,EAAA8K,WAAAC,MAAA7O,MAAA,GACAqN,EAAA8I,OAEA/B,EAAAU;AACAkP,OAAA,EACA9H,WAAA,EACApT,MAAAuE,EAAA8I,UAjIA,GAAAnU,GAAAgJ,EAAA+D,EAAAjL,EACAuJ,EAAAlL,EACA6mB,EAAAG,EAAAjH,EAFAO,EAAAvX,KAGAiW,EAAAlO,GAAAkO,UAoIA,KAAAnW,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EACAhJ,EAAAygB,EAAAzX,GACA+D,EAAAZ,EAAAsU,EAAAzX,IACA+D,IAEAjL,EAAAkO,EAAAyQ,EAAAzX,IACAqC,EAAA,GAAAH,GAAAC,GACAhL,EAAA8W,EAAAwJ,EAAAzX,GAAAqC,EAAAF,EAAAgX,IACA9W,EAAA4I,UAGAiM,EAAA7U,EAAA6U,OAEAiH,EAAAjH,EAAA9T,WACA8T,EAAAkH,KAAAD,EAEAH,EAAA9G,EACAA,IACAf,EAAAe,IAAAf,EAAAe,GAAAoC,SAEA0E,EAAA7H,EAAAe,IAGA8G,EAAA,GAAAtI,IAEAwB,EAAAjiB,MAAA,aAEA+oB,EAAAtH,YAAArU,EAAAqU,aAEAsH,EAAAI,IAAAlH,EAEAf,EAAAe,GAAA8G,IAIAA,IACAA,EAAA1E,UAAA6E,EAEAF,EAAAjnB,EAAA+M,EAAAjL,EAAAuJ,EAAAlL,MAGA6mB,EAAAC,OAAAA,EAAAjnB,EAAA+M,EAAAjL,EAAAuJ,EAAAlL,GAEA6mB,EAAAI,IAAAJ,EAAAI,OAOA,OAAA3G,IAIAxgB,EAAAmX,GAAAiQ,cAAA,SAAAlc,GAOA,QAAA8b,KAEAK,EAAAva,EAAAsa,cAAAL,EAAA3b,EAAAyU,QAEAzU,EAAA6b,MACA7b,EAAA6b,KAAA1b,KAAAiV,EAAA,GAAA6G,GAXA,GAAAva,GACA1B,EACA2b,EAAAG,EACAG,EAAApH,EAHAO,EAAAvX,IAqEA,OAtDA6D,GAAAZ,EAAAsU,EAAA,IACA1T,GAEA1B,EAAA,GAAAH,GAAAC,GAGA+U,EAAA7U,EAAA6U,OAIAxS,GAAAwS,IAGA8G,EAAA/mB,EAAA,cAAA,GACA+mB,EAAAvhB,MAAA4F,EAAA5F,MACAuhB,EAAAthB,OAAA2F,EAAA3F,OACAyhB,EAAAhb,EAAA6a,GACA9G,EAAA1U,KAAAwb,EAAAG,GACAF,MAKAE,EAAAjH,EAAA9T,WACA8T,EAAAkH,KAAAD,EAEAH,EAAA9G,GAGA8G,EAAA,GAAAtI,IAEAwB,EAAAjiB,MAAA,aAEA+oB,EAAAtH,YAAArU,EAAAqU,aAEAsH,EAAAI,IAAAlH,GAIA8G,EAAA1E,UAAA6E,EACAF,KAEAD,EAAAC,OAAAA,EAEAD,EAAAI,IAAAJ,EAAAI,OAOAE,EAAA,KAGAA,GAIArnB,EAAAmX,GAAAmQ,eAAA,SAAApc,GACA,GAAA4B,GACA1B,EACAmc,EACAC,EACAlnB,EAAAC,EACA7B,EAAA+oB,EAAA3O,EAAApB,EALA8I,EAAAvX,KAGAye,IAMA,IAFAtc,EAAA,GAAAH,GAAAC,GACA4B,EAAAZ,EAAAsU,EAAA,IACA,CAiBA,IAdApV,EAAApG,GAAAoG,EAAApG,IAAA,EACAoG,EAAAnG,GAAAmG,EAAAnG,IAAA,EACAmG,EAAAlG,GAAAkG,EAAAlG,IAAA,EACAkG,EAAAjG,GAAAiG,EAAAjG,IAAA,EAIAoiB,EAFA,OAAAnc,EAAAuU,IAAA,OAAAvU,EAAAwU,GAEA9S,EAAA6a,qBAAAvc,EAAApG,GAAAoG,EAAAnG,GAAAmG,EAAAuU,GAAAvU,EAAAlG,GAAAkG,EAAAjG,GAAAiG,EAAAwU,IAGA9S,EAAA8a,qBAAAxc,EAAApG,GAAAoG,EAAAnG,GAAAmG,EAAAlG,GAAAkG,EAAAjG,IAIAzG,EAAA,EAAA8N,SAAApB,EAAA,IAAA1M,GAAAA,GAAA,EACA8N,SAAApB,EAAA,IAAA1M,GACAgpB,EAAAza,KAAA7B,EAAA,IAAA1M,IAEAgpB,EAAAza,KAAA,KAeA,KAZAua,EAAAE,EAAAva,OAGA,OAAAua,EAAA,KACAA,EAAA,GAAA,GAGA,OAAAA,EAAAF,EAAA,KACAE,EAAAF,EAAA,GAAA,GAIA9oB,EAAA,EAAAA,EAAA8oB,EAAA9oB,GAAA,EAAA,CAGA,GAAA,OAAAgpB,EAAAhpB,GAAA,CAUA,IANAoa,EAAA,EAEApB,EAAA,EACApX,EAAAonB,EAAAhpB,GAGA+oB,EAAA/oB,EAAA,EAAA+oB,EAAAD,EAAAC,GAAA,EAAA,CACA,GAAA,OAAAC,EAAAD,GAAA,CAEAlnB,EAAAmnB,EAAAD,EACA,OAGA3O,GAAA,EAKAxY,EAAAC,IACAmnB,EAAAD,GAAAC,EAAAhpB,QAGA,QAAAgpB,EAAAhpB,KAEAgZ,GAAA,EACAgQ,EAAAhpB,GAAA4B,EAAAoX,IAAAnX,EAAAD,GAAAwY,GAGAyO,GAAAM,aAAAH,EAAAhpB,GAAA0M,EAAA,KAAA1M,EAAA,UAIA6oB,GAAA,IAEA,OAAAA,IAIAvnB,EAAAmX,GAAA2Q,UAAA,QAAAA,IAAA5c,GACA,GACAnL,GAAAgJ,EAAA+D,EAAAib,EACA3c,EACAsK,EACAsS,EAAAC,EAAAvpB,EAAAwpB,EAJA1H,EAAAvX,IAMA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAIA,GAHAhJ,EAAAygB,EAAAzX,GACA+D,EAAAZ,EAAAnM,GACAgoB,EAAAhY,EAAAyQ,EAAAzX,IACA+D,IAEA1B,EAAA,GAAAH,GAAAC,GACA8L,EAAAjX,EAAAqL,EAAAF,EAAA4c,IACA9X,EAAAwQ,EAAAzX,GAAA+D,EAAA1B,EAAAA,EAAA5F,MAAA4F,EAAA3F,QAGA,OAAA2F,EAAA5F,OAAA,OAAA4F,EAAA3F,SACA2F,EAAA5F,MAAAzF,EAAAyF,MACA4F,EAAA3F,OAAA1F,EAAA0F,OACA2F,EAAA/O,EAAA+O,EAAA5F,MAAA,EACA4F,EAAA9O,EAAA8O,EAAA3F,OAAA,GAGA,IAAA2F,EAAA5F,OAAA,IAAA4F,EAAA3F,QAAA,CAaA,GAVAuiB,EAAAlb,EAAAqb,cACA/c,EAAA/O,EAAA+O,EAAA5F,MAAA,GAAAuiB,EAAAhW,YACA3G,EAAA9O,EAAA8O,EAAA3F,OAAA,GAAAsiB,EAAAhW,WACA3G,EAAA5F,MAAAuiB,EAAAhW,WACA3G,EAAA3F,OAAAsiB,EAAAhW,YAEAkW,EAAAD,EAAAnmB,KACAqmB,EAAAD,EAAA9a,OAGA/B,EAAAgd,KACA,IAAA1pB,EAAA,EAAAA,EAAAwpB,EAAAxpB,GAAA,EACAgX,GACAJ,EAAA2S,EAAAvpB,GACA6U,EAAA0U,EAAAvpB,EAAA,GACA2pB,EAAAJ,EAAAvpB,EAAA,GACA+oB,EAAAQ,EAAAvpB,EAAA,IAEA0M,EAAAgd,KAAA7c,KAAAxL,EAAA2V,EAAAtK,GACA6c,EAAAvpB,GAAAgX,EAAAJ,EACA2S,EAAAvpB,EAAA,GAAAgX,EAAAnC,EACA0U,EAAAvpB,EAAA,GAAAgX,EAAA2S,EACAJ,EAAAvpB,EAAA,GAAAgX,EAAA+R,CAIA3a,GAAAwb,aACAN,GACA5c,EAAA/O,EAAA+O,EAAA5F,MAAA,GAAAuiB,EAAAhW,YACA3G,EAAA9O,EAAA8O,EAAA3F,OAAA,GAAAsiB,EAAAhW,YAGAjF,EAAAO,UAMA,MAAAmT,IAIAxgB,EAAAmX,GAAAoR,eAAA,SAAA5W,EAAA6W,GACA,GAAAzoB,GAAAygB,EAAAvX,KACAwf,EAAA,IAWA,OAVA,KAAAjI,EAAArT,SACApN,EAAAygB,EAAA,GACAzgB,EAAA2oB,YAEAlc,SAAAgc,IACAA,EAAA,GAEAC,EAAA1oB,EAAA2oB,UAAA,SAAA/W,EAAA6W,KAGAC,GAIAzoB,EAAAmX,GAAAwR,iBAAA,SAAAhI,GACA,GACA5gB,GAAAgJ,EAAA+D,EACA8b,EAAAC,EAAAC,EACAC,EAAAC,EACAnnB,EAJA2e,EAAAvX,IAMA,KAAAF,EAAA,EAAAA,EAAAyX,EAAArT,OAAApE,GAAA,EAEAhJ,EAAAygB,EAAAzX,GACA+D,EAAAZ,EAAAnM,GACA8B,EAAAkO,EAAAyQ,EAAAzX,IAGAlH,EAAAmQ,SAGA4W,EAAAlf,EAAAkf,kBAAA,EACAC,EAAA/b,EAAAmc,8BACAnc,EAAAoc,2BACApc,EAAAqc,0BACArc,EAAAsc,yBACAtc,EAAAuc,wBAAA,EAGAP,EAAAF,EAAAC,EAEA,IAAAC,IAIAC,EAAAhpB,EAAAyF,MACAwjB,EAAAjpB,EAAA0F,OAGA1F,EAAAyF,MAAAujB,EAAAD,EACA/oB,EAAA0F,OAAAujB,EAAAF,EAGA/oB,EAAA4Y,MAAAnT,MAAAujB,EAAA,KACAhpB,EAAA4Y,MAAAlT,OAAAujB,EAAA,KAGAlc,EAAAyD,MAAAuY,EAAAA,IAKAjnB,EAAAkQ,WAAA+W,EAEAjnB,EAAAmQ,QAAA,EAGA2O,GACAA,EAAApV,KAAAxL,EAAA+oB,GAMA,OAAAtI,IAIAnO,GAAAiX,WAAA,WACA,GAAAC,EACA,KAAAA,IAAAvY,IACA3F,OAAA5C,UAAA6C,eAAAC,KAAAyF,GAAAuY,KACAvY,GAAAuY,QAMAvpB,EAAAwpB,QAAAzpB,OAAAyM,SAAAxM,EAAA,cAAA,GAAAmM,WAGAV,GAAA4G,IACAmM,SAAAA,GACAiL,eAAA/b,EACAgc,eAAA1Z,EACA2Z,aAAAtP,EACA1K,UAAAF,EACAma,cAAArM,GACAjG,YAAAoG,KAEA1d,EAAAqS,QAAAA,GACArS,EAAAiL,cAAAA,GHxzIA,IAAAzO,SAAA,IACAE,QAAA,GACA,MAAAiD,WAAA,GACA,IAAAmF,0BAAA,UACAkB,WAAA,OACApD,YAAA,GACA2D,iBAAA,MACAhD,gBAAA,GACA/B,YAAA,QCFAqoB,YAAA7pB,EAAA,wEACAwI,WAAAxI,EAAA,eAAA6I,OAAAghB,YAEAlf,QAAA8N,UAAAqR,MAAA,WAEA,GAAAvhB,GAAAvI,EAAA,cAEA,oBAAAuI,GAAAwhB,SAEAxhB,EAAAM,OAAAL,YAUAD,EAAA1G,KAAA,QAAA0G,EAAAyhB,KAAA,UAAA7c,QAEA0c,YAAAtgB,GAAA,QAAA,SAAAR,GAEAA,EAAAC,iBAGAV,WAAAC,EAAAC","file":"main.min.js","sourcesContent":["var CenterX = 300;\nvar CenterY = 300;\nconst bigRadius = 250;\nvar colorRayAndCircleByLabel = '#48D1CC';\nvar colorLabel = '#36c';\nvar radiusLabel = 15;\nvar colorSelectLabel = \"Red\";\nvar shadowLabelSize = 10;\nvar shadowColor = \"white\";\n\n/*\n * General functions\n * */\n\n/**\n * Из декартовой в полярную систему координат.\n *\n * @param {float} x\n * @param {float} y\n * @returns {object}\n */\nfunction cartesian2Polar(x, y) {\n  var upX = (x-CenterX);\n  var upY = (y-CenterY);\n  distance = Math.sqrt(upX * upX + upY * upY);\n  radians = Math.atan2(upY, upX);\n  degr = radians*180/Math.PI+90;\n  polarCoor = {distance: distance, degr: degr};\n  return polarCoor;\n}\n\n/**\n * From polar in dec\n *\n * @param {float} radius\n * @param {float} degr\n * @returns {object}\n */\nfunction cartesian2Dec(radius, degr) {\n  radians = (degr-90)*(Math.PI/180);\n  if(degr >= 0 && degr <= 180){\n    tan  = Math.tan(radians);\n    x = Math.sqrt((Math.pow(radius,2))/(Math.pow(tan,2)+1));\n    y = x*tan;\n  }else{\n    tan  = Math.tan(-radians);\n    x = -Math.sqrt((Math.pow(radius,2))/(Math.pow(tan,2)+1));\n    y = -x*tan;\n  }\n  decCoor = {X: x+CenterX, Y: y+CenterY};\n  return decCoor;\n}\n\n/**\n * From polar in dec\n *\n * @param {float} radius\n * @param {float} degr\n * @returns {object}\n */\nfunction cartesian2DecForBorder(radius, degr) {\n  var newDegr = (degr-90);\n  radians = newDegr*(Math.PI/180);\n\n  if(newDegr >= 0 && newDegr <= 180){\n    tan  = Math.tan(radians);\n    x = Math.sqrt((radius*radius)/(tan*tan+1));\n    y = x*tan;\n  }else{\n    tan  = Math.tan(-radians);\n    x = Math.sqrt((radius*radius)/(tan*tan+1));\n    y = x*tan;\n  }\n\n  decCoor = {X: x, Y: y};\n\n  return decCoor;\n}\n\n/**\n *function for convert HEX -> rgba\n * */\n\nfunction hexInArray(h){\n  var m = h.slice(1).match(/.{2}/g);\n  m[0]=parseInt(m[0], 16);\n  m[1]=parseInt(m[1], 16);\n  m[2]=parseInt(m[2], 16);\n  return m;\n};\n\nfunction hexArrayInRgbString(m) {\n  var rgb = 'rgb('+m[0]+', '+m[1]+', '+m[2]+')';\n  return rgb;\n}\n\nfunction changeColorLayers(color,numLayers) {\n  var arColor = hexInArray(color);\n  var tempColor = arColor;\n  var arRBA = [];\n  var i = 0;\n  var difColorRed = (256-arColor[0])/numLayers;\n  var difColorGreen = (arColor[1])/(numLayers-1);\n  var difColorBlue = (arColor[2])/(numLayers-1);\n  var red = arColor[0] + difColorRed;\n  var green = arColor[1];\n  var blue = arColor[2];\n  for(red; red <= 256.01; red = red + difColorRed){\n    tempColor[0] = Math.floor(red);\n    tempColor[1] = Math.floor(green);\n    tempColor[2] = Math.floor(blue);\n    arRBA[i] = hexArrayInRgbString(tempColor);\n    green = green - difColorGreen;\n    blue = blue - difColorBlue;\n    i++;\n  }\n  console.log(arRBA);\n  return arRBA;\n}\n\n/*\n * Block functions for sectors\n * */\n\nfunction createSectorNew(sector_id, beginAngle, endAngle, circle_id, numLayers, color) {\n  var i;\n\n  var sector_id = sector_id;\n  var beginAngle = beginAngle;\n  var endAngle = endAngle;\n  var circle_id = circle_id;\n  var numLayers = numLayers;\n  var color = color;\n\n  var arColors = changeColorLayers(color,numLayers);\n  var difRadius = bigRadius/numLayers;\n  var radius = bigRadius;\n\n  var nameArc = 'mainArc_'+sector_id;\n  var nameSector = 'main_sector_'+sector_id;\n  var nameGroup = 'sector_'+sector_id;\n  var canvas = $('canvas');\n\n  for(i=1;i<=numLayers;i++){\n    canvas.drawSlice({\n      layer: true,\n      mask: true,\n      groups: [nameGroup],\n      fillStyle: arColors[i-1],\n      x: CenterX, y: CenterY,\n      start: beginAngle,\n      end: endAngle,\n      radius: radius,\n      strokeStyle: '#f60',\n      strokeWidth: 3,\n    }).restoreCanvas({\n      layer: true\n    });\n\n    radius = radius - difRadius;\n  }\n\n  canvas.drawSlice({\n    layer: true,\n    mask: true,\n    x: CenterX, y: CenterY,\n    start: beginAngle,\n    end: endAngle,\n    name: nameSector,\n    groups: [nameGroup],\n    circle_id: circle_id,\n    sector_id: sector_id,\n    radius: bigRadius,\n    numLayers : numLayers,\n    color : color,\n    dblclick: function(layer) {\n      var polar = cartesian2Polar(layer.eventX, layer.eventY);\n      var link = $('#create_label_link').attr('href','/app_dev.php/notes/new/'+layer.circle_id+'?radius='+polar.distance/bigRadius+'&degr='+polar.degr);\n      link.removeClass( \"btn-primary\" ).addClass( \"btn-danger\" );\n      link.text('Добавить заметку в выбрнный сектор');\n    },\n    click: function(layer) {\n      $('canvas').drawArc({\n        shadowBlur: 40,\n        shadowColor: 'white',\n        strokeStyle: 'white',\n        name: nameArc,\n        groups: [nameGroup],\n        strokeWidth: 3,\n        x: CenterX, y: CenterY,\n        radius: bigRadius,\n        start: beginAngle,\n        end: endAngle,\n      }).restoreCanvas({\n        layer: true\n      });\n    },\n    mouseout: function(layer) {\n      $('canvas').setLayer(nameArc, {\n        shadowBlur: 0\n      }).drawLayer();\n    }\n  });\n\n  canvas.restoreCanvas({\n    layer: true\n  });\n}\n\nfunction createBorderSector(data) {\n  var endCoord = cartesian2DecForBorder(bigRadius, data.beginAngle);\n  $('canvas').drawVector({\n    strokeStyle: 'white',\n    strokeWidth: 4,\n    x: CenterX, y: CenterY,\n    a1: endCoord.X, l1: endCoord.Y\n  });\n}\n\nfunction borderForSector(angle, sectorLeftId, sectorRightId, angleMin, angelMax) {\n  var LabelCoord = cartesian2Dec(bigRadius, angle);\n  var leftCoord = cartesian2Dec(bigRadius, angleMin+5);\n  var rightCoord = cartesian2Dec(bigRadius, angelMax-5);\n  $('canvas').drawArc({\n    layer: true,\n    draggable: true,\n    sectorLeftId: sectorLeftId,\n    sectorRightId: sectorRightId,\n    name: 'border_'+sectorLeftId+'_'+sectorRightId,\n    fillStyle: 'yellow',\n    x: LabelCoord.X, y: LabelCoord.Y,\n    radius: radiusLabel,\n    circlePath: true,\n    circleRadius: bigRadius,\n    circleCenterX: CenterX,\n    circleCenterY: CenterY,\n    xMin: leftCoord.X, yMin: leftCoord.Y,\n    xMax: rightCoord.X, yMax: rightCoord.Y,\n    data: {'sectorLeft': sectorLeftId , 'sectorRight': sectorRightId},\n    shadowColor: shadowColor,\n    shadowBlur: shadowLabelSize,\n    dragstop: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n      var sectorLeft = $('canvas').getLayer( 'main_sector_'+layer.sectorLeftId);\n      var sectorRight = $('canvas').getLayer('main_sector_'+layer.sectorRightId);\n\n      var circleId = sectorLeft.circle_id;\n      var numLayers = sectorLeft.numLayers;\n\n      var beginAngleL = sectorLeft.start;\n      var colorL = sectorLeft.color;\n\n      var endAngleR = sectorRight.end;\n      var colorR = sectorRight.color;\n\n      // sectorLeft.end = pol.degr;\n      // sectorRight.start = pol.degr;\n\n      var newLeftSectorMinAngle = sectorLeft.start;\n      var newRightSectorMinAngle = pol.degr;\n      var oldLeftSectorMinAngle = sectorLeft.start;\n      var oldRightSectorMinAngle = sectorRight.start;\n      var coefficientLeft = (pol.degr - beginAngleL)/(sectorLeft.end - sectorLeft.start);\n      var coefficientRight = (endAngleR - pol.degr)/(sectorRight.end - sectorRight.start);\n\n      updateLabelPositionByChangingSector(layer,coefficientLeft,coefficientRight,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle);\n\n      $('canvas').removeLayerGroup('sector_'+sectorLeftId);\n      createSectorNew(sectorLeftId,beginAngleL,pol.degr, circleId, numLayers, colorL);\n\n      $('canvas').removeLayerGroup('sector_'+sectorRightId);\n      createSectorNew(sectorRightId,pol.degr,endAngleR, circleId, numLayers, colorR);\n\n      setHightMoveLayerToLayer();\n\n      // $('canvas').removeLayer('border_'+sectorLeftId+'_'+sectorRightId);\n      // borderForSector(pol.degr,sectorLeftId,sectorRightId);\n\n\n      // updateCoordinateLabel(layer.data.circleId,layer.data.id,pol.distance/bigRadius,pol.degr);\n      // delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    drag: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n\n      $('canvas').drawVector({\n        strokeStyle: 'white',\n        strokeWidth: 4,\n        x: CenterX, y: CenterY,\n        a1: pol.degr, l1: pol.distance\n      });\n    },\n    mouseover: function(layer) {\n      $('canvas').drawVector({\n        strokeStyle: 'white',\n        strokeWidth: 4,\n        x: CenterX, y: CenterY,\n        a1: angle, l1: bigRadius\n      });\n    },\n    mouseout: function(layer) {\n      // var Label = $('canvas').getLayer(layer.name);\n      // Label.fillStyle = colorLabel;\n      // delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    dblclick: function(layer) {\n      // $('#pop_label_link').css('display','block').attr('href','/app_dev.php/notes/list/'+layer.data.circleId+'/'+layer.data.id+'/');\n    },\n  });\n}\n\n/*\n* Block functions for labels\n* */\n\nfunction rayAndCircleByLabel(layer,id) {\n  var pol = cartesian2Polar(layer.x, layer.y);\n  var dec = cartesian2Dec(bigRadius*2,pol.degr);\n  $('canvas').drawArc({\n    layer: true,\n    strokeStyle: colorRayAndCircleByLabel,\n    strokeWidth: 3,\n    name: 'circleByLabel'+id,\n    groups: ['circleByLabel'],\n    x: CenterX, y: CenterY,\n    radius: pol.distance,\n  });\n  $('canvas').drawLine({\n    layer: true,\n    strokeWidth: 3,\n    name: 'lineByLabel'+id,\n    groups: ['lineByLabel'],\n    strokeStyle: colorRayAndCircleByLabel,\n    x1: CenterX, y1: CenterY,\n    x2: dec.X, y2: dec.Y,\n  });\n}\n\nfunction createNamePopUpLabel(id,x,y,text) {\n  var heightPopUp = 30;\n  var widthPopUp = 150;\n\n  $('canvas').drawRect({\n    layer: true,\n    fillStyle: 'white',\n    strokeStyle: '#c33',\n    strokeWidth: 2,\n    name: 'nameLabelPopup'+id,\n    groups: ['nameLabelPopup'],\n    x: x + widthPopUp/2, y: y - heightPopUp/2 - 10,\n    width: widthPopUp,\n    height: heightPopUp,\n    cornerRadius: 10\n  });\n  $('canvas').drawText({\n    layer: true,\n    name: 'nameLabelPopupText'+id,\n    groups: ['nameLabelPopupText'],\n    fillStyle: 'black',\n    strokeWidth: 2,\n    x: x + widthPopUp/2, y: y - heightPopUp/2 - 10,\n    fontSize: '10pt',\n    fontFamily: 'Verdana, sans-serif',\n    maxWidth: widthPopUp,\n    text: text\n  })\n}\n\n\nfunction createLabel(data) {\n  var LabelCoord = cartesian2Dec(data.radius*bigRadius, data.degr);\n  // console.log(data.radius);\n  $('canvas').drawArc({\n    layer: true,\n    draggable: true,\n    groups: ['note_labels'],\n    name: 'myLabel'+data.id,\n    fillStyle: colorLabel,\n    x: LabelCoord.X, y: LabelCoord.Y,\n    radius: radiusLabel,\n    data: {'id' : data.id, 'name': data.name , 'circleId': data.circleId},\n    label_radius: data.radius,\n    label_angle: data.degr,\n    label_id: data.id,\n    shadowColor: shadowColor,\n    shadowBlur: shadowLabelSize,\n    dragstop: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n      var dec = cartesian2Dec(pol.distance,pol.degr);\n\n      layer.label_radius = pol.distance/bigRadius;\n      layer.label_angle = pol.degr;\n      // console.log(layer.label_radius,layer.label_angle);\n\n      updateCoordinateLabel(layer.data.circleId,layer.data.id,pol.distance/bigRadius,pol.degr);\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    drag: function(layer) {\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n      rayAndCircleByLabel(layer,layer.data.id);\n    },\n    mouseover: function(layer) {\n      var Label = $('canvas').getLayer(layer.name);\n      Label.fillStyle = colorSelectLabel;\n      delRayNamePopUpAndCircleAllLabels();\n      rayAndCircleByLabel(layer,layer.data.id);\n      setLinkLabelsByRadiusAndAngle(layer.label_radius,layer.label_angle, layer.label_id);\n      createNamePopUpLabel(layer.data.id,layer.x,layer.y,layer.data.name);\n    },\n    mouseout: function(layer) {\n      var Label = $('canvas').getLayer(layer.name);\n      Label.fillStyle = colorLabel;\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n      removeLinkLabelsByRadiusAndAngle(layer.label_radius,layer.label_angle, layer.label_id);\n    },\n    dblclick: function(layer) {\n      $('#pop_label_link').css('display','block').attr('href','/app_dev.php/notes/list/'+layer.data.circleId+'/'+layer.data.id+'/');\n    },\n  });\n}\n\nfunction setHightMoveLayerToLayer(){\n  // Returns an array containing all draggable layers\n  var dragLayers = $('canvas').getLayers(function(layer) {\n    return (layer.draggable === true);\n  });\n\n  function setMoveLayerToLayer(layer, index, array) {\n    $('canvas').moveLayer(layer.name, 100);\n  }\n  dragLayers.forEach(setMoveLayerToLayer);\n}\n\nfunction setLinkLabelsByRadiusAndAngle(radius, angle, label_id){\n  var labels = $('canvas').getLayerGroup('note_labels');\n  var radiusBorderMin = radius - 0.05;\n  var radiusBorderMax = radius + 0.05;\n  var angleBorderMin = angle - 10;\n  var angleBorderMax = angle + 10;\n  // console.log(radiusBorderMin,radiusBorderMax,angleBorderMin,angleBorderMax);\n\n  function setFillStyleToLayer(layer, index, array) {\n    if(layer.id !== label_id){\n      if((layer.label_angle > angleBorderMin && layer.label_angle < angleBorderMax)\n          || (layer.label_radius > radiusBorderMin && layer.label_radius < radiusBorderMax) ){\n        // console.log(layer.label_angle,layer.label_radius);\n        createNamePopUpLabel(layer.label_id,layer.x,layer.y,layer.data.name);\n        layer.fillStyle = colorSelectLabel;\n      }\n    }\n  }\n  labels.forEach(setFillStyleToLayer);\n}\n\nfunction removeLinkLabelsByRadiusAndAngle(radius, angle, label_id){\n  var labels = $('canvas').getLayerGroup('note_labels');\n  var radiusBorderMin = radius - 0.03;\n  var radiusBorderMax = radius + 0.03;\n  var angleBorderMin = angle - 10;\n  var angleBorderMax = angle + 10;\n  // console.log(radiusBorderMin,radiusBorderMax,angleBorderMin,angleBorderMax);\n\n  function deleteFillStyleToLayer(layer, index, array) {\n    if(layer.label_id !== label_id){\n      if((layer.label_angle > angleBorderMin && layer.label_angle < angleBorderMax)\n          || (layer.label_radius > radiusBorderMin && layer.label_radius < radiusBorderMax) ){\n        // console.log(layer.label_angle,layer.label_radius);\n        layer.fillStyle = colorLabel;\n        delNamePopUpByLabel(layer.label_id);\n      }\n    }\n  }\n  labels.forEach(deleteFillStyleToLayer);\n}\n\nfunction updateLabelPositionByChangingSector(border,coefficientLeft,coefficientRight,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle) {\n  var sector_left = $('canvas').getLayer('main_sector_'+border.sectorLeftId);\n  var sector_right = $('canvas').getLayer('main_sector_'+border.sectorRightId);\n  var labels = $('canvas').getLayerGroup('note_labels');\n\n  if(typeof labels !== 'undefined'){\n    function updateLabelPosition(label, index, array) {\n\n      if(label.label_angle > sector_left.start && label.label_angle < sector_left.end){\n        var newAngle = (label.label_angle-oldLeftSectorMinAngle)*coefficientLeft+newLeftSectorMinAngle;\n        var LabelCoord = cartesian2Dec(label.label_radius*bigRadius, newAngle);\n        label.x = LabelCoord.X;\n        label.y = LabelCoord.Y;\n        console.log(label.name,label.label_angle,newAngle,sector_left,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle,coefficientLeft);\n        label.label_angle = newAngle;\n      }else if(label.label_angle > sector_right.start && label.label_angle < sector_right.end){\n        var newAngle = (label.label_angle-oldRightSectorMinAngle)*coefficientRight+newRightSectorMinAngle;\n        var LabelCoord = cartesian2Dec(label.label_radius*bigRadius, newAngle);\n        label.x = LabelCoord.X;\n        label.y = LabelCoord.Y;\n        label.label_angle = newAngle;\n      }\n    }\n    labels.forEach(updateLabelPosition);\n  }\n\n  // console.log(sector_left,sector_right);\n}\n\n\nfunction updateCoordinateLabel(circleId,labelId,radius,angle) {\n  $.post(\n      \"/app_dev.php/circle/editLabelAjax\",\n      {\n        circleId: circleId,\n        labelId:labelId,\n        radius:radius,\n        angle:angle\n      }).done(\n      function (data) {\n        console.log(data);\n\n      })\n}\n\nfunction delRayNamePopUpAndCircleByLabel(id) {\n  $('canvas').removeLayer('circleByLabel'+id);\n  $('canvas').removeLayer('lineByLabel'+id);\n  $('canvas').removeLayer('nameLabelPopup'+id);\n  $('canvas').removeLayer('nameLabelPopupText'+id);\n}\n\nfunction delNamePopUpByLabel(id) {\n  $('canvas').removeLayer('nameLabelPopup'+id);\n  $('canvas').removeLayer('nameLabelPopupText'+id);\n}\n\nfunction delRayNamePopUpAndCircleAllLabels() {\n  $('canvas').removeLayerGroup('circleByLabel');\n  $('canvas').removeLayerGroup('lineByLabel');\n  $('canvas').removeLayerGroup('nameLabelPopup');\n  $('canvas').removeLayerGroup('nameLabelPopupText');\n}","/*\n* block for creating sectors\n* */\n\n// setup an \"add a tag\" link\n//btn btn-primary btn-block\nvar $addTagLink = $('<a href=\"#\" class=\"btn btn-primary btn-block\">Добавить категорию</a>');\nvar $newLinkLi = $('<div></div>').append($addTagLink);\n\njQuery(document).ready(function() {\n  // Get the ul that holds the collection of tags\n  var $collectionHolder = $('div.sectors');\n\n  if (typeof $collectionHolder.html() !== 'undefined'){\n    // add the \"add a tag\" anchor and li to the tags ul\n    $collectionHolder.append($newLinkLi);\n\n// TODO add when logic for delete sector will be ready\n//         // add a delete link to all of the existing tag form li elements\n//         $collectionHolder.find('li').each(function() {\n//           addTagFormDeleteLink($(this));\n//         });\n\n    // count the current form inputs we have (e.g. 2), use that as the new\n    // index when inserting a new item (e.g. 2)\n    $collectionHolder.data('index', $collectionHolder.find(':input').length);\n\n    $addTagLink.on('click', function(e) {\n      // prevent the link from creating a \"#\" on the URL\n      e.preventDefault();\n\n      // add a new tag form (see code block below)\n      addTagForm($collectionHolder, $newLinkLi);\n    });\n  }\n\n});\n\nfunction addTagForm($collectionHolder, $newLinkLi) {\n  // Get the data-prototype explained earlier\n  var prototype = $collectionHolder.data('prototype');\n\n  // get the new index\n  var index = $collectionHolder.data('index');\n\n  // Replace '$$name$$' in the prototype's HTML to\n  // instead be a number based on how many items we have\n  var newForm = prototype.replace(/__name__/g, index);\n\n  // increase the index with one for the next item\n  $collectionHolder.data('index', index + 1);\n\n  // Display the form in the page in an li, before the \"Add a tag\" link li\n  var $newFormLi = $(newForm);\n\n  // also add a remove button, just for this example\n  $newFormLi.append('<button class=\"remove-tag btn btn-danger\"><i class=\"fa fa-remove fa-lg\"></i></button>');\n\n  $newLinkLi.before($newFormLi);\n\n  // handle the removal, just for this example\n  $('.remove-tag').click(function(e) {\n    e.preventDefault();\n\n    $(this).parent().remove();\n\n    return false;\n  });\n\n//         // add a delete link to the new form\n//         addTagFormDeleteLink($newFormLi);\n}\n\nfunction addTagFormDeleteLink($tagFormLi) {\n  var $removeFormA = $('<a href=\"#\">delete this tag</a>');\n  $tagFormLi.append($removeFormA);\n\n  $removeFormA.on('click', function(e) {\n    // prevent the link from creating a \"#\" on the URL\n    e.preventDefault();\n\n    // remove the li for the tag form\n    $tagFormLi.remove();\n  });\n}","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","/**\n * @license jCanvas v20.1.4\n * Copyright 2017 Caleb Evans\n * Released under the MIT license\n */\n(function (jQuery, global, factory) {\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = function (jQuery, w) {\n      return factory(jQuery, w);\n    };\n  } else {\n    factory(jQuery, global);\n  }\n\n// Pass this if window is not defined yet\n}(typeof window !== 'undefined' ? window.jQuery : {}, typeof window !== 'undefined' ? window : this, function ($, window) {\n  'use strict';\n\n  var document = window.document,\n      Image = window.Image,\n      Array = window.Array,\n      getComputedStyle = window.getComputedStyle,\n      Math = window.Math,\n      Number = window.Number,\n      parseFloat = window.parseFloat;\n\n// Define local aliases to frequently used properties\n  var defaults,\n      // Aliases to jQuery methods\n      extendObject = $.extend,\n      inArray = $.inArray,\n      typeOf = function (operand) {\n        return Object.prototype.toString.call(operand)\n            .slice(8, -1).toLowerCase();\n      },\n      isFunction = $.isFunction,\n      isPlainObject = $.isPlainObject,\n      // Math constants and functions\n      PI = Math.PI,\n      round = Math.round,\n      abs = Math.abs,\n      sin = Math.sin,\n      cos = Math.cos,\n      atan2 = Math.atan2,\n      // The Array slice() method\n      arraySlice = Array.prototype.slice,\n      // jQuery's internal event normalization function\n      jQueryEventFix = $.event.fix,\n      // Object for storing a number of internal property maps\n      maps = {},\n      // jQuery internal caches\n      caches = {\n        dataCache: {},\n        propCache: {},\n        imageCache: {}\n      },\n      // Base transformations\n      baseTransforms = {\n        rotate: 0,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        // Store all previous masks\n        masks: []\n      },\n      // Object for storing CSS-related properties\n      css = {},\n      tangibleEvents = [\n        'mousedown',\n        'mousemove',\n        'mouseup',\n        'mouseover',\n        'mouseout',\n        'touchstart',\n        'touchmove',\n        'touchend'\n      ];\n\n// Constructor for creating objects that inherit from jCanvas preferences and defaults\n  function jCanvasObject(args) {\n    var params = this,\n        propName;\n    // Copy the given parameters into new object\n    for (propName in args) {\n      // Do not merge defaults into parameters\n      if (Object.prototype.hasOwnProperty.call(args, propName)) {\n        params[propName] = args[propName];\n      }\n    }\n    return params;\n  }\n\n// jCanvas object in which global settings are other data are stored\n  var jCanvas = {\n    // Events object for storing jCanvas event initiation functions\n    events: {},\n    // Object containing all jCanvas event hooks\n    eventHooks: {},\n    // Settings for enabling future jCanvas features\n    future: {}\n  };\n\n// jCanvas default property values\n  function jCanvasDefaults() {\n    extendObject(this, jCanvasDefaults.baseDefaults);\n  }\n  jCanvasDefaults.baseDefaults = {\n    align: 'center',\n    arrowAngle: 90,\n    arrowRadius: 0,\n    autosave: true,\n    baseline: 'middle',\n    bringToFront: false,\n    ccw: false,\n    closed: false,\n    compositing: 'source-over',\n    concavity: 0,\n    cornerRadius: 0,\n    count: 1,\n    cropFromCenter: true,\n    crossOrigin: null,\n    cursors: null,\n    disableEvents: false,\n    draggable: false,\n    dragGroups: null,\n    groups: null,\n    data: null,\n    dx: null,\n    dy: null,\n    end: 360,\n    eventX: null,\n    eventY: null,\n    fillStyle: 'transparent',\n    fontStyle: 'normal',\n    fontSize: '12pt',\n    fontFamily: 'sans-serif',\n    fromCenter: true,\n    height: null,\n    imageSmoothing: true,\n    inDegrees: true,\n    intangible: false,\n    index: null,\n    letterSpacing: null,\n    lineHeight: 1,\n    layer: false,\n    mask: false,\n    maxWidth: null,\n    miterLimit: 10,\n    name: null,\n    opacity: 1,\n    r1: null,\n    r2: null,\n    radius: 0,\n    repeat: 'repeat',\n    respectAlign: false,\n    restrictDragToAxis: null,\n    rotate: 0,\n    rounded: false,\n    scale: 1,\n    scaleX: 1,\n    scaleY: 1,\n    shadowBlur: 0,\n    shadowColor: 'transparent',\n    shadowStroke: false,\n    shadowX: 0,\n    shadowY: 0,\n    sHeight: null,\n    sides: 0,\n    source: '',\n    spread: 0,\n    start: 0,\n    strokeCap: 'butt',\n    strokeDash: null,\n    strokeDashOffset: 0,\n    strokeJoin: 'miter',\n    strokeStyle: 'transparent',\n    strokeWidth: 1,\n    sWidth: null,\n    sx: null,\n    sy: null,\n    text: '',\n    translate: 0,\n    translateX: 0,\n    translateY: 0,\n    type: null,\n    visible: true,\n    width: null,\n    x: 0,\n    y: 0\n  };\n  defaults = new jCanvasDefaults();\n  jCanvasObject.prototype = defaults;\n\n  /* Internal helper methods */\n\n// Determines if the given operand is a string\n  function isString(operand) {\n    return (typeOf(operand) === 'string');\n  }\n\n// Determines if the given operand is numeric\n  function isNumeric(operand) {\n    return !isNaN(Number(operand)) && !isNaN(parseFloat(operand));\n  }\n\n// Get 2D context for the given canvas\n  function _getContext(canvas) {\n    return (canvas && canvas.getContext ? canvas.getContext('2d') : null);\n  }\n\n// Coerce designated number properties from strings to numbers\n  function _coerceNumericProps(props) {\n    var propName, propType, propValue;\n    // Loop through all properties in given property map\n    for (propName in props) {\n      if (Object.prototype.hasOwnProperty.call(props, propName)) {\n        propValue = props[propName];\n        propType = typeOf(propValue);\n        // If property is non-empty string and value is numeric\n        if (propType === 'string' && isNumeric(propValue) && propName !== 'text') {\n          // Convert value to number\n          props[propName] = parseFloat(propValue);\n        }\n      }\n    }\n    // Ensure value of text property is always a string\n    if (props.text !== undefined) {\n      props.text = String(props.text);\n    }\n  }\n\n// Clone the given transformations object\n  function _cloneTransforms(transforms) {\n    // Clone the object itself\n    transforms = extendObject({}, transforms);\n    // Clone the object's masks array\n    transforms.masks = transforms.masks.slice(0);\n    return transforms;\n  }\n\n// Save canvas context and update transformation stack\n  function _saveCanvas(ctx, data) {\n    var transforms;\n    ctx.save();\n    transforms = _cloneTransforms(data.transforms);\n    data.savedTransforms.push(transforms);\n  }\n\n// Restore canvas context update transformation stack\n  function _restoreCanvas(ctx, data) {\n    if (data.savedTransforms.length === 0) {\n      // Reset transformation state if it can't be restored any more\n      data.transforms = _cloneTransforms(baseTransforms);\n    } else {\n      // Restore canvas context\n      ctx.restore();\n      // Restore current transform state to the last saved state\n      data.transforms = data.savedTransforms.pop();\n    }\n  }\n\n// Set the style with the given name\n  function _setStyle(canvas, ctx, params, styleName) {\n    if (params[styleName]) {\n      if (isFunction(params[styleName])) {\n        // Handle functions\n        ctx[styleName] = params[styleName].call(canvas, params);\n      } else {\n        // Handle string values\n        ctx[styleName] = params[styleName];\n      }\n    }\n  }\n\n// Set canvas context properties\n  function _setGlobalProps(canvas, ctx, params) {\n    _setStyle(canvas, ctx, params, 'fillStyle');\n    _setStyle(canvas, ctx, params, 'strokeStyle');\n    ctx.lineWidth = params.strokeWidth;\n    // Optionally round corners for paths\n    if (params.rounded) {\n      ctx.lineCap = ctx.lineJoin = 'round';\n    } else {\n      ctx.lineCap = params.strokeCap;\n      ctx.lineJoin = params.strokeJoin;\n      ctx.miterLimit = params.miterLimit;\n    }\n    // Reset strokeDash if null\n    if (!params.strokeDash) {\n      params.strokeDash = [];\n    }\n    // Dashed lines\n    if (ctx.setLineDash) {\n      ctx.setLineDash(params.strokeDash);\n    }\n    ctx.webkitLineDash = params.strokeDash;\n    ctx.lineDashOffset = ctx.webkitLineDashOffset = ctx.mozDashOffset = params.strokeDashOffset;\n    // Drop shadow\n    ctx.shadowOffsetX = params.shadowX;\n    ctx.shadowOffsetY = params.shadowY;\n    ctx.shadowBlur = params.shadowBlur;\n    ctx.shadowColor = params.shadowColor;\n    // Opacity and composite operation\n    ctx.globalAlpha = params.opacity;\n    ctx.globalCompositeOperation = params.compositing;\n    // Support cross-browser toggling of image smoothing\n    if (params.imageSmoothing) {\n      ctx.imageSmoothingEnabled = params.imageSmoothing;\n    }\n  }\n\n// Optionally enable masking support for this path\n  function _enableMasking(ctx, data, params) {\n    if (params.mask) {\n      // If jCanvas autosave is enabled\n      if (params.autosave) {\n        // Automatically save transformation state by default\n        _saveCanvas(ctx, data);\n      }\n      // Clip the current path\n      ctx.clip();\n      // Keep track of current masks\n      data.transforms.masks.push(params._args);\n    }\n  }\n\n// Restore individual shape transformation\n  function _restoreTransform(ctx, params) {\n    // If shape has been transformed by jCanvas\n    if (params._transformed) {\n      // Restore canvas context\n      ctx.restore();\n    }\n  }\n\n// Close current canvas path\n  function _closePath(canvas, ctx, params) {\n    var data;\n\n    // Optionally close path\n    if (params.closed) {\n      ctx.closePath();\n    }\n\n    if (params.shadowStroke && params.strokeWidth !== 0) {\n      // Extend the shadow to include the stroke of a drawing\n\n      // Add a stroke shadow by stroking before filling\n      ctx.stroke();\n      ctx.fill();\n      // Ensure the below stroking does not inherit a shadow\n      ctx.shadowColor = 'transparent';\n      ctx.shadowBlur = 0;\n      // Stroke over fill as usual\n      ctx.stroke();\n\n    } else {\n      // If shadowStroke is not enabled, stroke & fill as usual\n\n      ctx.fill();\n      // Prevent extra shadow created by stroke (but only when fill is present)\n      if (params.fillStyle !== 'transparent') {\n        ctx.shadowColor = 'transparent';\n      }\n      if (params.strokeWidth !== 0) {\n        // Only stroke if the stroke is not 0\n        ctx.stroke();\n      }\n\n    }\n\n    // Optionally close path\n    if (!params.closed) {\n      ctx.closePath();\n    }\n\n    // Restore individual shape transformation\n    _restoreTransform(ctx, params);\n\n    // Mask shape if chosen\n    if (params.mask) {\n      // Retrieve canvas data\n      data = _getCanvasData(canvas);\n      _enableMasking(ctx, data, params);\n    }\n\n  }\n\n// Transform (translate, scale, or rotate) shape\n  function _transformShape(canvas, ctx, params, width, height) {\n\n    // Get conversion factor for radians\n    params._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n    params._transformed = true;\n    ctx.save();\n\n    // Optionally measure (x, y) position from top-left corner\n    if (!params.fromCenter && !params._centered && width !== undefined) {\n      // Always draw from center unless otherwise specified\n      if (height === undefined) {\n        height = width;\n      }\n      params.x += width / 2;\n      params.y += height / 2;\n      params._centered = true;\n    }\n    // Optionally rotate shape\n    if (params.rotate) {\n      _rotateCanvas(ctx, params, null);\n    }\n    // Optionally scale shape\n    if (params.scale !== 1 || params.scaleX !== 1 || params.scaleY !== 1) {\n      _scaleCanvas(ctx, params, null);\n    }\n    // Optionally translate shape\n    if (params.translate || params.translateX || params.translateY) {\n      _translateCanvas(ctx, params, null);\n    }\n\n  }\n\n  /* Plugin API */\n\n// Extend jCanvas with a user-defined method\n  jCanvas.extend = function extend(plugin) {\n\n    // Create plugin\n    if (plugin.name) {\n      // Merge properties with defaults\n      if (plugin.props) {\n        extendObject(defaults, plugin.props);\n      }\n      // Define plugin method\n      $.fn[plugin.name] = function self(args) {\n        var $canvases = this, canvas, e, ctx,\n            params;\n\n        for (e = 0; e < $canvases.length; e += 1) {\n          canvas = $canvases[e];\n          ctx = _getContext(canvas);\n          if (ctx) {\n\n            params = new jCanvasObject(args);\n            _addLayer(canvas, params, args, self);\n\n            _setGlobalProps(canvas, ctx, params);\n            plugin.fn.call(canvas, ctx, params);\n\n          }\n        }\n        return $canvases;\n      };\n      // Add drawing type to drawing map\n      if (plugin.type) {\n        maps.drawings[plugin.type] = plugin.name;\n      }\n    }\n    return $.fn[plugin.name];\n  };\n\n  /* Layer API */\n\n// Retrieved the stored jCanvas data for a canvas element\n  function _getCanvasData(canvas) {\n    var dataCache = caches.dataCache, data;\n    if (dataCache._canvas === canvas && dataCache._data) {\n\n      // Retrieve canvas data from cache if possible\n      data = dataCache._data;\n\n    } else {\n\n      // Retrieve canvas data from jQuery's internal data storage\n      data = $.data(canvas, 'jCanvas');\n      if (!data) {\n\n        // Create canvas data object if it does not already exist\n        data = {\n          // The associated canvas element\n          canvas: canvas,\n          // Layers array\n          layers: [],\n          // Layer maps\n          layer: {\n            names: {},\n            groups: {}\n          },\n          eventHooks: {},\n          // All layers that intersect with the event coordinates (regardless of visibility)\n          intersecting: [],\n          // The topmost layer whose area contains the event coordinates\n          lastIntersected: null,\n          cursor: $(canvas).css('cursor'),\n          // Properties for the current drag event\n          drag: {\n            layer: null,\n            dragging: false\n          },\n          // Data for the current event\n          event: {\n            type: null,\n            x: null,\n            y: null\n          },\n          // Events which already have been bound to the canvas\n          events: {},\n          // The canvas's current transformation state\n          transforms: _cloneTransforms(baseTransforms),\n          savedTransforms: [],\n          // Whether a layer is being animated or not\n          animating: false,\n          // The layer currently being animated\n          animated: null,\n          // The device pixel ratio\n          pixelRatio: 1,\n          // Whether pixel ratio transformations have been applied\n          scaled: false,\n          // Whether the canvas should be redrawn when a layer mousemove\n          // event triggers (either directly, or indirectly via dragging)\n          redrawOnMousemove: false\n        };\n        // Use jQuery to store canvas data\n        $.data(canvas, 'jCanvas', data);\n\n      }\n      // Cache canvas data for faster retrieval\n      dataCache._canvas = canvas;\n      dataCache._data = data;\n\n    }\n    return data;\n  }\n\n// Initialize all of a layer's associated jCanvas events\n  function _addLayerEvents($canvas, data, layer) {\n    var eventName;\n    // Determine which jCanvas events need to be bound to this layer\n    for (eventName in jCanvas.events) {\n      if (Object.prototype.hasOwnProperty.call(jCanvas.events, eventName)) {\n        // If layer has callback function to complement it\n        if (layer[eventName] || (layer.cursors && layer.cursors[eventName])) {\n          // Bind event to layer\n          _addExplicitLayerEvent($canvas, data, layer, eventName);\n        }\n      }\n    }\n    if (!data.events.mouseout) {\n      $canvas.bind('mouseout.jCanvas', function () {\n        // Retrieve the layer whose drag event was canceled\n        var layer = data.drag.layer, l;\n        // If cursor mouses out of canvas while dragging\n        if (layer) {\n          // Cancel drag\n          data.drag = {};\n          _triggerLayerEvent($canvas, data, layer, 'dragcancel');\n        }\n        // Loop through all layers\n        for (l = 0; l < data.layers.length; l += 1) {\n          layer = data.layers[l];\n          // If layer thinks it's still being moused over\n          if (layer._hovered) {\n            // Trigger mouseout on layer\n            $canvas.triggerLayerEvent(data.layers[l], 'mouseout');\n          }\n        }\n        // Redraw layers\n        $canvas.drawLayers();\n      });\n      // Indicate that an event handler has been bound\n      data.events.mouseout = true;\n    }\n  }\n\n// Initialize the given event on the given layer\n  function _addLayerEvent($canvas, data, layer, eventName) {\n    // Use touch events if appropriate\n    // eventName = _getMouseEventName(eventName);\n    // Bind event to layer\n    jCanvas.events[eventName]($canvas, data);\n    layer._event = true;\n  }\n\n// Add a layer event that was explicitly declared in the layer's parameter map,\n// excluding events added implicitly (e.g. mousemove event required by draggable\n// layers)\n  function _addExplicitLayerEvent($canvas, data, layer, eventName) {\n    _addLayerEvent($canvas, data, layer, eventName);\n    if (eventName === 'mouseover' || eventName === 'mouseout' || eventName === 'mousemove') {\n      data.redrawOnMousemove = true;\n    }\n  }\n\n// Enable drag support for this layer\n  function _enableDrag($canvas, data, layer) {\n    var dragHelperEvents, eventName, i;\n    // Only make layer draggable if necessary\n    if (layer.draggable || layer.cursors) {\n\n      // Organize helper events which enable drag support\n      dragHelperEvents = ['mousedown', 'mousemove', 'mouseup'];\n\n      // Bind each helper event to the canvas\n      for (i = 0; i < dragHelperEvents.length; i += 1) {\n        // Use touch events if appropriate\n        eventName = dragHelperEvents[i];\n        // Bind event\n        _addLayerEvent($canvas, data, layer, eventName);\n      }\n      // Indicate that this layer has events bound to it\n      layer._event = true;\n\n    }\n  }\n\n// Update a layer property map if property is changed\n  function _updateLayerName($canvas, data, layer, props) {\n    var nameMap = data.layer.names;\n\n    // If layer name is being added, not changed\n    if (!props) {\n\n      props = layer;\n\n    } else {\n\n      // Remove old layer name entry because layer name has changed\n      if (props.name !== undefined && isString(layer.name) && layer.name !== props.name) {\n        delete nameMap[layer.name];\n      }\n\n    }\n\n    // Add new entry to layer name map with new name\n    if (isString(props.name)) {\n      nameMap[props.name] = layer;\n    }\n  }\n\n// Create or update the data map for the given layer and group type\n  function _updateLayerGroups($canvas, data, layer, props) {\n    var groupMap = data.layer.groups,\n        group, groupName, g,\n        index, l;\n\n    // If group name is not changing\n    if (!props) {\n\n      props = layer;\n\n    } else {\n\n      // Remove layer from all of its associated groups\n      if (props.groups !== undefined && layer.groups !== null) {\n        for (g = 0; g < layer.groups.length; g += 1) {\n          groupName = layer.groups[g];\n          group = groupMap[groupName];\n          if (group) {\n            // Remove layer from its old layer group entry\n            for (l = 0; l < group.length; l += 1) {\n              if (group[l] === layer) {\n                // Keep track of the layer's initial index\n                index = l;\n                // Remove layer once found\n                group.splice(l, 1);\n                break;\n              }\n            }\n            // Remove layer group entry if group is empty\n            if (group.length === 0) {\n              delete groupMap[groupName];\n            }\n          }\n        }\n      }\n\n    }\n\n    // Add layer to new group if a new group name is given\n    if (props.groups !== undefined && props.groups !== null) {\n\n      for (g = 0; g < props.groups.length; g += 1) {\n\n        groupName = props.groups[g];\n\n        group = groupMap[groupName];\n        if (!group) {\n          // Create new group entry if it doesn't exist\n          group = groupMap[groupName] = [];\n          group.name = groupName;\n        }\n        if (index === undefined) {\n          // Add layer to end of group unless otherwise stated\n          index = group.length;\n        }\n        // Add layer to its new layer group\n        group.splice(index, 0, layer);\n\n      }\n\n    }\n  }\n\n// Get event hooks object for the first selected canvas\n  $.fn.getEventHooks = function getEventHooks() {\n    var $canvases = this, canvas, data,\n        eventHooks = {};\n\n    if ($canvases.length !== 0) {\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      eventHooks = data.eventHooks;\n    }\n    return eventHooks;\n  };\n\n// Set event hooks for the selected canvases\n  $.fn.setEventHooks = function setEventHooks(eventHooks) {\n    var $canvases = this, e,\n        data;\n    for (e = 0; e < $canvases.length; e += 1) {\n      data = _getCanvasData($canvases[e]);\n      extendObject(data.eventHooks, eventHooks);\n    }\n    return $canvases;\n  };\n\n// Get jCanvas layers array\n  $.fn.getLayers = function getLayers(callback) {\n    var $canvases = this, canvas, data,\n        layers, layer, l,\n        matching = [];\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      // Retrieve layers array for this canvas\n      layers = data.layers;\n\n      // If a callback function is given\n      if (isFunction(callback)) {\n\n        // Filter the layers array using the callback\n        for (l = 0; l < layers.length; l += 1) {\n          layer = layers[l];\n          if (callback.call(canvas, layer)) {\n            // Add layer to array of matching layers if test passes\n            matching.push(layer);\n          }\n        }\n\n      } else {\n        // Otherwise, get all layers\n\n        matching = layers;\n\n      }\n\n    }\n    return matching;\n  };\n\n// Get a single jCanvas layer object\n  $.fn.getLayer = function getLayer(layerId) {\n    var $canvases = this, canvas,\n        data, layers, layer, l,\n        idType;\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      layers = data.layers;\n      idType = typeOf(layerId);\n\n      if (layerId && layerId.layer) {\n\n        // Return the actual layer object if given\n        layer = layerId;\n\n      } else if (idType === 'number') {\n\n        // Retrieve the layer using the given index\n\n        // Allow for negative indices\n        if (layerId < 0) {\n          layerId = layers.length + layerId;\n        }\n        // Get layer with the given index\n        layer = layers[layerId];\n\n      } else if (idType === 'regexp') {\n\n        // Get layer with the name that matches the given regex\n        for (l = 0; l < layers.length; l += 1) {\n          // Check if layer matches name\n          if (isString(layers[l].name) && layers[l].name.match(layerId)) {\n            layer = layers[l];\n            break;\n          }\n        }\n\n      } else {\n\n        // Get layer with the given name\n        layer = data.layer.names[layerId];\n\n      }\n\n    }\n    return layer;\n  };\n\n// Get all layers in the given group\n  $.fn.getLayerGroup = function getLayerGroup(groupId) {\n    var $canvases = this, canvas, data,\n        groups, groupName, group,\n        idType = typeOf(groupId);\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n\n      if (idType === 'array') {\n\n        // Return layer group if given\n        group = groupId;\n\n      } else if (idType === 'regexp') {\n\n        // Get canvas data\n        data = _getCanvasData(canvas);\n        groups = data.layer.groups;\n        // Loop through all layers groups for this canvas\n        for (groupName in groups) {\n          // Find a group whose name matches the given regex\n          if (groupName.match(groupId)) {\n            group = groups[groupName];\n            // Stop after finding the first matching group\n            break;\n          }\n        }\n\n      } else {\n\n        // Find layer group with the given group name\n        data = _getCanvasData(canvas);\n        group = data.layer.groups[groupId];\n      }\n\n    }\n    return group;\n  };\n\n// Get index of layer in layers array\n  $.fn.getLayerIndex = function getLayerIndex(layerId) {\n    var $canvases = this,\n        layers = $canvases.getLayers(),\n        layer = $canvases.getLayer(layerId);\n\n    return inArray(layer, layers);\n  };\n\n// Set properties of a layer\n  $.fn.setLayer = function setLayer(layerId, props) {\n    var $canvases = this, $canvas, e,\n        data, layer,\n        propName, propValue, propType;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      layer = $($canvases[e]).getLayer(layerId);\n      if (layer) {\n\n        // Update layer property maps\n        _updateLayerName($canvas, data, layer, props);\n        _updateLayerGroups($canvas, data, layer, props);\n\n        _coerceNumericProps(props);\n\n        // Merge properties with layer\n        for (propName in props) {\n          if (Object.prototype.hasOwnProperty.call(props, propName)) {\n            propValue = props[propName];\n            propType = typeOf(propValue);\n            if (propType === 'object' && isPlainObject(propValue)) {\n              // Clone objects\n              layer[propName] = extendObject({}, propValue);\n              _coerceNumericProps(layer[propName]);\n            } else if (propType === 'array') {\n              // Clone arrays\n              layer[propName] = propValue.slice(0);\n            } else if (propType === 'string') {\n              if (propValue.indexOf('+=') === 0) {\n                // Increment numbers prefixed with +=\n                layer[propName] += parseFloat(propValue.substr(2));\n              } else if (propValue.indexOf('-=') === 0) {\n                // Decrement numbers prefixed with -=\n                layer[propName] -= parseFloat(propValue.substr(2));\n              } else if (!isNaN(propValue) && isNumeric(propValue) && propName !== 'text') {\n                // Convert numeric values as strings to numbers\n                layer[propName] = parseFloat(propValue);\n              } else {\n                // Otherwise, set given string value\n                layer[propName] = propValue;\n              }\n            } else {\n              // Otherwise, set given value\n              layer[propName] = propValue;\n            }\n          }\n        }\n\n        // Update layer events\n        _addLayerEvents($canvas, data, layer);\n        _enableDrag($canvas, data, layer);\n\n        // If layer's properties were changed\n        if ($.isEmptyObject(props) === false) {\n          _triggerLayerEvent($canvas, data, layer, 'change', props);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Set properties of all layers (optionally filtered by a callback)\n  $.fn.setLayers = function setLayers(props, callback) {\n    var $canvases = this, $canvas, e,\n        layers, l;\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      layers = $canvas.getLayers(callback);\n      // Loop through all layers\n      for (l = 0; l < layers.length; l += 1) {\n        // Set properties of each layer\n        $canvas.setLayer(layers[l], props);\n      }\n    }\n    return $canvases;\n  };\n\n// Set properties of all layers in the given group\n  $.fn.setLayerGroup = function setLayerGroup(groupId, props) {\n    var $canvases = this, $canvas, e,\n        group, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      // Get layer group\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // If group exists\n      if (group) {\n\n        // Loop through layers in group\n        for (l = 0; l < group.length; l += 1) {\n          // Merge given properties with layer\n          $canvas.setLayer(group[l], props);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Move a layer to the given index in the layers array\n  $.fn.moveLayer = function moveLayer(layerId, index) {\n    var $canvases = this, $canvas, e,\n        data, layers, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      // Retrieve layers array and desired layer\n      layers = data.layers;\n      layer = $canvas.getLayer(layerId);\n      if (layer) {\n\n        // Ensure layer index is accurate\n        layer.index = inArray(layer, layers);\n\n        // Remove layer from its current placement\n        layers.splice(layer.index, 1);\n        // Add layer in its new placement\n        layers.splice(index, 0, layer);\n\n        // Handle negative indices\n        if (index < 0) {\n          index = layers.length + index;\n        }\n        // Update layer's stored index\n        layer.index = index;\n\n        _triggerLayerEvent($canvas, data, layer, 'move');\n\n      }\n    }\n    return $canvases;\n  };\n\n// Remove a jCanvas layer\n  $.fn.removeLayer = function removeLayer(layerId) {\n    var $canvases = this, $canvas, e, data,\n        layers, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      // Retrieve layers array and desired layer\n      layers = $canvas.getLayers();\n      layer = $canvas.getLayer(layerId);\n      // Remove layer if found\n      if (layer) {\n\n        // Ensure layer index is accurate\n        layer.index = inArray(layer, layers);\n        // Remove layer and allow it to be re-added later\n        layers.splice(layer.index, 1);\n        delete layer._layer;\n\n        // Update layer name map\n        _updateLayerName($canvas, data, layer, {\n          name: null\n        });\n        // Update layer group map\n        _updateLayerGroups($canvas, data, layer, {\n          groups: null\n        });\n\n        // Trigger 'remove' event\n        _triggerLayerEvent($canvas, data, layer, 'remove');\n\n      }\n    }\n    return $canvases;\n  };\n\n// Remove all layers\n  $.fn.removeLayers = function removeLayers(callback) {\n    var $canvases = this, $canvas, e,\n        data, layers, layer, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layers = $canvas.getLayers(callback);\n      // Remove all layers individually\n      for (l = 0; l < layers.length; l += 1) {\n        layer = layers[l];\n        $canvas.removeLayer(layer);\n        // Ensure no layer is skipped over\n        l -= 1;\n      }\n      // Update layer maps\n      data.layer.names = {};\n      data.layer.groups = {};\n    }\n    return $canvases;\n  };\n\n// Remove all layers in the group with the given ID\n  $.fn.removeLayerGroup = function removeLayerGroup(groupId) {\n    var $canvases = this, $canvas, e, group, l;\n\n    if (groupId !== undefined) {\n      for (e = 0; e < $canvases.length; e += 1) {\n        $canvas = $($canvases[e]);\n\n        group = $canvas.getLayerGroup(groupId);\n        // Remove layer group using given group name\n        if (group) {\n\n          // Clone groups array\n          group = group.slice(0);\n\n          // Loop through layers in group\n          for (l = 0; l < group.length; l += 1) {\n            $canvas.removeLayer(group[l]);\n          }\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Add an existing layer to a layer group\n  $.fn.addLayerToGroup = function addLayerToGroup(layerId, groupName) {\n    var $canvases = this, $canvas, e,\n        layer, groups = [groupName];\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n\n      // If layer is not already in group\n      if (layer.groups) {\n        // Clone groups list\n        groups = layer.groups.slice(0);\n        // If layer is not already in group\n        if (inArray(groupName, layer.groups) === -1) {\n          // Add layer to group\n          groups.push(groupName);\n        }\n      }\n      // Update layer group maps\n      $canvas.setLayer(layer, {\n        groups: groups\n      });\n\n    }\n    return $canvases;\n  };\n\n// Remove an existing layer from a layer group\n  $.fn.removeLayerFromGroup = function removeLayerFromGroup(layerId, groupName) {\n    var $canvases = this, $canvas, e,\n        layer, groups = [],\n        index;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n\n      if (layer.groups) {\n\n        // Find index of layer in group\n        index = inArray(groupName, layer.groups);\n\n        // If layer is in group\n        if (index !== -1) {\n\n          // Clone groups list\n          groups = layer.groups.slice(0);\n\n          // Remove layer from group\n          groups.splice(index, 1);\n\n          // Update layer group maps\n          $canvas.setLayer(layer, {\n            groups: groups\n          });\n\n        }\n\n      }\n\n    }\n    return $canvases;\n  };\n\n// Get topmost layer that intersects with event coordinates\n  function _getIntersectingLayer(data) {\n    var layer, i,\n        mask, m;\n\n    // Store the topmost layer\n    layer = null;\n\n    // Get the topmost layer whose visible area intersects event coordinates\n    for (i = data.intersecting.length - 1; i >= 0; i -= 1) {\n\n      // Get current layer\n      layer = data.intersecting[i];\n\n      // If layer has previous masks\n      if (layer._masks) {\n\n        // Search previous masks to ensure\n        // layer is visible at event coordinates\n        for (m = layer._masks.length - 1; m >= 0; m -= 1) {\n          mask = layer._masks[m];\n          // If mask does not intersect event coordinates\n          if (!mask.intersects) {\n            // Indicate that the mask does not\n            // intersect event coordinates\n            layer.intersects = false;\n            // Stop searching previous masks\n            break;\n          }\n\n        }\n\n        // If event coordinates intersect all previous masks\n        // and layer is not intangible\n        if (layer.intersects && !layer.intangible) {\n          // Stop searching for topmost layer\n          break;\n        }\n\n      }\n\n    }\n    // If resulting layer is intangible\n    if (layer && layer.intangible) {\n      // Cursor does not intersect this layer\n      layer = null;\n    }\n    return layer;\n  }\n\n// Draw individual layer (internal)\n  function _drawLayer($canvas, ctx, layer, nextLayerIndex) {\n    if (layer && layer.visible && layer._method) {\n      if (nextLayerIndex) {\n        layer._next = nextLayerIndex;\n      } else {\n        layer._next = null;\n      }\n      // If layer is an object, call its respective method\n      if (layer._method) {\n        layer._method.call($canvas, layer);\n      }\n    }\n  }\n\n// Handle dragging of the currently-dragged layer\n  function _handleLayerDrag($canvas, data, eventType) {\n    var layers, layer, l,\n        drag, dragGroups,\n        group, groupName, g,\n        newX, newY;\n\n    drag = data.drag;\n    layer = drag.layer;\n    dragGroups = (layer && layer.dragGroups) || [];\n    layers = data.layers;\n\n    if (eventType === 'mousemove' || eventType === 'touchmove') {\n      // Detect when user is currently dragging layer\n\n      if (!drag.dragging) {\n        // Detect when user starts dragging layer\n\n        // Signify that a layer on the canvas is being dragged\n        drag.dragging = true;\n        layer.dragging = true;\n\n        // Optionally bring layer to front when drag starts\n        if (layer.bringToFront) {\n          // Remove layer from its original position\n          layers.splice(layer.index, 1);\n          // Bring layer to front\n          // push() returns the new array length\n          layer.index = layers.push(layer);\n        }\n\n        // Set drag properties for this layer\n        layer._startX = layer.x;\n        layer._startY = layer.y;\n        layer._endX = layer._eventX;\n        layer._endY = layer._eventY;\n\n        // Trigger dragstart event\n        _triggerLayerEvent($canvas, data, layer, 'dragstart');\n\n      }\n\n      if (drag.dragging) {\n\n        // Calculate position after drag\n        newX = layer._eventX - (layer._endX - layer._startX);\n        newY = layer._eventY - (layer._endY - layer._startY);\n        if (layer.updateDragX) {\n          newX = layer.updateDragX.call($canvas[0], layer, newX);\n        }\n        if (layer.updateDragY) {\n          newY = layer.updateDragY.call($canvas[0], layer, newY);\n        }\n        layer.dx = newX - layer.x;\n        layer.dy = newY - layer.y;\n\n        if (layer.restrictDragToAxis !== 'y') {\n          layer.x = newX;\n        }\n        if (layer.restrictDragToAxis !== 'x') {\n          layer.y = newY;\n        }\n\n        if(layer.circlePath === true){\n          var centerX = layer.circleCenterX;\n          var centerY = layer.circleCenterY;\n          var r = layer.circleRadius;\n          var x1 = layer.x - centerX;\n          var y1 = layer.y - centerY;\n          var k = y1/x1;\n\n          if(x1<0){\n            var tempX = -Math.sqrt(Math.pow(r,2)/(1+Math.pow((k),2)));\n          }else{\n            var tempX = Math.sqrt(Math.pow(r,2)/(1+Math.pow((k),2)));\n          }\n          var tempY = tempX*k;\n\n          var px = layer.xMin;\n          var py = layer.yMin;\n          var qx = layer.xMax;\n          var qy = layer.yMax;\n          var rx = newX;\n          var ry = newY;\n          var Result = (Math.pow(px,2) + Math.pow(py,2)) * (qx * ry - qy * rx) -\n              (Math.pow(qx,2) + Math.pow(qy,2)) * (px * ry - py * rx) +\n              (Math.pow(rx,2) + Math.pow(ry,2)) * (px * qy - py * qx);\n\n          if(Result <= 0){\n            var absSumMin = Math.abs(layer.xMin - newX) + Math.abs(layer.yMin - newY);\n            var absSumMax = Math.abs(layer.xMax - newX) + Math.abs(layer.yMax - newY);\n            if(absSumMin < absSumMax){\n              tempX = layer.xMin - centerX;\n              tempY = layer.yMin - centerY;\n            }else{\n              tempX = layer.xMax - centerX;\n              tempY = layer.yMax - centerY;\n            }\n          }\n\n          var newX = tempX + centerX;\n          var newY = tempY + centerY;\n\n          layer.x = newX;\n          layer.y = newY;\n\n        }\n\n        // Trigger drag event\n        _triggerLayerEvent($canvas, data, layer, 'drag');\n\n        // Move groups with layer on drag\n        for (g = 0; g < dragGroups.length; g += 1) {\n\n          groupName = dragGroups[g];\n          group = data.layer.groups[groupName];\n          if (layer.groups && group) {\n\n            for (l = 0; l < group.length; l += 1) {\n              if (group[l] !== layer) {\n                if (layer.restrictDragToAxis !== 'y' && group[l].restrictDragToAxis !== 'y') {\n                  group[l].x += layer.dx;\n                }\n                if (layer.restrictDragToAxis !== 'x' && group[l].restrictDragToAxis !== 'x') {\n                  group[l].y += layer.dy;\n                }\n              }\n            }\n\n          }\n\n        }\n\n      }\n\n    } else if (eventType === 'mouseup' || eventType === 'touchend') {\n      // Detect when user stops dragging layer\n\n      if (drag.dragging) {\n        layer.dragging = false;\n        drag.dragging = false;\n        data.redrawOnMousemove = data.originalRedrawOnMousemove;\n        // Trigger dragstop event\n        _triggerLayerEvent($canvas, data, layer, 'dragstop');\n      }\n\n      // Cancel dragging\n      data.drag = {};\n\n    }\n  }\n\n\n// List of CSS3 cursors that need to be prefixed\n  css.cursors = ['grab', 'grabbing', 'zoom-in', 'zoom-out'];\n\n// Function to detect vendor prefix\n// Modified version of David Walsh's implementation\n// https://davidwalsh.name/vendor-prefix\n  css.prefix = (function () {\n    var styles = getComputedStyle(document.documentElement, ''),\n        pre = (arraySlice\n                .call(styles)\n                .join('')\n                .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\n        )[1];\n    return '-' + pre + '-';\n  })();\n\n// Set cursor on canvas\n  function _setCursor($canvas, layer, eventType) {\n    var cursor;\n    if (layer.cursors) {\n      // Retrieve cursor from cursors object if it exists\n      cursor = layer.cursors[eventType];\n    }\n    // Prefix any CSS3 cursor\n    if ($.inArray(cursor, css.cursors) !== -1) {\n      cursor = css.prefix + cursor;\n    }\n    // If cursor is defined\n    if (cursor) {\n      // Set canvas cursor\n      $canvas.css({\n        cursor: cursor\n      });\n    }\n  }\n\n// Reset cursor on canvas\n  function _resetCursor($canvas, data) {\n    $canvas.css({\n      cursor: data.cursor\n    });\n  }\n\n// Run the given event callback with the given arguments\n  function _runEventCallback($canvas, layer, eventType, callbacks, arg) {\n    // Prevent callback from firing recursively\n    if (callbacks[eventType] && layer._running && !layer._running[eventType]) {\n      // Signify the start of callback execution for this event\n      layer._running[eventType] = true;\n      // Run event callback with the given arguments\n      callbacks[eventType].call($canvas[0], layer, arg);\n      // Signify the end of callback execution for this event\n      layer._running[eventType] = false;\n    }\n  }\n\n// Determine if the given layer can \"legally\" fire the given event\n  function _layerCanFireEvent(layer, eventType) {\n    // If events are disable and if\n    // layer is tangible or event is not tangible\n    return (!layer.disableEvents &&\n        (!layer.intangible || $.inArray(eventType, tangibleEvents) === -1));\n  }\n\n// Trigger the given event on the given layer\n  function _triggerLayerEvent($canvas, data, layer, eventType, arg) {\n    // If layer can legally fire this event type\n    if (_layerCanFireEvent(layer, eventType)) {\n\n      // Do not set a custom cursor on layer mouseout\n      if (eventType !== 'mouseout') {\n        // Update cursor if one is defined for this event\n        _setCursor($canvas, layer, eventType);\n      }\n\n      // Trigger the user-defined event callback\n      _runEventCallback($canvas, layer, eventType, layer, arg);\n      // Trigger the canvas-bound event hook\n      _runEventCallback($canvas, layer, eventType, data.eventHooks, arg);\n      // Trigger the global event hook\n      _runEventCallback($canvas, layer, eventType, jCanvas.eventHooks, arg);\n\n    }\n  }\n\n// Manually trigger a layer event\n  $.fn.triggerLayerEvent = function (layer, eventType) {\n    var $canvases = this, $canvas, e,\n        data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layer);\n      if (layer) {\n        _triggerLayerEvent($canvas, data, layer, eventType);\n      }\n    }\n    return $canvases;\n  };\n\n// Draw layer with the given ID\n  $.fn.drawLayer = function drawLayer(layerId) {\n    var $canvases = this, e, ctx,\n        $canvas, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n        layer = $canvas.getLayer(layerId);\n        _drawLayer($canvas, ctx, layer);\n      }\n    }\n    return $canvases;\n  };\n\n// Draw all layers (or, if given, only layers starting at an index)\n  $.fn.drawLayers = function drawLayers(args) {\n    var $canvases = this, $canvas, e, ctx,\n        // Internal parameters for redrawing the canvas\n        params = args || {},\n        // Other variables\n        layers, layer, lastLayer, l, index, lastIndex,\n        data, eventCache, eventType, isImageLayer;\n\n    // The layer index from which to start redrawing the canvas\n    index = params.index;\n    if (!index) {\n      index = 0;\n    }\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        // Clear canvas first unless otherwise directed\n        if (params.clear !== false) {\n          $canvas.clearCanvas();\n        }\n\n        // Cache the layers array\n        layers = data.layers;\n\n        // Draw layers from first to last (bottom to top)\n        for (l = index; l < layers.length; l += 1) {\n          layer = layers[l];\n\n          // Ensure layer index is up-to-date\n          layer.index = l;\n\n          // Prevent any one event from firing excessively\n          if (params.resetFire) {\n            layer._fired = false;\n          }\n          // Draw layer\n          _drawLayer($canvas, ctx, layer, l + 1);\n          // Store list of previous masks for each layer\n          layer._masks = data.transforms.masks.slice(0);\n\n          // Allow image layers to load before drawing successive layers\n          if (layer._method === $.fn.drawImage && layer.visible) {\n            isImageLayer = true;\n            break;\n          }\n\n        }\n\n        // If layer is an image layer\n        if (isImageLayer) {\n          // Stop and wait for drawImage() to resume drawLayers()\n          break;\n        }\n\n        // Store the latest\n        lastIndex = l;\n\n        // Get first layer that intersects with event coordinates\n        layer = _getIntersectingLayer(data);\n\n        eventCache = data.event;\n        eventType = eventCache.type;\n\n        // If jCanvas has detected a dragstart\n        if (data.drag.layer) {\n          // Handle dragging of layer\n          _handleLayerDrag($canvas, data, eventType);\n        }\n\n        // Manage mouseout event\n        lastLayer = data.lastIntersected;\n        if (lastLayer !== null && layer !== lastLayer && lastLayer._hovered && !lastLayer._fired && !data.drag.dragging) {\n\n          data.lastIntersected = null;\n          lastLayer._fired = true;\n          lastLayer._hovered = false;\n          _triggerLayerEvent($canvas, data, lastLayer, 'mouseout');\n          _resetCursor($canvas, data);\n\n        }\n\n        if (layer) {\n\n          // Use mouse event callbacks if no touch event callbacks are given\n          if (!layer[eventType]) {\n            eventType = _getMouseEventName(eventType);\n          }\n\n          // Check events for intersecting layer\n          if (layer._event && layer.intersects) {\n\n            data.lastIntersected = layer;\n\n            // Detect mouseover events\n            if ((layer.mouseover || layer.mouseout || layer.cursors) && !data.drag.dragging) {\n\n              if (!layer._hovered && !layer._fired) {\n\n                // Prevent events from firing excessively\n                layer._fired = true;\n                layer._hovered = true;\n                _triggerLayerEvent($canvas, data, layer, 'mouseover');\n\n              }\n\n            }\n\n            // Detect any other mouse event\n            if (!layer._fired) {\n\n              // Prevent event from firing twice unintentionally\n              layer._fired = true;\n              eventCache.type = null;\n\n              _triggerLayerEvent($canvas, data, layer, eventType);\n\n            }\n\n            // Use the mousedown event to start drag\n            if (layer.draggable && !layer.disableEvents && (eventType === 'mousedown' || eventType === 'touchstart')) {\n\n              // Keep track of drag state\n              data.drag.layer = layer;\n              data.originalRedrawOnMousemove = data.redrawOnMousemove;\n              data.redrawOnMousemove = true;\n\n            }\n\n          }\n\n        }\n\n        // If cursor is not intersecting with any layer\n        if (layer === null && !data.drag.dragging) {\n          // Reset cursor to previous state\n          _resetCursor($canvas, data);\n        }\n\n        // If the last layer has been drawn\n        if (lastIndex === layers.length) {\n\n          // Reset list of intersecting layers\n          data.intersecting.length = 0;\n          // Reset transformation stack\n          data.transforms = _cloneTransforms(baseTransforms);\n          data.savedTransforms.length = 0;\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Add a jCanvas layer (internal)\n  function _addLayer(canvas, params, args, method) {\n    var $canvas, data,\n        layers, layer = (params._layer ? args : params);\n\n    // Store arguments object for later use\n    params._args = args;\n\n    // Convert all draggable drawings into jCanvas layers\n    if (params.draggable || params.dragGroups) {\n      params.layer = true;\n      params.draggable = true;\n    }\n\n    // Determine the layer's type using the available information\n    if (!params._method) {\n      if (method) {\n        params._method = method;\n      } else if (params.method) {\n        params._method = $.fn[params.method];\n      } else if (params.type) {\n        params._method = $.fn[maps.drawings[params.type]];\n      }\n    }\n\n    // If layer hasn't been added yet\n    if (params.layer && !params._layer) {\n      // Add layer to canvas\n\n      $canvas = $(canvas);\n\n      data = _getCanvasData(canvas);\n      layers = data.layers;\n\n      // Do not add duplicate layers of same name\n      if (layer.name === null || (isString(layer.name) && data.layer.names[layer.name] === undefined)) {\n\n        // Convert number properties to numbers\n        _coerceNumericProps(params);\n\n        // Ensure layers are unique across canvases by cloning them\n        layer = new jCanvasObject(params);\n        layer.canvas = canvas;\n        // Indicate that this is a layer for future checks\n        layer.layer = true;\n        layer._layer = true;\n        layer._running = {};\n        // If layer stores user-defined data\n        if (layer.data !== null) {\n          // Clone object\n          layer.data = extendObject({}, layer.data);\n        } else {\n          // Otherwise, create data object\n          layer.data = {};\n        }\n        // If layer stores a list of associated groups\n        if (layer.groups !== null) {\n          // Clone list\n          layer.groups = layer.groups.slice(0);\n        } else {\n          // Otherwise, create empty list\n          layer.groups = [];\n        }\n\n        // Update layer group maps\n        _updateLayerName($canvas, data, layer);\n        _updateLayerGroups($canvas, data, layer);\n\n        // Check for any associated jCanvas events and enable them\n        _addLayerEvents($canvas, data, layer);\n\n        // Optionally enable drag-and-drop support and cursor support\n        _enableDrag($canvas, data, layer);\n\n        // Copy _event property to parameters object\n        params._event = layer._event;\n\n        // Calculate width/height for text layers\n        if (layer._method === $.fn.drawText) {\n          $canvas.measureText(layer);\n        }\n\n        // Add layer to end of array if no index is specified\n        if (layer.index === null) {\n          layer.index = layers.length;\n        }\n\n        // Add layer to layers array at specified index\n        layers.splice(layer.index, 0, layer);\n\n        // Store layer on parameters object\n        params._args = layer;\n\n        // Trigger an 'add' event\n        _triggerLayerEvent($canvas, data, layer, 'add');\n\n      }\n\n    } else if (!params.layer) {\n      _coerceNumericProps(params);\n    }\n\n    return layer;\n  }\n\n// Add a jCanvas layer\n  $.fn.addLayer = function addLayer(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        params.layer = true;\n        _addLayer($canvases[e], params, args);\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Animation API */\n\n// Define properties used in both CSS and jCanvas\n  css.props = [\n    'width',\n    'height',\n    'opacity',\n    'lineHeight'\n  ];\n  css.propsObj = {};\n\n// Hide/show jCanvas/CSS properties so they can be animated using jQuery\n  function _showProps(obj) {\n    var cssProp, p;\n    for (p = 0; p < css.props.length; p += 1) {\n      cssProp = css.props[p];\n      obj[cssProp] = obj['_' + cssProp];\n    }\n  }\n  function _hideProps(obj, reset) {\n    var cssProp, p;\n    for (p = 0; p < css.props.length; p += 1) {\n      cssProp = css.props[p];\n      // Hide property using same name with leading underscore\n      if (obj[cssProp] !== undefined) {\n        obj['_' + cssProp] = obj[cssProp];\n        css.propsObj[cssProp] = true;\n        if (reset) {\n          delete obj[cssProp];\n        }\n      }\n    }\n  }\n\n// Evaluate property values that are functions\n  function _parseEndValues(canvas, layer, endValues) {\n    var propName, propValue,\n        subPropName, subPropValue;\n    // Loop through all properties in map of end values\n    for (propName in endValues) {\n      if (Object.prototype.hasOwnProperty.call(endValues, propName)) {\n        propValue = endValues[propName];\n        // If end value is function\n        if (isFunction(propValue)) {\n          // Call function and use its value as the end value\n          endValues[propName] = propValue.call(canvas, layer, propName);\n        }\n        // If end value is an object\n        if (typeOf(propValue) === 'object' && isPlainObject(propValue)) {\n          // Prepare to animate properties in object\n          for (subPropName in propValue) {\n            if (Object.prototype.hasOwnProperty.call(propValue, subPropName)) {\n              subPropValue = propValue[subPropName];\n              // Store property's start value at top-level of layer\n              if (layer[propName] !== undefined) {\n                layer[propName + '.' + subPropName] = layer[propName][subPropName];\n                // Store property's end value at top-level of end values map\n                endValues[propName + '.' + subPropName] = subPropValue;\n              }\n            }\n          }\n          // Delete sub-property of object as it's no longer needed\n          delete endValues[propName];\n        }\n      }\n    }\n    return endValues;\n  }\n\n// Remove sub-property aliases from layer object\n  function _removeSubPropAliases(layer) {\n    var propName;\n    for (propName in layer) {\n      if (Object.prototype.hasOwnProperty.call(layer, propName)) {\n        if (propName.indexOf('.') !== -1) {\n          delete layer[propName];\n        }\n      }\n    }\n  }\n\n// Convert a color value to an array of RGB values\n  function _colorToRgbArray(color) {\n    var originalColor, elem,\n        rgb = [],\n        multiple = 1;\n\n    // Deal with complete transparency\n    if (color === 'transparent') {\n      color = 'rgba(0, 0, 0, 0)';\n    } else if (color.match(/^([a-z]+|#[0-9a-f]+)$/gi)) {\n      // Deal with hexadecimal colors and color names\n      elem = document.head;\n      originalColor = elem.style.color;\n      elem.style.color = color;\n      color = $.css(elem, 'color');\n      elem.style.color = originalColor;\n    }\n    // Parse RGB string\n    if (color.match(/^rgb/gi)) {\n      rgb = color.match(/(\\d+(\\.\\d+)?)/gi);\n      // Deal with RGB percentages\n      if (color.match(/%/gi)) {\n        multiple = 2.55;\n      }\n      rgb[0] *= multiple;\n      rgb[1] *= multiple;\n      rgb[2] *= multiple;\n      // Ad alpha channel if given\n      if (rgb[3] !== undefined) {\n        rgb[3] = parseFloat(rgb[3]);\n      } else {\n        rgb[3] = 1;\n      }\n    }\n    return rgb;\n  }\n\n// Animate a hex or RGB color\n  function _animateColor(fx) {\n    var n = 3,\n        i;\n    // Only parse start and end colors once\n    if (typeOf(fx.start) !== 'array') {\n      fx.start = _colorToRgbArray(fx.start);\n      fx.end = _colorToRgbArray(fx.end);\n    }\n    fx.now = [];\n\n    // If colors are RGBA, animate transparency\n    if (fx.start[3] !== 1 || fx.end[3] !== 1) {\n      n = 4;\n    }\n\n    // Calculate current frame for red, green, blue, and alpha\n    for (i = 0; i < n; i += 1) {\n      fx.now[i] = fx.start[i] + ((fx.end[i] - fx.start[i]) * fx.pos);\n      // Only the red, green, and blue values must be integers\n      if (i < 3) {\n        fx.now[i] = round(fx.now[i]);\n      }\n    }\n    if (fx.start[3] !== 1 || fx.end[3] !== 1) {\n      // Only use RGBA if RGBA colors are given\n      fx.now = 'rgba(' + fx.now.join(',') + ')';\n    } else {\n      // Otherwise, animate as solid colors\n      fx.now.slice(0, 3);\n      fx.now = 'rgb(' + fx.now.join(',') + ')';\n    }\n    // Animate colors for both canvas layers and DOM elements\n    if (fx.elem.nodeName) {\n      fx.elem.style[fx.prop] = fx.now;\n    } else {\n      fx.elem[fx.prop] = fx.now;\n    }\n  }\n\n// Animate jCanvas layer\n  $.fn.animateLayer = function animateLayer() {\n    var $canvases = this, $canvas, e, ctx,\n        args = arraySlice.call(arguments, 0),\n        data, layer, props;\n\n    // Deal with all cases of argument placement\n    /*\n\t\t0. layer name/index\n\t\t1. properties\n\t\t2. duration/options\n\t\t3. easing\n\t\t4. complete function\n\t\t5. step function\n\t*/\n\n    if (typeOf(args[2]) === 'object') {\n\n      // Accept an options object for animation\n      args.splice(2, 0, args[2].duration || null);\n      args.splice(3, 0, args[3].easing || null);\n      args.splice(4, 0, args[4].complete || null);\n      args.splice(5, 0, args[5].step || null);\n\n    } else {\n\n      if (args[2] === undefined) {\n        // If object is the last argument\n        args.splice(2, 0, null);\n        args.splice(3, 0, null);\n        args.splice(4, 0, null);\n      } else if (isFunction(args[2])) {\n        // If callback comes after object\n        args.splice(2, 0, null);\n        args.splice(3, 0, null);\n      }\n      if (args[3] === undefined) {\n        // If duration is the last argument\n        args[3] = null;\n        args.splice(4, 0, null);\n      } else if (isFunction(args[3])) {\n        // If callback comes after duration\n        args.splice(3, 0, null);\n      }\n\n    }\n\n    // Run callback function when animation completes\n    function complete($canvas, data, layer) {\n\n      return function () {\n\n        _showProps(layer);\n        _removeSubPropAliases(layer);\n\n        // Prevent multiple redraw loops\n        if (!data.animating || data.animated === layer) {\n          // Redraw layers on last frame\n          $canvas.drawLayers();\n        }\n\n        // Signify the end of an animation loop\n        layer._animating = false;\n        data.animating = false;\n        data.animated = null;\n\n        // If callback is defined\n        if (args[4]) {\n          // Run callback at the end of the animation\n          args[4].call($canvas[0], layer);\n        }\n\n        _triggerLayerEvent($canvas, data, layer, 'animateend');\n\n      };\n\n    }\n\n    // Redraw layers on every frame of the animation\n    function step($canvas, data, layer) {\n\n      return function (now, fx) {\n        var parts, propName, subPropName,\n            hidden = false;\n\n        // If animated property has been hidden\n        if (fx.prop[0] === '_') {\n          hidden = true;\n          // Unhide property temporarily\n          fx.prop = fx.prop.replace('_', '');\n          layer[fx.prop] = layer['_' + fx.prop];\n        }\n\n        // If animating property of sub-object\n        if (fx.prop.indexOf('.') !== -1) {\n          parts = fx.prop.split('.');\n          propName = parts[0];\n          subPropName = parts[1];\n          if (layer[propName]) {\n            layer[propName][subPropName] = fx.now;\n          }\n        }\n\n        // Throttle animation to improve efficiency\n        if (layer._pos !== fx.pos) {\n\n          layer._pos = fx.pos;\n\n          // Signify the start of an animation loop\n          if (!layer._animating && !data.animating) {\n            layer._animating = true;\n            data.animating = true;\n            data.animated = layer;\n          }\n\n          // Prevent multiple redraw loops\n          if (!data.animating || data.animated === layer) {\n            // Redraw layers for every frame\n            $canvas.drawLayers();\n          }\n\n        }\n\n        // If callback is defined\n        if (args[5]) {\n          // Run callback for each step of animation\n          args[5].call($canvas[0], now, fx, layer);\n        }\n\n        _triggerLayerEvent($canvas, data, layer, 'animate', fx);\n\n        // If property should be hidden during animation\n        if (hidden) {\n          // Hide property again\n          fx.prop = '_' + fx.prop;\n        }\n\n      };\n\n    }\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        // If a layer object was passed, use it the layer to be animated\n        layer = $canvas.getLayer(args[0]);\n\n        // Ignore layers that are functions\n        if (layer && layer._method !== $.fn.draw) {\n\n          // Do not modify original object\n          props = extendObject({}, args[1]);\n\n          props = _parseEndValues($canvases[e], layer, props);\n\n          // Bypass jQuery CSS Hooks for CSS properties (width, opacity, etc.)\n          _hideProps(props, true);\n          _hideProps(layer);\n\n          // Fix for jQuery's vendor prefixing support, which affects how width/height/opacity are animated\n          layer.style = css.propsObj;\n\n          // Animate layer\n          $(layer).animate(props, {\n            duration: args[2],\n            easing: ($.easing[args[3]] ? args[3] : null),\n            // When animation completes\n            complete: complete($canvas, data, layer),\n            // Redraw canvas for every animation frame\n            step: step($canvas, data, layer)\n          });\n          _triggerLayerEvent($canvas, data, layer, 'animatestart');\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Animate all layers in a layer group\n  $.fn.animateLayerGroup = function animateLayerGroup(groupId) {\n    var $canvases = this, $canvas, e,\n        args = arraySlice.call(arguments, 0),\n        group, l;\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      group = $canvas.getLayerGroup(groupId);\n      if (group) {\n\n        // Animate all layers in the group\n        for (l = 0; l < group.length; l += 1) {\n\n          // Replace first argument with layer\n          args[0] = group[l];\n          $canvas.animateLayer.apply($canvas, args);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Delay layer animation by a given number of milliseconds\n  $.fn.delayLayer = function delayLayer(layerId, duration) {\n    var $canvases = this, $canvas, e,\n        data, layer;\n    duration = duration || 0;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n      // If layer exists\n      if (layer) {\n        // Delay animation\n        $(layer).delay(duration);\n        _triggerLayerEvent($canvas, data, layer, 'delay');\n      }\n    }\n    return $canvases;\n  };\n\n// Delay animation all layers in a layer group\n  $.fn.delayLayerGroup = function delayLayerGroup(groupId, duration) {\n    var $canvases = this, $canvas, e,\n        group, layer, l;\n    duration = duration || 0;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // Delay all layers in the group\n      if (group) {\n\n        for (l = 0; l < group.length; l += 1) {\n          // Delay each layer in the group\n          layer = group[l];\n          $canvas.delayLayer(layer, duration);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Stop layer animation\n  $.fn.stopLayer = function stopLayer(layerId, clearQueue) {\n    var $canvases = this, $canvas, e,\n        data, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n      // If layer exists\n      if (layer) {\n        // Stop animation\n        $(layer).stop(clearQueue);\n        _triggerLayerEvent($canvas, data, layer, 'stop');\n      }\n    }\n    return $canvases;\n  };\n\n// Stop animation of all layers in a layer group\n  $.fn.stopLayerGroup = function stopLayerGroup(groupId, clearQueue) {\n    var $canvases = this, $canvas, e,\n        group, layer, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // Stop all layers in the group\n      if (group) {\n\n        for (l = 0; l < group.length; l += 1) {\n          // Stop each layer in the group\n          layer = group[l];\n          $canvas.stopLayer(layer, clearQueue);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Enable animation for color properties\n  function _supportColorProps(props) {\n    var p;\n    for (p = 0; p < props.length; p += 1) {\n      $.fx.step[props[p]] = _animateColor;\n    }\n  }\n\n// Enable animation for color properties\n  _supportColorProps([\n    'color',\n    'backgroundColor',\n    'borderColor',\n    'borderTopColor',\n    'borderRightColor',\n    'borderBottomColor',\n    'borderLeftColor',\n    'fillStyle',\n    'outlineColor',\n    'strokeStyle',\n    'shadowColor'\n  ]);\n\n  /* Event API */\n\n// Map standard mouse events to touch events\n  maps.touchEvents = {\n    'mousedown': 'touchstart',\n    'mouseup': 'touchend',\n    'mousemove': 'touchmove'\n  };\n// Map standard touch events to mouse events\n  maps.mouseEvents = {\n    'touchstart': 'mousedown',\n    'touchend': 'mouseup',\n    'touchmove': 'mousemove'\n  };\n\n// Convert mouse event name to a corresponding touch event name (if possible)\n  function _getTouchEventName(eventName) {\n    // Detect touch event support\n    if (maps.touchEvents[eventName]) {\n      eventName = maps.touchEvents[eventName];\n    }\n    return eventName;\n  }\n// Convert touch event name to a corresponding mouse event name\n  function _getMouseEventName(eventName) {\n    if (maps.mouseEvents[eventName]) {\n      eventName = maps.mouseEvents[eventName];\n    }\n    return eventName;\n  }\n\n// Bind event to jCanvas layer using standard jQuery events\n  function _createEvent(eventName) {\n\n    jCanvas.events[eventName] = function ($canvas, data) {\n      var helperEventName, touchEventName, eventCache;\n\n      // Retrieve canvas's event cache\n      eventCache = data.event;\n\n      // Both mouseover/mouseout events will be managed by a single mousemove event\n      helperEventName = (eventName === 'mouseover' || eventName === 'mouseout') ? 'mousemove' : eventName;\n      touchEventName = _getTouchEventName(helperEventName);\n\n      function eventCallback(event) {\n        // Cache current mouse position and redraw layers\n        eventCache.x = event.offsetX;\n        eventCache.y = event.offsetY;\n        eventCache.type = helperEventName;\n        eventCache.event = event;\n        // Redraw layers on every trigger of the event; don't redraw if at\n        // least one layer is draggable and there are no layers with\n        // explicit mouseover/mouseout/mousemove events\n        if (event.type !== 'mousemove' || data.redrawOnMousemove || data.drag.dragging) {\n          $canvas.drawLayers({\n            resetFire: true\n          });\n        }\n        // Prevent default event behavior\n        event.preventDefault();\n      }\n\n      // Ensure the event is not bound more than once\n      if (!data.events[helperEventName]) {\n        // Bind one canvas event which handles all layer events of that type\n        if (touchEventName !== helperEventName) {\n          $canvas.bind(helperEventName + '.jCanvas ' + touchEventName + '.jCanvas', eventCallback);\n        } else {\n          $canvas.bind(helperEventName + '.jCanvas', eventCallback);\n        }\n        // Prevent this event from being bound twice\n        data.events[helperEventName] = true;\n      }\n    };\n  }\n  function _createEvents(eventNames) {\n    var n;\n    for (n = 0; n < eventNames.length; n += 1) {\n      _createEvent(eventNames[n]);\n    }\n  }\n// Populate jCanvas events object with some standard events\n  _createEvents([\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseup',\n    'mousemove',\n    'mouseover',\n    'mouseout',\n    'touchstart',\n    'touchmove',\n    'touchend',\n    'pointerdown',\n    'pointermove',\n    'pointerup',\n    'contextmenu'\n  ]);\n\n// Check if event fires when a drawing is drawn\n  function _detectEvents(canvas, ctx, params) {\n    var layer, data, eventCache, intersects,\n        transforms, x, y, angle;\n\n    // Use the layer object stored by the given parameters object\n    layer = params._args;\n    // Canvas must have event bindings\n    if (layer) {\n\n      data = _getCanvasData(canvas);\n      eventCache = data.event;\n      if (eventCache.x !== null && eventCache.y !== null) {\n        // Respect user-defined pixel ratio\n        x = eventCache.x * data.pixelRatio;\n        y = eventCache.y * data.pixelRatio;\n        // Determine if the given coordinates are in the current path\n        intersects = ctx.isPointInPath(x, y) || (ctx.isPointInStroke && ctx.isPointInStroke(x, y));\n      }\n      transforms = data.transforms;\n\n      // Allow callback functions to retrieve the mouse coordinates\n      layer.eventX = eventCache.x;\n      layer.eventY = eventCache.y;\n      layer.event = eventCache.event;\n\n      // Adjust coordinates to match current canvas transformation\n\n      // Keep track of some transformation values\n      angle = data.transforms.rotate;\n      x = layer.eventX;\n      y = layer.eventY;\n\n      if (angle !== 0) {\n        // Rotate coordinates if coordinate space has been rotated\n        layer._eventX = (x * cos(-angle)) - (y * sin(-angle));\n        layer._eventY = (y * cos(-angle)) + (x * sin(-angle));\n      } else {\n        // Otherwise, no calculations need to be made\n        layer._eventX = x;\n        layer._eventY = y;\n      }\n\n      // Scale coordinates\n      layer._eventX /= transforms.scaleX;\n      layer._eventY /= transforms.scaleY;\n\n      // If layer intersects with cursor\n      if (intersects) {\n        // Add it to a list of layers that intersect with cursor\n        data.intersecting.push(layer);\n      }\n      layer.intersects = Boolean(intersects);\n    }\n  }\n\n// Normalize offsetX and offsetY for all browsers\n  $.event.fix = function (event) {\n    var offset, originalEvent, touches;\n\n    event = jQueryEventFix.call($.event, event);\n    originalEvent = event.originalEvent;\n\n    // originalEvent does not exist for manually-triggered events\n    if (originalEvent) {\n\n      touches = originalEvent.changedTouches;\n\n      // If offsetX and offsetY are not supported, define them\n      if (event.pageX !== undefined && event.offsetX === undefined) {\n        try {\n          offset = $(event.currentTarget).offset();\n          if (offset) {\n            event.offsetX = event.pageX - offset.left;\n            event.offsetY = event.pageY - offset.top;\n          }\n        } catch (error) {\n          // Fail silently\n        }\n      } else if (touches) {\n        try {\n          // Enable offsetX and offsetY for mobile devices\n          offset = $(event.currentTarget).offset();\n          if (offset) {\n            event.offsetX = touches[0].pageX - offset.left;\n            event.offsetY = touches[0].pageY - offset.top;\n          }\n        } catch (error) {\n          // Fail silently\n        }\n      }\n\n    }\n    return event;\n  };\n\n  /* Drawing API */\n\n// Map drawing names with their respective method names\n  maps.drawings = {\n    'arc': 'drawArc',\n    'bezier': 'drawBezier',\n    'ellipse': 'drawEllipse',\n    'function': 'draw',\n    'image': 'drawImage',\n    'line': 'drawLine',\n    'path': 'drawPath',\n    'polygon': 'drawPolygon',\n    'slice': 'drawSlice',\n    'quadratic': 'drawQuadratic',\n    'rectangle': 'drawRect',\n    'text': 'drawText',\n    'vector': 'drawVector',\n    'save': 'saveCanvas',\n    'restore': 'restoreCanvas',\n    'rotate': 'rotateCanvas',\n    'scale': 'scaleCanvas',\n    'translate': 'translateCanvas'\n  };\n\n// Draws on canvas using a function\n  $.fn.draw = function draw(args) {\n    var $canvases = this, e, ctx,\n        params = new jCanvasObject(args);\n\n    // Draw using any other method\n    if (maps.drawings[params.type] && params.type !== 'function') {\n\n      $canvases[maps.drawings[params.type]](args);\n\n    } else {\n\n      for (e = 0; e < $canvases.length; e += 1) {\n        ctx = _getContext($canvases[e]);\n        if (ctx) {\n\n          params = new jCanvasObject(args);\n          _addLayer($canvases[e], params, args, draw);\n          if (params.visible) {\n\n            if (params.fn) {\n              // Call the given user-defined function\n              params.fn.call($canvases[e], ctx, params);\n            }\n\n          }\n\n        }\n      }\n\n    }\n    return $canvases;\n  };\n\n// Clears canvas\n  $.fn.clearCanvas = function clearCanvas(args) {\n    var $canvases = this, e, ctx,\n        params = new jCanvasObject(args);\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        if (params.width === null || params.height === null) {\n          // Clear entire canvas if width/height is not given\n\n          // Reset current transformation temporarily to ensure that the entire canvas is cleared\n          ctx.save();\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.clearRect(0, 0, $canvases[e].width, $canvases[e].height);\n          ctx.restore();\n\n        } else {\n          // Otherwise, clear the defined section of the canvas\n\n          // Transform clear rectangle\n          _addLayer($canvases[e], params, args, clearCanvas);\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          ctx.clearRect(params.x - (params.width / 2), params.y - (params.height / 2), params.width, params.height);\n          // Restore previous transformation\n          _restoreTransform(ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Transformation API */\n\n// Restores canvas\n  $.fn.saveCanvas = function saveCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, saveCanvas);\n\n        // Restore a number of times using the given count\n        for (i = 0; i < params.count; i += 1) {\n          _saveCanvas(ctx, data);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Restores canvas\n  $.fn.restoreCanvas = function restoreCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, restoreCanvas);\n\n        // Restore a number of times using the given count\n        for (i = 0; i < params.count; i += 1) {\n          _restoreCanvas(ctx, data);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Rotates canvas (internal)\n  function _rotateCanvas(ctx, params, transforms) {\n\n    // Get conversion factor for radians\n    params._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n    // Rotate canvas using shape as center of rotation\n    ctx.translate(params.x, params.y);\n    ctx.rotate(params.rotate * params._toRad);\n    ctx.translate(-params.x, -params.y);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.rotate += (params.rotate * params._toRad);\n    }\n  }\n\n// Scales canvas (internal)\n  function _scaleCanvas(ctx, params, transforms) {\n\n    // Scale both the x- and y- axis using the 'scale' property\n    if (params.scale !== 1) {\n      params.scaleX = params.scaleY = params.scale;\n    }\n\n    // Scale canvas using shape as center of rotation\n    ctx.translate(params.x, params.y);\n    ctx.scale(params.scaleX, params.scaleY);\n    ctx.translate(-params.x, -params.y);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.scaleX *= params.scaleX;\n      transforms.scaleY *= params.scaleY;\n    }\n  }\n\n// Translates canvas (internal)\n  function _translateCanvas(ctx, params, transforms) {\n\n    // Translate both the x- and y-axis using the 'translate' property\n    if (params.translate) {\n      params.translateX = params.translateY = params.translate;\n    }\n\n    // Translate canvas\n    ctx.translate(params.translateX, params.translateY);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.translateX += params.translateX;\n      transforms.translateY += params.translateY;\n    }\n  }\n\n// Rotates canvas\n  $.fn.rotateCanvas = function rotateCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, rotateCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _rotateCanvas(ctx, params, data.transforms);\n      }\n\n    }\n    return $canvases;\n  };\n\n// Scales canvas\n  $.fn.scaleCanvas = function scaleCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, scaleCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _scaleCanvas(ctx, params, data.transforms);\n\n      }\n    }\n    return $canvases;\n  };\n\n// Translates canvas\n  $.fn.translateCanvas = function translateCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, translateCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _translateCanvas(ctx, params, data.transforms);\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Shape API */\n\n// Draws rectangle\n  $.fn.drawRect = function drawRect(args) {\n    var $canvases = this, e, ctx,\n        params,\n        x1, y1,\n        x2, y2,\n        r, temp;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawRect);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          if (params.width && params.height) {\n            x1 = params.x - (params.width / 2);\n            y1 = params.y - (params.height / 2);\n            r = abs(params.cornerRadius);\n            // If corner radius is defined and is not zero\n            if (r) {\n              // Draw rectangle with rounded corners if cornerRadius is defined\n\n              x2 = params.x + (params.width / 2);\n              y2 = params.y + (params.height / 2);\n\n              // Handle negative width\n              if (params.width < 0) {\n                temp = x1;\n                x1 = x2;\n                x2 = temp;\n              }\n              // Handle negative height\n              if (params.height < 0) {\n                temp = y1;\n                y1 = y2;\n                y2 = temp;\n              }\n\n              // Prevent over-rounded corners\n              if ((x2 - x1) - (2 * r) < 0) {\n                r = (x2 - x1) / 2;\n              }\n              if ((y2 - y1) - (2 * r) < 0) {\n                r = (y2 - y1) / 2;\n              }\n\n              // Draw rectangle\n              ctx.moveTo(x1 + r, y1);\n              ctx.lineTo(x2 - r, y1);\n              ctx.arc(x2 - r, y1 + r, r, 3 * PI / 2, PI * 2, false);\n              ctx.lineTo(x2, y2 - r);\n              ctx.arc(x2 - r, y2 - r, r, 0, PI / 2, false);\n              ctx.lineTo(x1 + r, y2);\n              ctx.arc(x1 + r, y2 - r, r, PI / 2, PI, false);\n              ctx.lineTo(x1, y1 + r);\n              ctx.arc(x1 + r, y1 + r, r, PI, 3 * PI / 2, false);\n              // Always close path\n              params.closed = true;\n\n            } else {\n\n              // Otherwise, draw rectangle with square corners\n              ctx.rect(x1, y1, params.width, params.height);\n\n            }\n          }\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Close rectangle path\n          _closePath($canvases[e], ctx, params);\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves a coterminal angle between 0 and 2pi for the given angle\n  function _getCoterminal(angle) {\n    while (angle < 0) {\n      angle += (2 * PI);\n    }\n    return angle;\n  }\n\n// Retrieves the x-coordinate for the given angle in a circle\n  function _getArcX(params, angle) {\n    return params.x + (params.radius * cos(angle));\n  }\n// Retrieves the y-coordinate for the given angle in a circle\n  function _getArcY(params, angle) {\n    return params.y + (params.radius * sin(angle));\n  }\n\n// Draws arc (internal)\n  function _drawArc(canvas, ctx, params, path) {\n    var x1, y1, x2, y2,\n        x3, y3, x4, y4,\n        offsetX, offsetY,\n        diff;\n\n    // Determine offset from dragging\n    if (params === path) {\n      offsetX = 0;\n      offsetY = 0;\n    } else {\n      offsetX = params.x;\n      offsetY = params.y;\n    }\n\n    // Convert default end angle to radians\n    if (!path.inDegrees && path.end === 360) {\n      path.end = PI * 2;\n    }\n\n    // Convert angles to radians\n    path.start *= params._toRad;\n    path.end *= params._toRad;\n    // Consider 0deg due north of arc\n    path.start -= (PI / 2);\n    path.end -= (PI / 2);\n\n    // Ensure arrows are pointed correctly for CCW arcs\n    diff = PI / 180;\n    if (path.ccw) {\n      diff *= -1;\n    }\n\n    // Calculate coordinates for start arrow\n    x1 = _getArcX(path, path.start + diff);\n    y1 = _getArcY(path, path.start + diff);\n    x2 = _getArcX(path, path.start);\n    y2 = _getArcY(path, path.start);\n\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        x1, y1,\n        x2, y2\n    );\n\n    // Draw arc\n    ctx.arc(path.x + offsetX, path.y + offsetY, path.radius, path.start, path.end, path.ccw);\n\n    // Calculate coordinates for end arrow\n    x3 = _getArcX(path, path.end + diff);\n    y3 = _getArcY(path, path.end + diff);\n    x4 = _getArcX(path, path.end);\n    y4 = _getArcY(path, path.end);\n\n    _addEndArrow(\n        canvas, ctx,\n        params, path,\n        x4, y4,\n        x3, y3\n    );\n  }\n\n// Draws arc or circle\n  $.fn.drawArc = function drawArc(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawArc);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          _drawArc($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Draws ellipse\n  $.fn.drawEllipse = function drawEllipse(args) {\n    var $canvases = this, e, ctx,\n        params,\n        controlW,\n        controlH;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawEllipse);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Calculate control width and height\n          controlW = params.width * (4 / 3);\n          controlH = params.height;\n\n          // Create ellipse using curves\n          ctx.beginPath();\n          ctx.moveTo(params.x, params.y - (controlH / 2));\n          // Left side\n          ctx.bezierCurveTo(params.x - (controlW / 2), params.y - (controlH / 2), params.x - (controlW / 2), params.y + (controlH / 2), params.x, params.y + (controlH / 2));\n          // Right side\n          ctx.bezierCurveTo(params.x + (controlW / 2), params.y + (controlH / 2), params.x + (controlW / 2), params.y - (controlH / 2), params.x, params.y - (controlH / 2));\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws a regular (equal-angled) polygon\n  $.fn.drawPolygon = function drawPolygon(args) {\n    var $canvases = this, e, ctx,\n        params,\n        theta, dtheta, hdtheta,\n        apothem,\n        x, y, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawPolygon);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Polygon's central angle\n          dtheta = (2 * PI) / params.sides;\n          // Half of dtheta\n          hdtheta = dtheta / 2;\n          // Polygon's starting angle\n          theta = hdtheta + (PI / 2);\n          // Distance from polygon's center to the middle of its side\n          apothem = params.radius * cos(hdtheta);\n\n          // Calculate path and draw\n          ctx.beginPath();\n          for (i = 0; i < params.sides; i += 1) {\n\n            // Draw side of polygon\n            x = params.x + (params.radius * cos(theta));\n            y = params.y + (params.radius * sin(theta));\n\n            // Plot point on polygon\n            ctx.lineTo(x, y);\n\n            // Project side if chosen\n            if (params.concavity) {\n              // Sides are projected from the polygon's apothem\n              x = params.x + ((apothem + (-apothem * params.concavity)) * cos(theta + hdtheta));\n              y = params.y + ((apothem + (-apothem * params.concavity)) * sin(theta + hdtheta));\n              ctx.lineTo(x, y);\n            }\n\n            // Increment theta by delta theta\n            theta += dtheta;\n\n          }\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws pie-shaped slice\n  $.fn.drawSlice = function drawSlice(args) {\n    var $canvases = this, e, ctx,\n        params,\n        angle, dx, dy;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawSlice);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Perform extra calculations\n\n          // Convert angles to radians\n          params.start *= params._toRad;\n          params.end *= params._toRad;\n          // Consider 0deg at north of arc\n          params.start -= (PI / 2);\n          params.end -= (PI / 2);\n\n          // Find positive equivalents of angles\n          params.start = _getCoterminal(params.start);\n          params.end = _getCoterminal(params.end);\n          // Ensure start angle is less than end angle\n          if (params.end < params.start) {\n            params.end += (2 * PI);\n          }\n\n          // Calculate angular position of slice\n          angle = ((params.start + params.end) / 2);\n\n          // Calculate ratios for slice's angle\n          dx = (params.radius * params.spread * cos(angle));\n          dy = (params.radius * params.spread * sin(angle));\n\n          // Adjust position of slice\n          params.x += dx;\n          params.y += dy;\n\n          // Draw slice\n          ctx.beginPath();\n          ctx.arc(params.x, params.y, params.radius, params.start, params.end, params.ccw);\n          ctx.lineTo(params.x, params.y);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Path API */\n\n// Adds arrow to path using the given properties\n  function _addArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    var leftX, leftY,\n        rightX, rightY,\n        offsetX, offsetY,\n        angle;\n\n    // If arrow radius is given and path is not closed\n    if (path.arrowRadius && !params.closed) {\n\n      // Calculate angle\n      angle = atan2((y2 - y1), (x2 - x1));\n      // Adjust angle correctly\n      angle -= PI;\n      // Calculate offset to place arrow at edge of path\n      offsetX = (params.strokeWidth * cos(angle));\n      offsetY = (params.strokeWidth * sin(angle));\n\n      // Calculate coordinates for left half of arrow\n      leftX = x2 + (path.arrowRadius * cos(angle + (path.arrowAngle / 2)));\n      leftY = y2 + (path.arrowRadius * sin(angle + (path.arrowAngle / 2)));\n      // Calculate coordinates for right half of arrow\n      rightX = x2 + (path.arrowRadius * cos(angle - (path.arrowAngle / 2)));\n      rightY = y2 + (path.arrowRadius * sin(angle - (path.arrowAngle / 2)));\n\n      // Draw left half of arrow\n      ctx.moveTo(leftX - offsetX, leftY - offsetY);\n      ctx.lineTo(x2 - offsetX, y2 - offsetY);\n      // Draw right half of arrow\n      ctx.lineTo(rightX - offsetX, rightY - offsetY);\n\n      // Visually connect arrow to path\n      ctx.moveTo(x2 - offsetX, y2 - offsetY);\n      ctx.lineTo(x2 + offsetX, y2 + offsetY);\n      // Move back to end of path\n      ctx.moveTo(x2, y2);\n\n    }\n  }\n\n// Optionally adds arrow to start of path\n  function _addStartArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    if (!path._arrowAngleConverted) {\n      path.arrowAngle *= params._toRad;\n      path._arrowAngleConverted = true;\n    }\n    if (path.startArrow) {\n      _addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n    }\n  }\n\n// Optionally adds arrow to end of path\n  function _addEndArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    if (!path._arrowAngleConverted) {\n      path.arrowAngle *= params._toRad;\n      path._arrowAngleConverted = true;\n    }\n    if (path.endArrow) {\n      _addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n    }\n  }\n\n// Draws line (internal)\n  function _drawLine(canvas, ctx, params, path) {\n    var l,\n        lx, ly;\n    l = 2;\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        path.x2 + params.x,\n        path.y2 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      // If coordinates are given\n      if (lx !== undefined && ly !== undefined) {\n        // Draw next line\n        ctx.lineTo(lx + params.x, ly + params.y);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    // Optionally add arrows to path\n    _addEndArrow(\n        canvas, ctx,\n        params,\n        path,\n        path['x' + (l - 1)] + params.x,\n        path['y' + (l - 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws line\n  $.fn.drawLine = function drawLine(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawLine);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawLine($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Draws quadratic curve (internal)\n  function _drawQuadratic(canvas, ctx, params, path) {\n    var l,\n        lx, ly,\n        lcx, lcy;\n\n    l = 2;\n\n    _addStartArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path.cx1 + params.x,\n        path.cy1 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      lcx = path['cx' + (l - 1)];\n      lcy = path['cy' + (l - 1)];\n      // If coordinates are given\n      if (lx !== undefined && ly !== undefined && lcx !== undefined && lcy !== undefined) {\n        // Draw next curve\n        ctx.quadraticCurveTo(lcx + params.x, lcy + params.y, lx + params.x, ly + params.y);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    _addEndArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path['cx' + (l - 1)] + params.x,\n        path['cy' + (l - 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws quadratic curve\n  $.fn.drawQuadratic = function drawQuadratic(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawQuadratic);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawQuadratic($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws Bezier curve (internal)\n  function _drawBezier(canvas, ctx, params, path) {\n    var l, lc,\n        lx, ly,\n        lcx1, lcy1,\n        lcx2, lcy2;\n\n    l = 2;\n    lc = 1;\n\n    _addStartArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path.cx1 + params.x,\n        path.cy1 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      lcx1 = path['cx' + lc];\n      lcy1 = path['cy' + lc];\n      lcx2 = path['cx' + (lc + 1)];\n      lcy2 = path['cy' + (lc + 1)];\n      // If next coordinates are given\n      if (lx !== undefined && ly !== undefined && lcx1 !== undefined && lcy1 !== undefined && lcx2 !== undefined && lcy2 !== undefined) {\n        // Draw next curve\n        ctx.bezierCurveTo(lcx1 + params.x, lcy1 + params.y, lcx2 + params.x, lcy2 + params.y, lx + params.x, ly + params.y);\n        l += 1;\n        lc += 2;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    lc -= 2;\n    _addEndArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path['cx' + (lc + 1)] + params.x,\n        path['cy' + (lc + 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws Bezier curve\n  $.fn.drawBezier = function drawBezier(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawBezier);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawBezier($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves the x-coordinate for the given vector angle and length\n  function _getVectorX(params, angle, length) {\n    angle *= params._toRad;\n    angle -= (PI / 2);\n    return (length * cos(angle));\n  }\n// Retrieves the y-coordinate for the given vector angle and length\n  function _getVectorY(params, angle, length) {\n    angle *= params._toRad;\n    angle -= (PI / 2);\n    return (length * sin(angle));\n  }\n\n// Draws vector (internal) #2\n  function _drawVector(canvas, ctx, params, path) {\n    var l, angle, length,\n        offsetX, offsetY,\n        x, y,\n        x3, y3,\n        x4, y4;\n\n    // Determine offset from dragging\n    if (params === path) {\n      offsetX = 0;\n      offsetY = 0;\n    } else {\n      offsetX = params.x;\n      offsetY = params.y;\n    }\n\n    l = 1;\n    x = x3 = x4 = path.x + offsetX;\n    y = y3 = y4 = path.y + offsetY;\n\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        x + _getVectorX(params, path.a1, path.l1),\n        y + _getVectorY(params, path.a1, path.l1),\n        x,\n        y\n    );\n\n    // The vector starts at the given (x, y) coordinates\n    if (path.x !== undefined && path.y !== undefined) {\n      ctx.moveTo(x, y);\n    }\n    while (true) {\n\n      angle = path['a' + l];\n      length = path['l' + l];\n\n      if (angle !== undefined && length !== undefined) {\n        // Convert the angle to radians with 0 degrees starting at north\n        // Keep track of last two coordinates\n        x3 = x4;\n        y3 = y4;\n        // Compute (x, y) coordinates from angle and length\n        x4 += _getVectorX(params, angle, length);\n        y4 += _getVectorY(params, angle, length);\n        ctx.lineTo(x4, y4);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n\n    }\n    _addEndArrow(\n        canvas, ctx,\n        params, path,\n        x3, y3,\n        x4, y4\n    );\n  }\n\n// Draws vector\n  $.fn.drawVector = function drawVector(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawVector);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawVector($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws a path consisting of one or more subpaths\n  $.fn.drawPath = function drawPath(args) {\n    var $canvases = this, e, ctx,\n        params,\n        l, lp;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawPath);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          l = 1;\n          while (true) {\n            lp = params['p' + l];\n            if (lp !== undefined) {\n              lp = new jCanvasObject(lp);\n              if (lp.type === 'line') {\n                _drawLine($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'quadratic') {\n                _drawQuadratic($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'bezier') {\n                _drawBezier($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'vector') {\n                _drawVector($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'arc') {\n                _drawArc($canvases[e], ctx, params, lp);\n              }\n              l += 1;\n            } else {\n              break;\n            }\n          }\n\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Text API */\n\n// Calculates font string and set it as the canvas font\n  function _setCanvasFont(canvas, ctx, params) {\n    // Otherwise, use the given font attributes\n    if (!isNaN(Number(params.fontSize))) {\n      // Give font size units if it doesn't have any\n      params.fontSize += 'px';\n    }\n    // Set font using given font properties\n    ctx.font = params.fontStyle + ' ' + params.fontSize + ' ' + params.fontFamily;\n  }\n\n// Measures canvas text\n  function _measureText(canvas, ctx, params, lines) {\n    var originalSize, curWidth, l,\n        propCache = caches.propCache;\n\n    // Used cached width/height if possible\n    if (propCache.text === params.text && propCache.fontStyle === params.fontStyle && propCache.fontSize === params.fontSize && propCache.fontFamily === params.fontFamily && propCache.maxWidth === params.maxWidth && propCache.lineHeight === params.lineHeight) {\n\n      params.width = propCache.width;\n      params.height = propCache.height;\n\n    } else {\n      // Calculate text dimensions only once\n\n      // Calculate width of first line (for comparison)\n      params.width = ctx.measureText(lines[0]).width;\n\n      // Get width of longest line\n      for (l = 1; l < lines.length; l += 1) {\n\n        curWidth = ctx.measureText(lines[l]).width;\n        // Ensure text's width is the width of its longest line\n        if (curWidth > params.width) {\n          params.width = curWidth;\n        }\n\n      }\n\n      // Save original font size\n      originalSize = canvas.style.fontSize;\n      // Temporarily set canvas font size to retrieve size in pixels\n      canvas.style.fontSize = params.fontSize;\n      // Save text width and height in parameters object\n      params.height = parseFloat($.css(canvas, 'fontSize')) * lines.length * params.lineHeight;\n      // Reset font size to original size\n      canvas.style.fontSize = originalSize;\n    }\n  }\n\n// Wraps a string of text within a defined width\n  function _wrapText(ctx, params) {\n    var allText = String(params.text),\n        // Maximum line width (optional)\n        maxWidth = params.maxWidth,\n        // Lines created by manual line breaks (\\n)\n        manualLines = allText.split('\\n'),\n        // All lines created manually and by wrapping\n        allLines = [],\n        // Other variables\n        lines, line, l,\n        text, words, w;\n\n    // Loop through manually-broken lines\n    for (l = 0; l < manualLines.length; l += 1) {\n\n      text = manualLines[l];\n      // Split line into list of words\n      words = text.split(' ');\n      lines = [];\n      line = '';\n\n      // If text is short enough initially\n      // Or, if the text consists of only one word\n      if (words.length === 1 || ctx.measureText(text).width < maxWidth) {\n\n        // No need to wrap text\n        lines = [text];\n\n      } else {\n\n        // Wrap lines\n        for (w = 0; w < words.length; w += 1) {\n\n          // Once line gets too wide, push word to next line\n          if (ctx.measureText(line + words[w]).width > maxWidth) {\n            // This check prevents empty lines from being created\n            if (line !== '') {\n              lines.push(line);\n            }\n            // Start new line and repeat process\n            line = '';\n          }\n          // Add words to line until the line is too wide\n          line += words[w];\n          // Do not add a space after the last word\n          if (w !== (words.length - 1)) {\n            line += ' ';\n          }\n        }\n        // The last word should always be pushed\n        lines.push(line);\n\n      }\n      // Remove extra space at the end of each line\n      allLines = allLines.concat(\n          lines\n              .join('\\n')\n              .replace(/((\\n))|($)/gi, '$2')\n              .split('\\n')\n      );\n\n    }\n\n    return allLines;\n  }\n\n// Draws text on canvas\n  $.fn.drawText = function drawText(args) {\n    var $canvases = this, e, ctx,\n        params, layer,\n        lines, line, l,\n        fontSize, constantCloseness = 500,\n        nchars, chars, ch, c,\n        x, y;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawText);\n        if (params.visible) {\n\n          // Set text-specific properties\n          ctx.textBaseline = params.baseline;\n          ctx.textAlign = params.align;\n\n          // Set canvas font using given properties\n          _setCanvasFont($canvases[e], ctx, params);\n\n          if (params.maxWidth !== null) {\n            // Wrap text using an internal function\n            lines = _wrapText(ctx, params);\n          } else {\n            // Convert string of text to list of lines\n            lines = params.text\n                .toString()\n                .split('\\n');\n          }\n\n          // Calculate text's width and height\n          _measureText($canvases[e], ctx, params, lines);\n\n          // If text is a layer\n          if (layer) {\n            // Copy calculated width/height to layer object\n            layer.width = params.width;\n            layer.height = params.height;\n          }\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Adjust text position to accomodate different horizontal alignments\n          x = params.x;\n          if (params.align === 'left') {\n            if (params.respectAlign) {\n              // Realign text to the left if chosen\n              params.x += params.width / 2;\n            } else {\n              // Center text block by default\n              x -= params.width / 2;\n            }\n          } else if (params.align === 'right') {\n            if (params.respectAlign) {\n              // Realign text to the right if chosen\n              params.x -= params.width / 2;\n            } else {\n              // Center text block by default\n              x += params.width / 2;\n            }\n          }\n\n          if (params.radius) {\n\n            fontSize = parseFloat(params.fontSize);\n\n            // Greater values move clockwise\n            if (params.letterSpacing === null) {\n              params.letterSpacing = fontSize / constantCloseness;\n            }\n\n            // Loop through each line of text\n            for (l = 0; l < lines.length; l += 1) {\n              ctx.save();\n              ctx.translate(params.x, params.y);\n              line = lines[l];\n              if (params.flipArcText) {\n                chars = line.split('');\n                chars.reverse();\n                line = chars.join('');\n              }\n              nchars = line.length;\n              ctx.rotate(-(PI * params.letterSpacing * (nchars - 1)) / 2);\n              // Loop through characters on each line\n              for (c = 0; c < nchars; c += 1) {\n                ch = line[c];\n                // If character is not the first character\n                if (c !== 0) {\n                  // Rotate character onto arc\n                  ctx.rotate(PI * params.letterSpacing);\n                }\n                ctx.save();\n                ctx.translate(0, -params.radius);\n                if (params.flipArcText) {\n                  ctx.scale(-1, -1);\n                }\n                ctx.fillText(ch, 0, 0);\n                // Prevent extra shadow created by stroke (but only when fill is present)\n                if (params.fillStyle !== 'transparent') {\n                  ctx.shadowColor = 'transparent';\n                }\n                if (params.strokeWidth !== 0) {\n                  // Only stroke if the stroke is not 0\n                  ctx.strokeText(ch, 0, 0);\n                }\n                ctx.restore();\n              }\n              params.radius -= fontSize;\n              params.letterSpacing += fontSize / (constantCloseness * 2 * PI);\n              ctx.restore();\n            }\n\n          } else {\n\n            // Draw each line of text separately\n            for (l = 0; l < lines.length; l += 1) {\n              line = lines[l];\n              // Add line offset to center point, but subtract some to center everything\n              y = params.y + (l * params.height / lines.length) - (((lines.length - 1) * params.height / lines.length) / 2);\n\n              ctx.shadowColor = params.shadowColor;\n\n              // Fill & stroke text\n              ctx.fillText(line, x, y);\n              // Prevent extra shadow created by stroke (but only when fill is present)\n              if (params.fillStyle !== 'transparent') {\n                ctx.shadowColor = 'transparent';\n              }\n              if (params.strokeWidth !== 0) {\n                // Only stroke if the stroke is not 0\n                ctx.strokeText(line, x, y);\n              }\n\n            }\n\n          }\n\n          // Adjust bounding box according to text baseline\n          y = 0;\n          if (params.baseline === 'top') {\n            y += params.height / 2;\n          } else if (params.baseline === 'bottom') {\n            y -= params.height / 2;\n          }\n\n          // Detect jCanvas events\n          if (params._event) {\n            ctx.beginPath();\n            ctx.rect(\n                params.x - (params.width / 2),\n                params.y - (params.height / 2) + y,\n                params.width,\n                params.height\n            );\n            _detectEvents($canvases[e], ctx, params);\n            // Close path and configure masking\n            ctx.closePath();\n          }\n          _restoreTransform(ctx, params);\n\n        }\n      }\n    }\n    // Cache jCanvas parameters object for efficiency\n    caches.propCache = params;\n    return $canvases;\n  };\n\n// Measures text width/height using the given parameters\n  $.fn.measureText = function measureText(args) {\n    var $canvases = this, ctx,\n        params, lines;\n\n    // Attempt to retrieve layer\n    params = $canvases.getLayer(args);\n    // If layer does not exist or if returned object is not a jCanvas layer\n    if (!params || (params && !params._layer)) {\n      params = new jCanvasObject(args);\n    }\n\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      // Set canvas font using given properties\n      _setCanvasFont($canvases[0], ctx, params);\n      // Calculate width and height of text\n      if (params.maxWidth !== null) {\n        lines = _wrapText(ctx, params);\n      } else {\n        lines = params.text.split('\\n');\n      }\n      _measureText($canvases[0], ctx, params, lines);\n\n\n    }\n\n    return params;\n  };\n\n  /* Image API */\n\n// Draws image on canvas\n  $.fn.drawImage = function drawImage(args) {\n    var $canvases = this, canvas, e, ctx, data,\n        params, layer,\n        img, imgCtx, source,\n        imageCache = caches.imageCache;\n\n    // Draw image function\n    function draw(canvas, ctx, data, params, layer) {\n\n      // If width and sWidth are not defined, use image width\n      if (params.width === null && params.sWidth === null) {\n        params.width = params.sWidth = img.width;\n      }\n      // If width and sHeight are not defined, use image height\n      if (params.height === null && params.sHeight === null) {\n        params.height = params.sHeight = img.height;\n      }\n\n      // Ensure image layer's width and height are accurate\n      if (layer) {\n        layer.width = params.width;\n        layer.height = params.height;\n      }\n\n      // Only crop image if all cropping properties are given\n      if (params.sWidth !== null && params.sHeight !== null && params.sx !== null && params.sy !== null) {\n\n        // If width is not defined, use the given sWidth\n        if (params.width === null) {\n          params.width = params.sWidth;\n        }\n        // If height is not defined, use the given sHeight\n        if (params.height === null) {\n          params.height = params.sHeight;\n        }\n\n        // Optionally crop from top-left corner of region\n        if (params.cropFromCenter) {\n          params.sx += params.sWidth / 2;\n          params.sy += params.sHeight / 2;\n        }\n\n        // Ensure cropped region does not escape image boundaries\n\n        // Top\n        if ((params.sy - (params.sHeight / 2)) < 0) {\n          params.sy = (params.sHeight / 2);\n        }\n        // Bottom\n        if ((params.sy + (params.sHeight / 2)) > img.height) {\n          params.sy = img.height - (params.sHeight / 2);\n        }\n        // Left\n        if ((params.sx - (params.sWidth / 2)) < 0) {\n          params.sx = (params.sWidth / 2);\n        }\n        // Right\n        if ((params.sx + (params.sWidth / 2)) > img.width) {\n          params.sx = img.width - (params.sWidth / 2);\n        }\n\n        _transformShape(canvas, ctx, params, params.width, params.height);\n        _setGlobalProps(canvas, ctx, params);\n\n        // Draw image\n        ctx.drawImage(\n            img,\n            params.sx - (params.sWidth / 2),\n            params.sy - (params.sHeight / 2),\n            params.sWidth,\n            params.sHeight,\n            params.x - (params.width / 2),\n            params.y - (params.height / 2),\n            params.width,\n            params.height\n        );\n\n      } else {\n        // Show entire image if no crop region is defined\n\n        _transformShape(canvas, ctx, params, params.width, params.height);\n        _setGlobalProps(canvas, ctx, params);\n\n        // Draw image on canvas\n        ctx.drawImage(\n            img,\n            params.x - (params.width / 2),\n            params.y - (params.height / 2),\n            params.width,\n            params.height\n        );\n\n      }\n\n      // Draw invisible rectangle to allow for events and masking\n      ctx.beginPath();\n      ctx.rect(\n          params.x - (params.width / 2),\n          params.y - (params.height / 2),\n          params.width,\n          params.height\n      );\n      // Check for jCanvas events\n      _detectEvents(canvas, ctx, params);\n      // Close path and configure masking\n      ctx.closePath();\n      _restoreTransform(ctx, params);\n      _enableMasking(ctx, data, params);\n    }\n    // On load function\n    function onload(canvas, ctx, data, params, layer) {\n      return function () {\n        var $canvas = $(canvas);\n        draw(canvas, ctx, data, params, layer);\n        if (params.layer) {\n          // Trigger 'load' event for layers\n          _triggerLayerEvent($canvas, data, layer, 'load');\n        } else if (params.load) {\n          // Run 'load' callback for non-layers\n          params.load.call($canvas[0], layer);\n        }\n        // Continue drawing successive layers after this image layer has loaded\n        if (params.layer) {\n          // Store list of previous masks for each layer\n          layer._masks = data.transforms.masks.slice(0);\n          if (params._next) {\n            // Draw successive layers\n            $canvas.drawLayers({\n              clear: false,\n              resetFire: true,\n              index: params._next\n            });\n          }\n        }\n      };\n    }\n    for (e = 0; e < $canvases.length; e += 1) {\n      canvas = $canvases[e];\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n        params = new jCanvasObject(args);\n        layer = _addLayer($canvases[e], params, args, drawImage);\n        if (params.visible) {\n\n          // Cache the given source\n          source = params.source;\n\n          imgCtx = source.getContext;\n          if (source.src || imgCtx) {\n            // Use image or canvas element if given\n            img = source;\n          } else if (source) {\n            if (imageCache[source] && imageCache[source].complete) {\n              // Get the image element from the cache if possible\n              img = imageCache[source];\n            } else {\n              // Otherwise, get the image from the given source URL\n              img = new Image();\n              // If source URL is not a data URL\n              if (!source.match(/^data:/i)) {\n                // Set crossOrigin for this image\n                img.crossOrigin = params.crossOrigin;\n              }\n              img.src = source;\n              // Save image in cache for improved performance\n              imageCache[source] = img;\n            }\n          }\n\n          if (img) {\n            if (img.complete || imgCtx) {\n              // Draw image if already loaded\n              onload(canvas, ctx, data, params, layer)();\n            } else {\n              // Otherwise, draw image when it loads\n              img.onload = onload(canvas, ctx, data, params, layer);\n              // Fix onload() bug in IE9\n              img.src = img.src;\n            }\n          }\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Creates a canvas pattern object\n  $.fn.createPattern = function createPattern(args) {\n    var $canvases = this, ctx,\n        params,\n        img, imgCtx,\n        pattern, source;\n\n    // Function to be called when pattern loads\n    function onload() {\n      // Create pattern\n      pattern = ctx.createPattern(img, params.repeat);\n      // Run callback function if defined\n      if (params.load) {\n        params.load.call($canvases[0], pattern);\n      }\n    }\n\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      params = new jCanvasObject(args);\n\n      // Cache the given source\n      source = params.source;\n\n      // Draw when image is loaded (if load() callback function is defined)\n\n      if (isFunction(source)) {\n        // Draw pattern using function if given\n\n        img = $('<canvas />')[0];\n        img.width = params.width;\n        img.height = params.height;\n        imgCtx = _getContext(img);\n        source.call(img, imgCtx);\n        onload();\n\n      } else {\n        // Otherwise, draw pattern using source image\n\n        imgCtx = source.getContext;\n        if (source.src || imgCtx) {\n          // Use image element if given\n          img = source;\n        } else {\n          // Use URL if given to get the image\n          img = new Image();\n          // If source URL is not a data URL\n          if (!source.match(/^data:/i)) {\n            // Set crossOrigin for this image\n            img.crossOrigin = params.crossOrigin;\n          }\n          img.src = source;\n        }\n\n        // Create pattern if already loaded\n        if (img.complete || imgCtx) {\n          onload();\n        } else {\n          img.onload = onload;\n          // Fix onload() bug in IE9\n          img.src = img.src;\n        }\n\n      }\n\n    } else {\n\n      pattern = null;\n\n    }\n    return pattern;\n  };\n\n// Creates a canvas gradient object\n  $.fn.createGradient = function createGradient(args) {\n    var $canvases = this, ctx,\n        params,\n        gradient,\n        stops = [], nstops,\n        start, end,\n        i, a, n, p;\n\n    params = new jCanvasObject(args);\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      // Gradient coordinates must be defined\n      params.x1 = params.x1 || 0;\n      params.y1 = params.y1 || 0;\n      params.x2 = params.x2 || 0;\n      params.y2 = params.y2 || 0;\n\n      if (params.r1 !== null && params.r2 !== null) {\n        // Create radial gradient if chosen\n        gradient = ctx.createRadialGradient(params.x1, params.y1, params.r1, params.x2, params.y2, params.r2);\n      } else {\n        // Otherwise, create a linear gradient by default\n        gradient = ctx.createLinearGradient(params.x1, params.y1, params.x2, params.y2);\n      }\n\n      // Count number of color stops\n      for (i = 1; params['c' + i] !== undefined; i += 1) {\n        if (params['s' + i] !== undefined) {\n          stops.push(params['s' + i]);\n        } else {\n          stops.push(null);\n        }\n      }\n      nstops = stops.length;\n\n      // Define start stop if not already defined\n      if (stops[0] === null) {\n        stops[0] = 0;\n      }\n      // Define end stop if not already defined\n      if (stops[nstops - 1] === null) {\n        stops[nstops - 1] = 1;\n      }\n\n      // Loop through color stops to fill in the blanks\n      for (i = 0; i < nstops; i += 1) {\n        // A progression, in this context, is defined as all of the color stops between and including two known color stops\n\n        if (stops[i] !== null) {\n          // Start a new progression if stop is a number\n\n          // Number of stops in current progression\n          n = 1;\n          // Current iteration in current progression\n          p = 0;\n          start = stops[i];\n\n          // Look ahead to find end stop\n          for (a = (i + 1); a < nstops; a += 1) {\n            if (stops[a] !== null) {\n              // If this future stop is a number, make it the end stop for this progression\n              end = stops[a];\n              break;\n            } else {\n              // Otherwise, keep looking ahead\n              n += 1;\n            }\n          }\n\n          // Ensure start stop is not greater than end stop\n          if (start > end) {\n            stops[a] = stops[i];\n          }\n\n        } else if (stops[i] === null) {\n          // Calculate stop if not initially given\n          p += 1;\n          stops[i] = start + (p * ((end - start) / n));\n        }\n        // Add color stop to gradient object\n        gradient.addColorStop(stops[i], params['c' + (i + 1)]);\n      }\n\n    } else {\n      gradient = null;\n    }\n    return gradient;\n  };\n\n// Manipulates pixels on the canvas\n  $.fn.setPixels = function setPixels(args) {\n    var $canvases = this,\n        canvas, e, ctx, canvasData,\n        params,\n        px,\n        imgData, pixelData, i, len;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      canvas = $canvases[e];\n      ctx = _getContext(canvas);\n      canvasData = _getCanvasData($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer(canvas, params, args, setPixels);\n        _transformShape($canvases[e], ctx, params, params.width, params.height);\n\n        // Use entire canvas of x, y, width, or height is not defined\n        if (params.width === null || params.height === null) {\n          params.width = canvas.width;\n          params.height = canvas.height;\n          params.x = params.width / 2;\n          params.y = params.height / 2;\n        }\n\n        if (params.width !== 0 && params.height !== 0) {\n          // Only set pixels if width and height are not zero\n\n          imgData = ctx.getImageData(\n              (params.x - (params.width / 2)) * canvasData.pixelRatio,\n              (params.y - (params.height / 2)) * canvasData.pixelRatio,\n              params.width * canvasData.pixelRatio,\n              params.height * canvasData.pixelRatio\n          );\n          pixelData = imgData.data;\n          len = pixelData.length;\n\n          // Loop through pixels with the \"each\" callback function\n          if (params.each) {\n            for (i = 0; i < len; i += 4) {\n              px = {\n                r: pixelData[i],\n                g: pixelData[i + 1],\n                b: pixelData[i + 2],\n                a: pixelData[i + 3]\n              };\n              params.each.call(canvas, px, params);\n              pixelData[i] = px.r;\n              pixelData[i + 1] = px.g;\n              pixelData[i + 2] = px.b;\n              pixelData[i + 3] = px.a;\n            }\n          }\n          // Put pixels on canvas\n          ctx.putImageData(\n              imgData,\n              (params.x - (params.width / 2)) * canvasData.pixelRatio,\n              (params.y - (params.height / 2)) * canvasData.pixelRatio\n          );\n          // Restore transformation\n          ctx.restore();\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves canvas image as data URL\n  $.fn.getCanvasImage = function getCanvasImage(type, quality) {\n    var $canvases = this, canvas,\n        dataURL = null;\n    if ($canvases.length !== 0) {\n      canvas = $canvases[0];\n      if (canvas.toDataURL) {\n        // JPEG quality defaults to 1\n        if (quality === undefined) {\n          quality = 1;\n        }\n        dataURL = canvas.toDataURL('image/' + type, quality);\n      }\n    }\n    return dataURL;\n  };\n\n// Scales canvas based on the device's pixel ratio\n  $.fn.detectPixelRatio = function detectPixelRatio(callback) {\n    var $canvases = this,\n        canvas, e, ctx,\n        devicePixelRatio, backingStoreRatio, ratio,\n        oldWidth, oldHeight,\n        data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      // Get canvas and its associated data\n      canvas = $canvases[e];\n      ctx = _getContext(canvas);\n      data = _getCanvasData($canvases[e]);\n\n      // If canvas has not already been scaled with this method\n      if (!data.scaled) {\n\n        // Determine device pixel ratios\n        devicePixelRatio = window.devicePixelRatio || 1;\n        backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n            ctx.mozBackingStorePixelRatio ||\n            ctx.msBackingStorePixelRatio ||\n            ctx.oBackingStorePixelRatio ||\n            ctx.backingStorePixelRatio || 1;\n\n        // Calculate general ratio based on the two given ratios\n        ratio = devicePixelRatio / backingStoreRatio;\n\n        if (ratio !== 1) {\n          // Scale canvas relative to ratio\n\n          // Get the current canvas dimensions for future use\n          oldWidth = canvas.width;\n          oldHeight = canvas.height;\n\n          // Resize canvas relative to the determined ratio\n          canvas.width = oldWidth * ratio;\n          canvas.height = oldHeight * ratio;\n\n          // Scale canvas back to original dimensions via CSS\n          canvas.style.width = oldWidth + 'px';\n          canvas.style.height = oldHeight + 'px';\n\n          // Scale context to counter the manual scaling of canvas\n          ctx.scale(ratio, ratio);\n\n        }\n\n        // Set pixel ratio on canvas data object\n        data.pixelRatio = ratio;\n        // Ensure that this method can only be called once for any given canvas\n        data.scaled = true;\n\n        // Call the given callback function with the ratio as its only argument\n        if (callback) {\n          callback.call(canvas, ratio);\n        }\n\n      }\n\n    }\n    return $canvases;\n  };\n\n// Clears the jCanvas cache\n  jCanvas.clearCache = function clearCache() {\n    var cacheName;\n    for (cacheName in caches) {\n      if (Object.prototype.hasOwnProperty.call(caches, cacheName)) {\n        caches[cacheName] = {};\n      }\n    }\n  };\n\n// Enable canvas feature detection with $.support\n  $.support.canvas = ($('<canvas />')[0].getContext !== undefined);\n\n// Export jCanvas functions\n  extendObject(jCanvas, {\n    defaults: defaults,\n    setGlobalProps: _setGlobalProps,\n    transformShape: _transformShape,\n    detectEvents: _detectEvents,\n    closePath: _closePath,\n    setCanvasFont: _setCanvasFont,\n    measureText: _measureText\n  });\n  $.jCanvas = jCanvas;\n  $.jCanvasObject = jCanvasObject;\n\n}));"]}