{"version":3,"sources":["script.js","sectors.js","notes.js","main.js","jcanvas.js"],"names":["cartesian2Polar","x","y","upX","CenterX","upY","CenterY","distance","Math","sqrt","radians","atan2","degr","PI","polarCoor","cartesian2Dec","radius","tan","pow","decCoor","X","Y","cartesian2DecForBorder","newDegr","hexInArray","h","m","slice","match","parseInt","hexArrayInRgbString","rgb","changeColorLayers","color","numLayers","arColor","tempColor","arRBA","i","difColorRed","difColorGreen","difColorBlue","red","green","blue","floor","console","log","createSectorNew","sector_id","beginAngle","endAngle","circle_id","arColors","difRadius","bigRadius","nameArc","nameSector","nameGroup","canvas","$","drawSlice","layer","mask","groups","fillStyle","start","end","strokeStyle","strokeWidth","restoreCanvas","name","dblclick","polar","eventX","eventY","link","attr","removeClass","addClass","text","click","drawArc","shadowBlur","shadowColor","mouseout","setLayer","drawLayer","createBorderSector","data","endCoord","drawVector","a1","l1","borderForSector","angle","sectorLeftId","sectorRightId","angleMin","angelMax","LabelCoord","leftCoord","rightCoord","draggable","radiusLabel","circlePath","circleRadius","circleCenterX","circleCenterY","xMin","yMin","xMax","yMax","sectorLeft","sectorRight","shadowLabelSize","dragstop","pol","getLayer","circleId","beginAngleL","colorL","endAngleR","colorR","newLeftSectorMinAngle","newRightSectorMinAngle","oldLeftSectorMinAngle","oldRightSectorMinAngle","coefficientLeft","coefficientRight","updateLabelPositionByChangingSector","removeLayerGroup","setHightMoveLayerToLayer","drag","mouseover","rayAndCircleByLabel","id","dec","colorRayAndCircleByLabel","drawLine","x1","y1","x2","y2","createNamePopUpLabel","heightPopUp","widthPopUp","drawRect","width","height","cornerRadius","drawText","fontSize","fontFamily","maxWidth","createLabel","colorLabel","label_radius","label_angle","label_id","updateCoordinateLabel","delRayNamePopUpAndCircleByLabel","Label","colorSelectLabel","delRayNamePopUpAndCircleAllLabels","setLinkLabelsByRadiusAndAngle","removeLinkLabelsByRadiusAndAngle","css","setMoveLayerToLayer","index","array","moveLayer","dragLayers","getLayers","forEach","setFillStyleToLayer","angleBorderMin","angleBorderMax","radiusBorderMin","radiusBorderMax","labels","getLayerGroup","deleteFillStyleToLayer","delNamePopUpByLabel","border","updateLabelPosition","label","sector_left","newAngle","sector_right","labelId","post","done","removeLayer","addTagForm","$collectionHolder","$newLinkLi","prototype","newForm","replace","$newFormLi","append","before","e","preventDefault","this","parent","remove","addTagFormDeleteLink","$tagFormLi","$removeFormA","on","getNoteContent","noteId","host","window","location","hostname","port","ajax","url","isLocalDev","type","success","document","getElementById","innerHTML","title","href","error","err","setDisabledToRange","selsectCategory","val","isLocalhost","Boolean","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","jQuery","global","factory","module","exports","w","jCanvasObject","args","propName","params","Object","hasOwnProperty","call","jCanvasDefaults","extendObject","baseDefaults","isString","operand","typeOf","isNumeric","isNaN","Number","parseFloat","_getContext","getContext","_coerceNumericProps","props","propType","propValue","undefined","String","_cloneTransforms","transforms","masks","_saveCanvas","ctx","save","savedTransforms","push","_restoreCanvas","length","baseTransforms","restore","pop","_setStyle","styleName","isFunction","_setGlobalProps","lineWidth","rounded","lineCap","lineJoin","strokeCap","strokeJoin","miterLimit","strokeDash","setLineDash","webkitLineDash","lineDashOffset","webkitLineDashOffset","mozDashOffset","strokeDashOffset","shadowOffsetX","shadowX","shadowOffsetY","shadowY","globalAlpha","opacity","globalCompositeOperation","compositing","imageSmoothing","imageSmoothingEnabled","_enableMasking","autosave","clip","_args","_restoreTransform","_transformed","_closePath","closed","closePath","shadowStroke","stroke","fill","_getCanvasData","_transformShape","_toRad","inDegrees","fromCenter","_centered","rotate","_rotateCanvas","scale","scaleX","scaleY","_scaleCanvas","translate","translateX","translateY","_translateCanvas","dataCache","caches","_canvas","_data","layers","names","eventHooks","intersecting","lastIntersected","cursor","dragging","event","events","animating","animated","pixelRatio","scaled","redrawOnMousemove","_addLayerEvents","$canvas","eventName","jCanvas","cursors","_addExplicitLayerEvent","bind","l","_triggerLayerEvent","_hovered","triggerLayerEvent","drawLayers","_addLayerEvent","_event","_enableDrag","dragHelperEvents","_updateLayerName","nameMap","_updateLayerGroups","group","groupName","g","groupMap","splice","_getIntersectingLayer","_masks","intersects","intangible","_drawLayer","nextLayerIndex","visible","_method","_next","_handleLayerDrag","eventType","dragGroups","newX","newY","bringToFront","_startX","_startY","_endX","_eventX","_endY","_eventY","updateDragX","updateDragY","dx","dy","restrictDragToAxis","centerX","centerY","r","k","tempX","tempY","px","py","qx","qy","rx","ry","Result","absSumMin","abs","absSumMax","originalRedrawOnMousemove","_setCursor","inArray","prefix","_resetCursor","_runEventCallback","callbacks","arg","_running","_layerCanFireEvent","disableEvents","tangibleEvents","_addLayer","method","_layer","fn","maps","drawings","measureText","_showProps","obj","cssProp","p","_hideProps","reset","propsObj","_parseEndValues","endValues","subPropName","subPropValue","isPlainObject","_removeSubPropAliases","indexOf","_colorToRgbArray","originalColor","elem","multiple","head","style","_animateColor","fx","n","now","pos","round","join","nodeName","prop","_supportColorProps","step","_getTouchEventName","touchEvents","_getMouseEventName","mouseEvents","_createEvent","eventCallback","eventCache","offsetX","offsetY","helperEventName","resetFire","touchEventName","_createEvents","eventNames","_detectEvents","isPointInPath","isPointInStroke","cos","sin","_getCoterminal","_getArcX","_getArcY","_drawArc","path","x3","y3","x4","y4","diff","ccw","_addStartArrow","arc","_addEndArrow","_addArrow","leftX","leftY","rightX","rightY","arrowRadius","arrowAngle","moveTo","lineTo","_arrowAngleConverted","startArrow","endArrow","_drawLine","lx","ly","_drawQuadratic","lcx","lcy","cx1","cy1","quadraticCurveTo","_drawBezier","lc","lcx1","lcy1","lcx2","lcy2","bezierCurveTo","_getVectorX","_getVectorY","_drawVector","_setCanvasFont","font","fontStyle","_measureText","lines","originalSize","curWidth","propCache","lineHeight","_wrapText","line","words","allText","manualLines","split","allLines","concat","defaults","Image","Array","getComputedStyle","extend","toString","toLowerCase","arraySlice","jQueryEventFix","fix","imageCache","future","align","baseline","concavity","count","cropFromCenter","crossOrigin","letterSpacing","r1","r2","repeat","respectAlign","sHeight","sides","source","spread","sWidth","sx","sy","plugin","self","$canvases","getEventHooks","setEventHooks","callback","matching","layerId","idType","groupId","getLayerIndex","substr","isEmptyObject","setLayers","setLayerGroup","removeLayers","addLayerToGroup","removeLayerFromGroup","styles","documentElement","pre","OLink","lastLayer","lastIndex","isImageLayer","clear","clearCanvas","_fired","drawImage","addLayer","animateLayer","complete","_animating","parts","hidden","_pos","arguments","duration","easing","draw","animate","animateLayerGroup","apply","delayLayer","delay","delayLayerGroup","stopLayer","clearQueue","stop","stopLayerGroup","mousedown","mouseup","mousemove","touchstart","touchend","touchmove","offset","originalEvent","touches","changedTouches","pageX","currentTarget","left","pageY","top","bezier","ellipse","function","image","polygon","quadratic","rectangle","vector","setTransform","clearRect","saveCanvas","rotateCanvas","scaleCanvas","translateCanvas","temp","beginPath","rect","drawEllipse","controlW","controlH","drawPolygon","theta","dtheta","hdtheta","apothem","drawQuadratic","drawBezier","drawPath","lp","nchars","chars","ch","c","constantCloseness","textBaseline","textAlign","flipArcText","reverse","fillText","strokeText","img","onload","load","imgCtx","src","createPattern","pattern","createGradient","gradient","nstops","a","stops","createRadialGradient","createLinearGradient","addColorStop","setPixels","canvasData","imgData","pixelData","len","getImageData","each","b","putImageData","getCanvasImage","quality","dataURL","toDataURL","detectPixelRatio","devicePixelRatio","backingStoreRatio","ratio","oldWidth","oldHeight","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","clearCache","cacheName","support","setGlobalProps","transformShape","detectEvents","setCanvasFont","$addTagLink","ready","html","find","change"],"mappings":"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","file":"main.min.js","sourcesContent":["var CenterX = 300;\nvar CenterY = 300;\nconst bigRadius = 250;\nvar colorRayAndCircleByLabel = '#48D1CC';\nvar colorLabel = '#36c';\nvar radiusLabel = 15;\nvar colorSelectLabel = \"Red\";\nvar shadowLabelSize = 10;\nvar shadowColor = \"white\";\n\n/*\n * General functions\n * */\n\n/**\n * From dec in polar\n *\n * @param {float} x\n * @param {float} y\n * @returns {object}\n */\nfunction cartesian2Polar(x, y) {\n  var upX = (x-CenterX);\n  var upY = (y-CenterY);\n  distance = Math.sqrt(upX * upX + upY * upY);\n  radians = Math.atan2(upY, upX);\n  degr = radians*180/Math.PI+90;\n  polarCoor = {distance: distance, degr: degr};\n  return polarCoor;\n}\n\n/**\n * From polar in dec\n *\n * @param {float} radius\n * @param {float} degr\n * @returns {object}\n */\nfunction cartesian2Dec(radius, degr) {\n  radians = (degr-90)*(Math.PI/180);\n  if(degr >= 0 && degr <= 180){\n    tan  = Math.tan(radians);\n    x = Math.sqrt((Math.pow(radius,2))/(Math.pow(tan,2)+1));\n    y = x*tan;\n  }else{\n    tan  = Math.tan(-radians);\n    x = -Math.sqrt((Math.pow(radius,2))/(Math.pow(tan,2)+1));\n    y = -x*tan;\n  }\n  decCoor = {X: x+CenterX, Y: y+CenterY};\n  return decCoor;\n}\n\n/**\n * From polar in dec\n *\n * @param {float} radius\n * @param {float} degr\n * @returns {object}\n */\nfunction cartesian2DecForBorder(radius, degr) {\n  var newDegr = (degr-90);\n  radians = newDegr*(Math.PI/180);\n\n  if(newDegr >= 0 && newDegr <= 180){\n    tan  = Math.tan(radians);\n    x = Math.sqrt((radius*radius)/(tan*tan+1));\n    y = x*tan;\n  }else{\n    tan  = Math.tan(-radians);\n    x = Math.sqrt((radius*radius)/(tan*tan+1));\n    y = x*tan;\n  }\n\n  decCoor = {X: x, Y: y};\n\n  return decCoor;\n}\n\n/**\n *function for convert HEX -> rgba\n * */\n\nfunction hexInArray(h){\n  var m = h.slice(1).match(/.{2}/g);\n  m[0]=parseInt(m[0], 16);\n  m[1]=parseInt(m[1], 16);\n  m[2]=parseInt(m[2], 16);\n  return m;\n};\n\nfunction hexArrayInRgbString(m) {\n  var rgb = 'rgb('+m[0]+', '+m[1]+', '+m[2]+')';\n  return rgb;\n}\n\nfunction changeColorLayers(color,numLayers) {\n  var arColor = hexInArray(color);\n  var tempColor = arColor;\n  var arRBA = [];\n  var i = 0;\n  var difColorRed = (256-arColor[0])/numLayers;\n  var difColorGreen = (arColor[1])/(numLayers-1);\n  var difColorBlue = (arColor[2])/(numLayers-1);\n  var red = arColor[0] + difColorRed;\n  var green = arColor[1];\n  var blue = arColor[2];\n  for(red; red <= 256.01; red = red + difColorRed){\n    tempColor[0] = Math.floor(red);\n    tempColor[1] = Math.floor(green);\n    tempColor[2] = Math.floor(blue);\n    arRBA[i] = hexArrayInRgbString(tempColor);\n    green = green - difColorGreen;\n    blue = blue - difColorBlue;\n    i++;\n  }\n  console.log(arRBA);\n  return arRBA;\n}\n\n/*\n * Block functions for sectors\n * */\n\nfunction createSectorNew(sector_id, beginAngle, endAngle, circle_id, numLayers, color) {\n  var i;\n\n  var sector_id = sector_id;\n  var beginAngle = beginAngle;\n  var endAngle = endAngle;\n  var circle_id = circle_id;\n  var numLayers = numLayers;\n  var color = color;\n\n  var arColors = changeColorLayers(color,numLayers);\n  var difRadius = bigRadius/numLayers;\n  var radius = bigRadius;\n\n  var nameArc = 'mainArc_'+sector_id;\n  var nameSector = 'main_sector_'+sector_id;\n  var nameGroup = 'sector_'+sector_id;\n  var canvas = $('canvas');\n\n  for(i=1;i<=numLayers;i++){\n    canvas.drawSlice({\n      layer: true,\n      mask: true,\n      groups: [nameGroup],\n      fillStyle: arColors[i-1],\n      x: CenterX, y: CenterY,\n      start: beginAngle,\n      end: endAngle,\n      radius: radius,\n      strokeStyle: '#f60',\n      strokeWidth: 3,\n    }).restoreCanvas({\n      layer: true\n    });\n\n    radius = radius - difRadius;\n  }\n\n  canvas.drawSlice({\n    layer: true,\n    mask: true,\n    x: CenterX, y: CenterY,\n    start: beginAngle,\n    end: endAngle,\n    name: nameSector,\n    groups: [nameGroup],\n    circle_id: circle_id,\n    sector_id: sector_id,\n    radius: bigRadius,\n    numLayers : numLayers,\n    color : color,\n    dblclick: function(layer) {\n      var polar = cartesian2Polar(layer.eventX, layer.eventY);\n      var link = $('#create_label_link').attr('href','/app_dev.php/notes/new/'+layer.circle_id+'?radius='+polar.distance/bigRadius+'&degr='+polar.degr);\n      link.removeClass( \"btn-primary\" ).addClass( \"btn-danger\" );\n      link.text('    ');\n    },\n    click: function(layer) {\n      $('canvas').drawArc({\n        shadowBlur: 40,\n        shadowColor: 'white',\n        strokeStyle: 'white',\n        name: nameArc,\n        groups: [nameGroup],\n        strokeWidth: 3,\n        x: CenterX, y: CenterY,\n        radius: bigRadius,\n        start: beginAngle,\n        end: endAngle,\n      }).restoreCanvas({\n        layer: true\n      });\n    },\n    mouseout: function(layer) {\n      $('canvas').setLayer(nameArc, {\n        shadowBlur: 0\n      }).drawLayer();\n    }\n  });\n\n  canvas.restoreCanvas({\n    layer: true\n  });\n}\n\nfunction createBorderSector(data) {\n  var endCoord = cartesian2DecForBorder(bigRadius, data.beginAngle);\n  $('canvas').drawVector({\n    strokeStyle: 'white',\n    strokeWidth: 4,\n    x: CenterX, y: CenterY,\n    a1: endCoord.X, l1: endCoord.Y\n  });\n}\n\nfunction borderForSector(angle, sectorLeftId, sectorRightId, angleMin, angelMax) {\n  var LabelCoord = cartesian2Dec(bigRadius, angle);\n  var leftCoord = cartesian2Dec(bigRadius, angleMin+5);\n  var rightCoord = cartesian2Dec(bigRadius, angelMax-5);\n  $('canvas').drawArc({\n    layer: true,\n    draggable: true,\n    sectorLeftId: sectorLeftId,\n    sectorRightId: sectorRightId,\n    name: 'border_'+sectorLeftId+'_'+sectorRightId,\n    fillStyle: 'yellow',\n    x: LabelCoord.X, y: LabelCoord.Y,\n    radius: radiusLabel,\n    circlePath: true,\n    circleRadius: bigRadius,\n    circleCenterX: CenterX,\n    circleCenterY: CenterY,\n    xMin: leftCoord.X, yMin: leftCoord.Y,\n    xMax: rightCoord.X, yMax: rightCoord.Y,\n    data: {'sectorLeft': sectorLeftId , 'sectorRight': sectorRightId},\n    shadowColor: shadowColor,\n    shadowBlur: shadowLabelSize,\n    dragstop: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n      var sectorLeft = $('canvas').getLayer( 'main_sector_'+layer.sectorLeftId);\n      var sectorRight = $('canvas').getLayer('main_sector_'+layer.sectorRightId);\n\n      var circleId = sectorLeft.circle_id;\n      var numLayers = sectorLeft.numLayers;\n\n      var beginAngleL = sectorLeft.start;\n      var colorL = sectorLeft.color;\n\n      var endAngleR = sectorRight.end;\n      var colorR = sectorRight.color;\n\n      var newLeftSectorMinAngle = sectorLeft.start;\n      var newRightSectorMinAngle = pol.degr;\n      var oldLeftSectorMinAngle = sectorLeft.start;\n      var oldRightSectorMinAngle = sectorRight.start;\n      var coefficientLeft = (pol.degr - beginAngleL)/(sectorLeft.end - sectorLeft.start);\n      var coefficientRight = (endAngleR - pol.degr)/(sectorRight.end - sectorRight.start);\n\n      updateLabelPositionByChangingSector(layer,coefficientLeft,coefficientRight,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle);\n\n      $('canvas').removeLayerGroup('sector_'+sectorLeftId);\n      createSectorNew(sectorLeftId,beginAngleL,pol.degr, circleId, numLayers, colorL);\n\n      $('canvas').removeLayerGroup('sector_'+sectorRightId);\n      createSectorNew(sectorRightId,pol.degr,endAngleR, circleId, numLayers, colorR);\n\n      setHightMoveLayerToLayer();\n    },\n    drag: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n\n      $('canvas').drawVector({\n        strokeStyle: 'white',\n        strokeWidth: 4,\n        x: CenterX, y: CenterY,\n        a1: pol.degr, l1: pol.distance\n      });\n    },\n    mouseover: function(layer) {\n      $('canvas').drawVector({\n        strokeStyle: 'white',\n        strokeWidth: 4,\n        x: CenterX, y: CenterY,\n        a1: angle, l1: bigRadius\n      });\n    },\n    mouseout: function(layer) {\n      // var Label = $('canvas').getLayer(layer.name);\n      // Label.fillStyle = colorLabel;\n      // delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    dblclick: function(layer) {\n      // $('#pop_label_link').css('display','block').attr('href','/app_dev.php/notes/list/'+layer.data.circleId+'/'+layer.data.id+'/');\n    },\n  });\n}\n\n/*\n* Block functions for labels\n* */\n\nfunction rayAndCircleByLabel(layer,id) {\n  var pol = cartesian2Polar(layer.x, layer.y);\n  var dec = cartesian2Dec(bigRadius*2,pol.degr);\n  $('canvas').drawArc({\n    layer: true,\n    strokeStyle: colorRayAndCircleByLabel,\n    strokeWidth: 3,\n    name: 'circleByLabel'+id,\n    groups: ['circleByLabel'],\n    x: CenterX, y: CenterY,\n    radius: pol.distance,\n  });\n  $('canvas').drawLine({\n    layer: true,\n    strokeWidth: 3,\n    name: 'lineByLabel'+id,\n    groups: ['lineByLabel'],\n    strokeStyle: colorRayAndCircleByLabel,\n    x1: CenterX, y1: CenterY,\n    x2: dec.X, y2: dec.Y,\n  });\n}\n\nfunction createNamePopUpLabel(id,x,y,text) {\n  var heightPopUp = 30;\n  var widthPopUp = 150;\n\n  $('canvas').drawRect({\n    layer: true,\n    fillStyle: 'white',\n    strokeStyle: '#c33',\n    strokeWidth: 2,\n    name: 'nameLabelPopup'+id,\n    groups: ['nameLabelPopup'],\n    x: x + widthPopUp/2, y: y - heightPopUp/2 - 10,\n    width: widthPopUp,\n    height: heightPopUp,\n    cornerRadius: 10\n  });\n  $('canvas').drawText({\n    layer: true,\n    name: 'nameLabelPopupText'+id,\n    groups: ['nameLabelPopupText'],\n    fillStyle: 'black',\n    strokeWidth: 2,\n    x: x + widthPopUp/2, y: y - heightPopUp/2 - 10,\n    fontSize: '10pt',\n    fontFamily: 'Verdana, sans-serif',\n    maxWidth: widthPopUp,\n    text: text\n  })\n}\n\n\nfunction createLabel(data) {\n  var LabelCoord = cartesian2Dec(data.radius*bigRadius, data.degr);\n  // console.log(data.radius);\n  $('canvas').drawArc({\n    layer: true,\n    draggable: true,\n    groups: ['note_labels'],\n    name: 'myLabel'+data.id,\n    fillStyle: colorLabel,\n    x: LabelCoord.X, y: LabelCoord.Y,\n    radius: radiusLabel,\n    data: {'id' : data.id, 'name': data.name , 'circleId': data.circleId},\n    label_radius: data.radius,\n    label_angle: data.degr,\n    label_id: data.id,\n    shadowColor: shadowColor,\n    shadowBlur: shadowLabelSize,\n    dragstop: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n      var dec = cartesian2Dec(pol.distance,pol.degr);\n\n      layer.label_radius = pol.distance/bigRadius;\n      layer.label_angle = pol.degr;\n      // console.log(layer.label_radius,layer.label_angle);\n\n      updateCoordinateLabel(layer.data.circleId,layer.data.id,pol.distance/bigRadius,pol.degr);\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    drag: function(layer) {\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n      rayAndCircleByLabel(layer,layer.data.id);\n    },\n    mouseover: function(layer) {\n      var Label = $('canvas').getLayer(layer.name);\n      Label.fillStyle = colorSelectLabel;\n      delRayNamePopUpAndCircleAllLabels();\n      rayAndCircleByLabel(layer,layer.data.id);\n      setLinkLabelsByRadiusAndAngle(layer.label_radius,layer.label_angle, layer.label_id);\n      createNamePopUpLabel(layer.data.id,layer.x,layer.y,layer.data.name);\n    },\n    mouseout: function(layer) {\n      var Label = $('canvas').getLayer(layer.name);\n      Label.fillStyle = colorLabel;\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n      removeLinkLabelsByRadiusAndAngle(layer.label_radius,layer.label_angle, layer.label_id);\n    },\n    dblclick: function(layer) {\n      $('#pop_label_link').css('display','block').attr('href','/app_dev.php/notes/list/'+layer.data.circleId+'/'+layer.data.id+'/');\n    },\n  });\n}\n\nfunction setHightMoveLayerToLayer(){\n  // Returns an array containing all draggable layers\n  var dragLayers = $('canvas').getLayers(function(layer) {\n    return (layer.draggable === true);\n  });\n\n  function setMoveLayerToLayer(layer, index, array) {\n    $('canvas').moveLayer(layer.name, 100);\n  }\n  dragLayers.forEach(setMoveLayerToLayer);\n}\n\nfunction setLinkLabelsByRadiusAndAngle(radius, angle, label_id){\n  var labels = $('canvas').getLayerGroup('note_labels');\n  var radiusBorderMin = radius - 0.05;\n  var radiusBorderMax = radius + 0.05;\n  var angleBorderMin = angle - 10;\n  var angleBorderMax = angle + 10;\n  // console.log(radiusBorderMin,radiusBorderMax,angleBorderMin,angleBorderMax);\n\n  function setFillStyleToLayer(layer, index, array) {\n    if(layer.id !== label_id){\n      if((layer.label_angle > angleBorderMin && layer.label_angle < angleBorderMax)\n          || (layer.label_radius > radiusBorderMin && layer.label_radius < radiusBorderMax) ){\n        // console.log(layer.label_angle,layer.label_radius);\n        createNamePopUpLabel(layer.label_id,layer.x,layer.y,layer.data.name);\n        layer.fillStyle = colorSelectLabel;\n      }\n    }\n  }\n  labels.forEach(setFillStyleToLayer);\n}\n\nfunction removeLinkLabelsByRadiusAndAngle(radius, angle, label_id){\n  var labels = $('canvas').getLayerGroup('note_labels');\n  var radiusBorderMin = radius - 0.03;\n  var radiusBorderMax = radius + 0.03;\n  var angleBorderMin = angle - 10;\n  var angleBorderMax = angle + 10;\n  // console.log(radiusBorderMin,radiusBorderMax,angleBorderMin,angleBorderMax);\n\n  function deleteFillStyleToLayer(layer, index, array) {\n    if(layer.label_id !== label_id){\n      if((layer.label_angle > angleBorderMin && layer.label_angle < angleBorderMax)\n          || (layer.label_radius > radiusBorderMin && layer.label_radius < radiusBorderMax) ){\n        // console.log(layer.label_angle,layer.label_radius);\n        layer.fillStyle = colorLabel;\n        delNamePopUpByLabel(layer.label_id);\n      }\n    }\n  }\n  labels.forEach(deleteFillStyleToLayer);\n}\n\nfunction updateLabelPositionByChangingSector(border,coefficientLeft,coefficientRight,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle) {\n  var sector_left = $('canvas').getLayer('main_sector_'+border.sectorLeftId);\n  var sector_right = $('canvas').getLayer('main_sector_'+border.sectorRightId);\n  var labels = $('canvas').getLayerGroup('note_labels');\n\n  if(typeof labels !== 'undefined'){\n    function updateLabelPosition(label, index, array) {\n\n      if(label.label_angle > sector_left.start && label.label_angle < sector_left.end){\n        var newAngle = (label.label_angle-oldLeftSectorMinAngle)*coefficientLeft+newLeftSectorMinAngle;\n        var LabelCoord = cartesian2Dec(label.label_radius*bigRadius, newAngle);\n        label.x = LabelCoord.X;\n        label.y = LabelCoord.Y;\n        console.log(label.name,label.label_angle,newAngle,sector_left,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle,coefficientLeft);\n        label.label_angle = newAngle;\n      }else if(label.label_angle > sector_right.start && label.label_angle < sector_right.end){\n        var newAngle = (label.label_angle-oldRightSectorMinAngle)*coefficientRight+newRightSectorMinAngle;\n        var LabelCoord = cartesian2Dec(label.label_radius*bigRadius, newAngle);\n        label.x = LabelCoord.X;\n        label.y = LabelCoord.Y;\n        label.label_angle = newAngle;\n      }\n    }\n    labels.forEach(updateLabelPosition);\n  }\n\n  // console.log(sector_left,sector_right);\n}\n\n\nfunction updateCoordinateLabel(circleId,labelId,radius,angle) {\n  $.post(\n      \"/app_dev.php/circle/editLabelAjax\",\n      {\n        circleId: circleId,\n        labelId:labelId,\n        radius:radius,\n        angle:angle\n      }).done(\n      function (data) {\n        console.log(data);\n\n      })\n}\n\nfunction delRayNamePopUpAndCircleByLabel(id) {\n  $('canvas').removeLayer('circleByLabel'+id);\n  $('canvas').removeLayer('lineByLabel'+id);\n  $('canvas').removeLayer('nameLabelPopup'+id);\n  $('canvas').removeLayer('nameLabelPopupText'+id);\n}\n\nfunction delNamePopUpByLabel(id) {\n  $('canvas').removeLayer('nameLabelPopup'+id);\n  $('canvas').removeLayer('nameLabelPopupText'+id);\n}\n\nfunction delRayNamePopUpAndCircleAllLabels() {\n  $('canvas').removeLayerGroup('circleByLabel');\n  $('canvas').removeLayerGroup('lineByLabel');\n  $('canvas').removeLayerGroup('nameLabelPopup');\n  $('canvas').removeLayerGroup('nameLabelPopupText');\n}","/*\n* block for creating sectors\n* */\n\n// setup an \"add a tag\" link\n//btn btn-primary btn-block\nvar $addTagLink = $('<a href=\"#\" class=\"btn btn-primary btn-block\"> </a>');\nvar $newLinkLi = $('<div></div>').append($addTagLink);\n\njQuery(document).ready(function() {\n  // Get the ul that holds the collection of tags\n  var $collectionHolder = $('div.sectors');\n\n  if (typeof $collectionHolder.html() !== 'undefined'){\n    // add the \"add a tag\" anchor and li to the tags ul\n    $collectionHolder.append($newLinkLi);\n\n// TODO add when logic for delete sector will be ready\n//         // add a delete link to all of the existing tag form li elements\n//         $collectionHolder.find('li').each(function() {\n//           addTagFormDeleteLink($(this));\n//         });\n\n    // count the current form inputs we have (e.g. 2), use that as the new\n    // index when inserting a new item (e.g. 2)\n    $collectionHolder.data('index', $collectionHolder.find(':input').length);\n\n    $addTagLink.on('click', function(e) {\n      // prevent the link from creating a \"#\" on the URL\n      e.preventDefault();\n\n      // add a new tag form (see code block below)\n      addTagForm($collectionHolder, $newLinkLi);\n    });\n  }\n\n});\n\nfunction addTagForm($collectionHolder, $newLinkLi) {\n  // Get the data-prototype explained earlier\n  var prototype = $collectionHolder.data('prototype');\n\n  // get the new index\n  var index = $collectionHolder.data('index');\n\n  // Replace '$$name$$' in the prototype's HTML to\n  // instead be a number based on how many items we have\n  var newForm = prototype.replace(/__name__/g, index);\n\n  // increase the index with one for the next item\n  $collectionHolder.data('index', index + 1);\n\n  // Display the form in the page in an li, before the \"Add a tag\" link li\n  var $newFormLi = $(newForm);\n\n  // also add a remove button, just for this example\n  $newFormLi.append('<button class=\"remove-tag btn btn-danger\"><i class=\"fa fa-remove fa-lg\"></i></button>');\n\n  $newLinkLi.before($newFormLi);\n\n  // handle the removal, just for this example\n  $('.remove-tag').click(function(e) {\n    e.preventDefault();\n\n    $(this).parent().remove();\n\n    return false;\n  });\n\n//         // add a delete link to the new form\n//         addTagFormDeleteLink($newFormLi);\n}\n\nfunction addTagFormDeleteLink($tagFormLi) {\n  var $removeFormA = $('<a href=\"#\">delete this tag</a>');\n  $tagFormLi.append($removeFormA);\n\n  $removeFormA.on('click', function(e) {\n    // prevent the link from creating a \"#\" on the URL\n    e.preventDefault();\n\n    // remove the li for the tag form\n    $tagFormLi.remove();\n  });\n}","function getNoteContent(noteId) {\n  var host = \"http://\" + window.location.hostname + ':' + window.location.port;\n  $.ajax({\n    url: typeof isLocalDev !== \"undefined\" ? host + \"/note/api/data.json\" : host + \"/note/api/\"+noteId+\"/\",\n    type: 'get',\n    success:   function (data) {\n      document.getElementById('note_view_title').innerHTML = data.title;\n      document.getElementById('note_view_text').innerHTML = data.text;\n      document.getElementById('note_edit_link').href = typeof isLocalDev !== \"undefined\" ? host + \"/notes_edit.html\" : host + \"/note/view/\"+data.id+\"/\";\n    },\n    error: function (err) {\n\n    }\n  });\n}\n\njQuery(document).ready(function() {\n  setDisabledToRange();\n  $(\"#note_category\").change(function() {\n    setDisabledToRange();\n  });\n});\n\nfunction setDisabledToRange() {\n  var selsectCategory = $('#note_category').val();\n  if(selsectCategory === \"\"){\n    $('#note_noteLabel_radius').attr(\"disabled\",true);\n  }else{\n    $('#note_noteLabel_radius').attr(\"disabled\",false);\n  }\n}","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","/**\n * @license jCanvas v20.1.4\n * Copyright 2017 Caleb Evans\n * Released under the MIT license\n */\n(function (jQuery, global, factory) {\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = function (jQuery, w) {\n      return factory(jQuery, w);\n    };\n  } else {\n    factory(jQuery, global);\n  }\n\n// Pass this if window is not defined yet\n}(typeof window !== 'undefined' ? window.jQuery : {}, typeof window !== 'undefined' ? window : this, function ($, window) {\n  'use strict';\n\n  var document = window.document,\n      Image = window.Image,\n      Array = window.Array,\n      getComputedStyle = window.getComputedStyle,\n      Math = window.Math,\n      Number = window.Number,\n      parseFloat = window.parseFloat;\n\n// Define local aliases to frequently used properties\n  var defaults,\n      // Aliases to jQuery methods\n      extendObject = $.extend,\n      inArray = $.inArray,\n      typeOf = function (operand) {\n        return Object.prototype.toString.call(operand)\n            .slice(8, -1).toLowerCase();\n      },\n      isFunction = $.isFunction,\n      isPlainObject = $.isPlainObject,\n      // Math constants and functions\n      PI = Math.PI,\n      round = Math.round,\n      abs = Math.abs,\n      sin = Math.sin,\n      cos = Math.cos,\n      atan2 = Math.atan2,\n      // The Array slice() method\n      arraySlice = Array.prototype.slice,\n      // jQuery's internal event normalization function\n      jQueryEventFix = $.event.fix,\n      // Object for storing a number of internal property maps\n      maps = {},\n      // jQuery internal caches\n      caches = {\n        dataCache: {},\n        propCache: {},\n        imageCache: {}\n      },\n      // Base transformations\n      baseTransforms = {\n        rotate: 0,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        // Store all previous masks\n        masks: []\n      },\n      // Object for storing CSS-related properties\n      css = {},\n      tangibleEvents = [\n        'mousedown',\n        'mousemove',\n        'mouseup',\n        'mouseover',\n        'mouseout',\n        'touchstart',\n        'touchmove',\n        'touchend'\n      ];\n\n// Constructor for creating objects that inherit from jCanvas preferences and defaults\n  function jCanvasObject(args) {\n    var params = this,\n        propName;\n    // Copy the given parameters into new object\n    for (propName in args) {\n      // Do not merge defaults into parameters\n      if (Object.prototype.hasOwnProperty.call(args, propName)) {\n        params[propName] = args[propName];\n      }\n    }\n    return params;\n  }\n\n// jCanvas object in which global settings are other data are stored\n  var jCanvas = {\n    // Events object for storing jCanvas event initiation functions\n    events: {},\n    // Object containing all jCanvas event hooks\n    eventHooks: {},\n    // Settings for enabling future jCanvas features\n    future: {}\n  };\n\n// jCanvas default property values\n  function jCanvasDefaults() {\n    extendObject(this, jCanvasDefaults.baseDefaults);\n  }\n  jCanvasDefaults.baseDefaults = {\n    align: 'center',\n    arrowAngle: 90,\n    arrowRadius: 0,\n    autosave: true,\n    baseline: 'middle',\n    bringToFront: false,\n    ccw: false,\n    closed: false,\n    compositing: 'source-over',\n    concavity: 0,\n    cornerRadius: 0,\n    count: 1,\n    cropFromCenter: true,\n    crossOrigin: null,\n    cursors: null,\n    disableEvents: false,\n    draggable: false,\n    dragGroups: null,\n    groups: null,\n    data: null,\n    dx: null,\n    dy: null,\n    end: 360,\n    eventX: null,\n    eventY: null,\n    fillStyle: 'transparent',\n    fontStyle: 'normal',\n    fontSize: '12pt',\n    fontFamily: 'sans-serif',\n    fromCenter: true,\n    height: null,\n    imageSmoothing: true,\n    inDegrees: true,\n    intangible: false,\n    index: null,\n    letterSpacing: null,\n    lineHeight: 1,\n    layer: false,\n    mask: false,\n    maxWidth: null,\n    miterLimit: 10,\n    name: null,\n    opacity: 1,\n    r1: null,\n    r2: null,\n    radius: 0,\n    repeat: 'repeat',\n    respectAlign: false,\n    restrictDragToAxis: null,\n    rotate: 0,\n    rounded: false,\n    scale: 1,\n    scaleX: 1,\n    scaleY: 1,\n    shadowBlur: 0,\n    shadowColor: 'transparent',\n    shadowStroke: false,\n    shadowX: 0,\n    shadowY: 0,\n    sHeight: null,\n    sides: 0,\n    source: '',\n    spread: 0,\n    start: 0,\n    strokeCap: 'butt',\n    strokeDash: null,\n    strokeDashOffset: 0,\n    strokeJoin: 'miter',\n    strokeStyle: 'transparent',\n    strokeWidth: 1,\n    sWidth: null,\n    sx: null,\n    sy: null,\n    text: '',\n    translate: 0,\n    translateX: 0,\n    translateY: 0,\n    type: null,\n    visible: true,\n    width: null,\n    x: 0,\n    y: 0\n  };\n  defaults = new jCanvasDefaults();\n  jCanvasObject.prototype = defaults;\n\n  /* Internal helper methods */\n\n// Determines if the given operand is a string\n  function isString(operand) {\n    return (typeOf(operand) === 'string');\n  }\n\n// Determines if the given operand is numeric\n  function isNumeric(operand) {\n    return !isNaN(Number(operand)) && !isNaN(parseFloat(operand));\n  }\n\n// Get 2D context for the given canvas\n  function _getContext(canvas) {\n    return (canvas && canvas.getContext ? canvas.getContext('2d') : null);\n  }\n\n// Coerce designated number properties from strings to numbers\n  function _coerceNumericProps(props) {\n    var propName, propType, propValue;\n    // Loop through all properties in given property map\n    for (propName in props) {\n      if (Object.prototype.hasOwnProperty.call(props, propName)) {\n        propValue = props[propName];\n        propType = typeOf(propValue);\n        // If property is non-empty string and value is numeric\n        if (propType === 'string' && isNumeric(propValue) && propName !== 'text') {\n          // Convert value to number\n          props[propName] = parseFloat(propValue);\n        }\n      }\n    }\n    // Ensure value of text property is always a string\n    if (props.text !== undefined) {\n      props.text = String(props.text);\n    }\n  }\n\n// Clone the given transformations object\n  function _cloneTransforms(transforms) {\n    // Clone the object itself\n    transforms = extendObject({}, transforms);\n    // Clone the object's masks array\n    transforms.masks = transforms.masks.slice(0);\n    return transforms;\n  }\n\n// Save canvas context and update transformation stack\n  function _saveCanvas(ctx, data) {\n    var transforms;\n    ctx.save();\n    transforms = _cloneTransforms(data.transforms);\n    data.savedTransforms.push(transforms);\n  }\n\n// Restore canvas context update transformation stack\n  function _restoreCanvas(ctx, data) {\n    if (data.savedTransforms.length === 0) {\n      // Reset transformation state if it can't be restored any more\n      data.transforms = _cloneTransforms(baseTransforms);\n    } else {\n      // Restore canvas context\n      ctx.restore();\n      // Restore current transform state to the last saved state\n      data.transforms = data.savedTransforms.pop();\n    }\n  }\n\n// Set the style with the given name\n  function _setStyle(canvas, ctx, params, styleName) {\n    if (params[styleName]) {\n      if (isFunction(params[styleName])) {\n        // Handle functions\n        ctx[styleName] = params[styleName].call(canvas, params);\n      } else {\n        // Handle string values\n        ctx[styleName] = params[styleName];\n      }\n    }\n  }\n\n// Set canvas context properties\n  function _setGlobalProps(canvas, ctx, params) {\n    _setStyle(canvas, ctx, params, 'fillStyle');\n    _setStyle(canvas, ctx, params, 'strokeStyle');\n    ctx.lineWidth = params.strokeWidth;\n    // Optionally round corners for paths\n    if (params.rounded) {\n      ctx.lineCap = ctx.lineJoin = 'round';\n    } else {\n      ctx.lineCap = params.strokeCap;\n      ctx.lineJoin = params.strokeJoin;\n      ctx.miterLimit = params.miterLimit;\n    }\n    // Reset strokeDash if null\n    if (!params.strokeDash) {\n      params.strokeDash = [];\n    }\n    // Dashed lines\n    if (ctx.setLineDash) {\n      ctx.setLineDash(params.strokeDash);\n    }\n    ctx.webkitLineDash = params.strokeDash;\n    ctx.lineDashOffset = ctx.webkitLineDashOffset = ctx.mozDashOffset = params.strokeDashOffset;\n    // Drop shadow\n    ctx.shadowOffsetX = params.shadowX;\n    ctx.shadowOffsetY = params.shadowY;\n    ctx.shadowBlur = params.shadowBlur;\n    ctx.shadowColor = params.shadowColor;\n    // Opacity and composite operation\n    ctx.globalAlpha = params.opacity;\n    ctx.globalCompositeOperation = params.compositing;\n    // Support cross-browser toggling of image smoothing\n    if (params.imageSmoothing) {\n      ctx.imageSmoothingEnabled = params.imageSmoothing;\n    }\n  }\n\n// Optionally enable masking support for this path\n  function _enableMasking(ctx, data, params) {\n    if (params.mask) {\n      // If jCanvas autosave is enabled\n      if (params.autosave) {\n        // Automatically save transformation state by default\n        _saveCanvas(ctx, data);\n      }\n      // Clip the current path\n      ctx.clip();\n      // Keep track of current masks\n      data.transforms.masks.push(params._args);\n    }\n  }\n\n// Restore individual shape transformation\n  function _restoreTransform(ctx, params) {\n    // If shape has been transformed by jCanvas\n    if (params._transformed) {\n      // Restore canvas context\n      ctx.restore();\n    }\n  }\n\n// Close current canvas path\n  function _closePath(canvas, ctx, params) {\n    var data;\n\n    // Optionally close path\n    if (params.closed) {\n      ctx.closePath();\n    }\n\n    if (params.shadowStroke && params.strokeWidth !== 0) {\n      // Extend the shadow to include the stroke of a drawing\n\n      // Add a stroke shadow by stroking before filling\n      ctx.stroke();\n      ctx.fill();\n      // Ensure the below stroking does not inherit a shadow\n      ctx.shadowColor = 'transparent';\n      ctx.shadowBlur = 0;\n      // Stroke over fill as usual\n      ctx.stroke();\n\n    } else {\n      // If shadowStroke is not enabled, stroke & fill as usual\n\n      ctx.fill();\n      // Prevent extra shadow created by stroke (but only when fill is present)\n      if (params.fillStyle !== 'transparent') {\n        ctx.shadowColor = 'transparent';\n      }\n      if (params.strokeWidth !== 0) {\n        // Only stroke if the stroke is not 0\n        ctx.stroke();\n      }\n\n    }\n\n    // Optionally close path\n    if (!params.closed) {\n      ctx.closePath();\n    }\n\n    // Restore individual shape transformation\n    _restoreTransform(ctx, params);\n\n    // Mask shape if chosen\n    if (params.mask) {\n      // Retrieve canvas data\n      data = _getCanvasData(canvas);\n      _enableMasking(ctx, data, params);\n    }\n\n  }\n\n// Transform (translate, scale, or rotate) shape\n  function _transformShape(canvas, ctx, params, width, height) {\n\n    // Get conversion factor for radians\n    params._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n    params._transformed = true;\n    ctx.save();\n\n    // Optionally measure (x, y) position from top-left corner\n    if (!params.fromCenter && !params._centered && width !== undefined) {\n      // Always draw from center unless otherwise specified\n      if (height === undefined) {\n        height = width;\n      }\n      params.x += width / 2;\n      params.y += height / 2;\n      params._centered = true;\n    }\n    // Optionally rotate shape\n    if (params.rotate) {\n      _rotateCanvas(ctx, params, null);\n    }\n    // Optionally scale shape\n    if (params.scale !== 1 || params.scaleX !== 1 || params.scaleY !== 1) {\n      _scaleCanvas(ctx, params, null);\n    }\n    // Optionally translate shape\n    if (params.translate || params.translateX || params.translateY) {\n      _translateCanvas(ctx, params, null);\n    }\n\n  }\n\n  /* Plugin API */\n\n// Extend jCanvas with a user-defined method\n  jCanvas.extend = function extend(plugin) {\n\n    // Create plugin\n    if (plugin.name) {\n      // Merge properties with defaults\n      if (plugin.props) {\n        extendObject(defaults, plugin.props);\n      }\n      // Define plugin method\n      $.fn[plugin.name] = function self(args) {\n        var $canvases = this, canvas, e, ctx,\n            params;\n\n        for (e = 0; e < $canvases.length; e += 1) {\n          canvas = $canvases[e];\n          ctx = _getContext(canvas);\n          if (ctx) {\n\n            params = new jCanvasObject(args);\n            _addLayer(canvas, params, args, self);\n\n            _setGlobalProps(canvas, ctx, params);\n            plugin.fn.call(canvas, ctx, params);\n\n          }\n        }\n        return $canvases;\n      };\n      // Add drawing type to drawing map\n      if (plugin.type) {\n        maps.drawings[plugin.type] = plugin.name;\n      }\n    }\n    return $.fn[plugin.name];\n  };\n\n  /* Layer API */\n\n// Retrieved the stored jCanvas data for a canvas element\n  function _getCanvasData(canvas) {\n    var dataCache = caches.dataCache, data;\n    if (dataCache._canvas === canvas && dataCache._data) {\n\n      // Retrieve canvas data from cache if possible\n      data = dataCache._data;\n\n    } else {\n\n      // Retrieve canvas data from jQuery's internal data storage\n      data = $.data(canvas, 'jCanvas');\n      if (!data) {\n\n        // Create canvas data object if it does not already exist\n        data = {\n          // The associated canvas element\n          canvas: canvas,\n          // Layers array\n          layers: [],\n          // Layer maps\n          layer: {\n            names: {},\n            groups: {}\n          },\n          eventHooks: {},\n          // All layers that intersect with the event coordinates (regardless of visibility)\n          intersecting: [],\n          // The topmost layer whose area contains the event coordinates\n          lastIntersected: null,\n          cursor: $(canvas).css('cursor'),\n          // Properties for the current drag event\n          drag: {\n            layer: null,\n            dragging: false\n          },\n          // Data for the current event\n          event: {\n            type: null,\n            x: null,\n            y: null\n          },\n          // Events which already have been bound to the canvas\n          events: {},\n          // The canvas's current transformation state\n          transforms: _cloneTransforms(baseTransforms),\n          savedTransforms: [],\n          // Whether a layer is being animated or not\n          animating: false,\n          // The layer currently being animated\n          animated: null,\n          // The device pixel ratio\n          pixelRatio: 1,\n          // Whether pixel ratio transformations have been applied\n          scaled: false,\n          // Whether the canvas should be redrawn when a layer mousemove\n          // event triggers (either directly, or indirectly via dragging)\n          redrawOnMousemove: false\n        };\n        // Use jQuery to store canvas data\n        $.data(canvas, 'jCanvas', data);\n\n      }\n      // Cache canvas data for faster retrieval\n      dataCache._canvas = canvas;\n      dataCache._data = data;\n\n    }\n    return data;\n  }\n\n// Initialize all of a layer's associated jCanvas events\n  function _addLayerEvents($canvas, data, layer) {\n    var eventName;\n    // Determine which jCanvas events need to be bound to this layer\n    for (eventName in jCanvas.events) {\n      if (Object.prototype.hasOwnProperty.call(jCanvas.events, eventName)) {\n        // If layer has callback function to complement it\n        if (layer[eventName] || (layer.cursors && layer.cursors[eventName])) {\n          // Bind event to layer\n          _addExplicitLayerEvent($canvas, data, layer, eventName);\n        }\n      }\n    }\n    if (!data.events.mouseout) {\n      $canvas.bind('mouseout.jCanvas', function () {\n        // Retrieve the layer whose drag event was canceled\n        var layer = data.drag.layer, l;\n        // If cursor mouses out of canvas while dragging\n        if (layer) {\n          // Cancel drag\n          data.drag = {};\n          _triggerLayerEvent($canvas, data, layer, 'dragcancel');\n        }\n        // Loop through all layers\n        for (l = 0; l < data.layers.length; l += 1) {\n          layer = data.layers[l];\n          // If layer thinks it's still being moused over\n          if (layer._hovered) {\n            // Trigger mouseout on layer\n            $canvas.triggerLayerEvent(data.layers[l], 'mouseout');\n          }\n        }\n        // Redraw layers\n        $canvas.drawLayers();\n      });\n      // Indicate that an event handler has been bound\n      data.events.mouseout = true;\n    }\n  }\n\n// Initialize the given event on the given layer\n  function _addLayerEvent($canvas, data, layer, eventName) {\n    // Use touch events if appropriate\n    // eventName = _getMouseEventName(eventName);\n    // Bind event to layer\n    jCanvas.events[eventName]($canvas, data);\n    layer._event = true;\n  }\n\n// Add a layer event that was explicitly declared in the layer's parameter map,\n// excluding events added implicitly (e.g. mousemove event required by draggable\n// layers)\n  function _addExplicitLayerEvent($canvas, data, layer, eventName) {\n    _addLayerEvent($canvas, data, layer, eventName);\n    if (eventName === 'mouseover' || eventName === 'mouseout' || eventName === 'mousemove') {\n      data.redrawOnMousemove = true;\n    }\n  }\n\n// Enable drag support for this layer\n  function _enableDrag($canvas, data, layer) {\n    var dragHelperEvents, eventName, i;\n    // Only make layer draggable if necessary\n    if (layer.draggable || layer.cursors) {\n\n      // Organize helper events which enable drag support\n      dragHelperEvents = ['mousedown', 'mousemove', 'mouseup'];\n\n      // Bind each helper event to the canvas\n      for (i = 0; i < dragHelperEvents.length; i += 1) {\n        // Use touch events if appropriate\n        eventName = dragHelperEvents[i];\n        // Bind event\n        _addLayerEvent($canvas, data, layer, eventName);\n      }\n      // Indicate that this layer has events bound to it\n      layer._event = true;\n\n    }\n  }\n\n// Update a layer property map if property is changed\n  function _updateLayerName($canvas, data, layer, props) {\n    var nameMap = data.layer.names;\n\n    // If layer name is being added, not changed\n    if (!props) {\n\n      props = layer;\n\n    } else {\n\n      // Remove old layer name entry because layer name has changed\n      if (props.name !== undefined && isString(layer.name) && layer.name !== props.name) {\n        delete nameMap[layer.name];\n      }\n\n    }\n\n    // Add new entry to layer name map with new name\n    if (isString(props.name)) {\n      nameMap[props.name] = layer;\n    }\n  }\n\n// Create or update the data map for the given layer and group type\n  function _updateLayerGroups($canvas, data, layer, props) {\n    var groupMap = data.layer.groups,\n        group, groupName, g,\n        index, l;\n\n    // If group name is not changing\n    if (!props) {\n\n      props = layer;\n\n    } else {\n\n      // Remove layer from all of its associated groups\n      if (props.groups !== undefined && layer.groups !== null) {\n        for (g = 0; g < layer.groups.length; g += 1) {\n          groupName = layer.groups[g];\n          group = groupMap[groupName];\n          if (group) {\n            // Remove layer from its old layer group entry\n            for (l = 0; l < group.length; l += 1) {\n              if (group[l] === layer) {\n                // Keep track of the layer's initial index\n                index = l;\n                // Remove layer once found\n                group.splice(l, 1);\n                break;\n              }\n            }\n            // Remove layer group entry if group is empty\n            if (group.length === 0) {\n              delete groupMap[groupName];\n            }\n          }\n        }\n      }\n\n    }\n\n    // Add layer to new group if a new group name is given\n    if (props.groups !== undefined && props.groups !== null) {\n\n      for (g = 0; g < props.groups.length; g += 1) {\n\n        groupName = props.groups[g];\n\n        group = groupMap[groupName];\n        if (!group) {\n          // Create new group entry if it doesn't exist\n          group = groupMap[groupName] = [];\n          group.name = groupName;\n        }\n        if (index === undefined) {\n          // Add layer to end of group unless otherwise stated\n          index = group.length;\n        }\n        // Add layer to its new layer group\n        group.splice(index, 0, layer);\n\n      }\n\n    }\n  }\n\n// Get event hooks object for the first selected canvas\n  $.fn.getEventHooks = function getEventHooks() {\n    var $canvases = this, canvas, data,\n        eventHooks = {};\n\n    if ($canvases.length !== 0) {\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      eventHooks = data.eventHooks;\n    }\n    return eventHooks;\n  };\n\n// Set event hooks for the selected canvases\n  $.fn.setEventHooks = function setEventHooks(eventHooks) {\n    var $canvases = this, e,\n        data;\n    for (e = 0; e < $canvases.length; e += 1) {\n      data = _getCanvasData($canvases[e]);\n      extendObject(data.eventHooks, eventHooks);\n    }\n    return $canvases;\n  };\n\n// Get jCanvas layers array\n  $.fn.getLayers = function getLayers(callback) {\n    var $canvases = this, canvas, data,\n        layers, layer, l,\n        matching = [];\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      // Retrieve layers array for this canvas\n      layers = data.layers;\n\n      // If a callback function is given\n      if (isFunction(callback)) {\n\n        // Filter the layers array using the callback\n        for (l = 0; l < layers.length; l += 1) {\n          layer = layers[l];\n          if (callback.call(canvas, layer)) {\n            // Add layer to array of matching layers if test passes\n            matching.push(layer);\n          }\n        }\n\n      } else {\n        // Otherwise, get all layers\n\n        matching = layers;\n\n      }\n\n    }\n    return matching;\n  };\n\n// Get a single jCanvas layer object\n  $.fn.getLayer = function getLayer(layerId) {\n    var $canvases = this, canvas,\n        data, layers, layer, l,\n        idType;\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      layers = data.layers;\n      idType = typeOf(layerId);\n\n      if (layerId && layerId.layer) {\n\n        // Return the actual layer object if given\n        layer = layerId;\n\n      } else if (idType === 'number') {\n\n        // Retrieve the layer using the given index\n\n        // Allow for negative indices\n        if (layerId < 0) {\n          layerId = layers.length + layerId;\n        }\n        // Get layer with the given index\n        layer = layers[layerId];\n\n      } else if (idType === 'regexp') {\n\n        // Get layer with the name that matches the given regex\n        for (l = 0; l < layers.length; l += 1) {\n          // Check if layer matches name\n          if (isString(layers[l].name) && layers[l].name.match(layerId)) {\n            layer = layers[l];\n            break;\n          }\n        }\n\n      } else {\n\n        // Get layer with the given name\n        layer = data.layer.names[layerId];\n\n      }\n\n    }\n    return layer;\n  };\n\n// Get all layers in the given group\n  $.fn.getLayerGroup = function getLayerGroup(groupId) {\n    var $canvases = this, canvas, data,\n        groups, groupName, group,\n        idType = typeOf(groupId);\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n\n      if (idType === 'array') {\n\n        // Return layer group if given\n        group = groupId;\n\n      } else if (idType === 'regexp') {\n\n        // Get canvas data\n        data = _getCanvasData(canvas);\n        groups = data.layer.groups;\n        // Loop through all layers groups for this canvas\n        for (groupName in groups) {\n          // Find a group whose name matches the given regex\n          if (groupName.match(groupId)) {\n            group = groups[groupName];\n            // Stop after finding the first matching group\n            break;\n          }\n        }\n\n      } else {\n\n        // Find layer group with the given group name\n        data = _getCanvasData(canvas);\n        group = data.layer.groups[groupId];\n      }\n\n    }\n    return group;\n  };\n\n// Get index of layer in layers array\n  $.fn.getLayerIndex = function getLayerIndex(layerId) {\n    var $canvases = this,\n        layers = $canvases.getLayers(),\n        layer = $canvases.getLayer(layerId);\n\n    return inArray(layer, layers);\n  };\n\n// Set properties of a layer\n  $.fn.setLayer = function setLayer(layerId, props) {\n    var $canvases = this, $canvas, e,\n        data, layer,\n        propName, propValue, propType;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      layer = $($canvases[e]).getLayer(layerId);\n      if (layer) {\n\n        // Update layer property maps\n        _updateLayerName($canvas, data, layer, props);\n        _updateLayerGroups($canvas, data, layer, props);\n\n        _coerceNumericProps(props);\n\n        // Merge properties with layer\n        for (propName in props) {\n          if (Object.prototype.hasOwnProperty.call(props, propName)) {\n            propValue = props[propName];\n            propType = typeOf(propValue);\n            if (propType === 'object' && isPlainObject(propValue)) {\n              // Clone objects\n              layer[propName] = extendObject({}, propValue);\n              _coerceNumericProps(layer[propName]);\n            } else if (propType === 'array') {\n              // Clone arrays\n              layer[propName] = propValue.slice(0);\n            } else if (propType === 'string') {\n              if (propValue.indexOf('+=') === 0) {\n                // Increment numbers prefixed with +=\n                layer[propName] += parseFloat(propValue.substr(2));\n              } else if (propValue.indexOf('-=') === 0) {\n                // Decrement numbers prefixed with -=\n                layer[propName] -= parseFloat(propValue.substr(2));\n              } else if (!isNaN(propValue) && isNumeric(propValue) && propName !== 'text') {\n                // Convert numeric values as strings to numbers\n                layer[propName] = parseFloat(propValue);\n              } else {\n                // Otherwise, set given string value\n                layer[propName] = propValue;\n              }\n            } else {\n              // Otherwise, set given value\n              layer[propName] = propValue;\n            }\n          }\n        }\n\n        // Update layer events\n        _addLayerEvents($canvas, data, layer);\n        _enableDrag($canvas, data, layer);\n\n        // If layer's properties were changed\n        if ($.isEmptyObject(props) === false) {\n          _triggerLayerEvent($canvas, data, layer, 'change', props);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Set properties of all layers (optionally filtered by a callback)\n  $.fn.setLayers = function setLayers(props, callback) {\n    var $canvases = this, $canvas, e,\n        layers, l;\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      layers = $canvas.getLayers(callback);\n      // Loop through all layers\n      for (l = 0; l < layers.length; l += 1) {\n        // Set properties of each layer\n        $canvas.setLayer(layers[l], props);\n      }\n    }\n    return $canvases;\n  };\n\n// Set properties of all layers in the given group\n  $.fn.setLayerGroup = function setLayerGroup(groupId, props) {\n    var $canvases = this, $canvas, e,\n        group, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      // Get layer group\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // If group exists\n      if (group) {\n\n        // Loop through layers in group\n        for (l = 0; l < group.length; l += 1) {\n          // Merge given properties with layer\n          $canvas.setLayer(group[l], props);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Move a layer to the given index in the layers array\n  $.fn.moveLayer = function moveLayer(layerId, index) {\n    var $canvases = this, $canvas, e,\n        data, layers, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      // Retrieve layers array and desired layer\n      layers = data.layers;\n      layer = $canvas.getLayer(layerId);\n      if (layer) {\n\n        // Ensure layer index is accurate\n        layer.index = inArray(layer, layers);\n\n        // Remove layer from its current placement\n        layers.splice(layer.index, 1);\n        // Add layer in its new placement\n        layers.splice(index, 0, layer);\n\n        // Handle negative indices\n        if (index < 0) {\n          index = layers.length + index;\n        }\n        // Update layer's stored index\n        layer.index = index;\n\n        _triggerLayerEvent($canvas, data, layer, 'move');\n\n      }\n    }\n    return $canvases;\n  };\n\n// Remove a jCanvas layer\n  $.fn.removeLayer = function removeLayer(layerId) {\n    var $canvases = this, $canvas, e, data,\n        layers, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      // Retrieve layers array and desired layer\n      layers = $canvas.getLayers();\n      layer = $canvas.getLayer(layerId);\n      // Remove layer if found\n      if (layer) {\n\n        // Ensure layer index is accurate\n        layer.index = inArray(layer, layers);\n        // Remove layer and allow it to be re-added later\n        layers.splice(layer.index, 1);\n        delete layer._layer;\n\n        // Update layer name map\n        _updateLayerName($canvas, data, layer, {\n          name: null\n        });\n        // Update layer group map\n        _updateLayerGroups($canvas, data, layer, {\n          groups: null\n        });\n\n        // Trigger 'remove' event\n        _triggerLayerEvent($canvas, data, layer, 'remove');\n\n      }\n    }\n    return $canvases;\n  };\n\n// Remove all layers\n  $.fn.removeLayers = function removeLayers(callback) {\n    var $canvases = this, $canvas, e,\n        data, layers, layer, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layers = $canvas.getLayers(callback);\n      // Remove all layers individually\n      for (l = 0; l < layers.length; l += 1) {\n        layer = layers[l];\n        $canvas.removeLayer(layer);\n        // Ensure no layer is skipped over\n        l -= 1;\n      }\n      // Update layer maps\n      data.layer.names = {};\n      data.layer.groups = {};\n    }\n    return $canvases;\n  };\n\n// Remove all layers in the group with the given ID\n  $.fn.removeLayerGroup = function removeLayerGroup(groupId) {\n    var $canvases = this, $canvas, e, group, l;\n\n    if (groupId !== undefined) {\n      for (e = 0; e < $canvases.length; e += 1) {\n        $canvas = $($canvases[e]);\n\n        group = $canvas.getLayerGroup(groupId);\n        // Remove layer group using given group name\n        if (group) {\n\n          // Clone groups array\n          group = group.slice(0);\n\n          // Loop through layers in group\n          for (l = 0; l < group.length; l += 1) {\n            $canvas.removeLayer(group[l]);\n          }\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Add an existing layer to a layer group\n  $.fn.addLayerToGroup = function addLayerToGroup(layerId, groupName) {\n    var $canvases = this, $canvas, e,\n        layer, groups = [groupName];\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n\n      // If layer is not already in group\n      if (layer.groups) {\n        // Clone groups list\n        groups = layer.groups.slice(0);\n        // If layer is not already in group\n        if (inArray(groupName, layer.groups) === -1) {\n          // Add layer to group\n          groups.push(groupName);\n        }\n      }\n      // Update layer group maps\n      $canvas.setLayer(layer, {\n        groups: groups\n      });\n\n    }\n    return $canvases;\n  };\n\n// Remove an existing layer from a layer group\n  $.fn.removeLayerFromGroup = function removeLayerFromGroup(layerId, groupName) {\n    var $canvases = this, $canvas, e,\n        layer, groups = [],\n        index;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n\n      if (layer.groups) {\n\n        // Find index of layer in group\n        index = inArray(groupName, layer.groups);\n\n        // If layer is in group\n        if (index !== -1) {\n\n          // Clone groups list\n          groups = layer.groups.slice(0);\n\n          // Remove layer from group\n          groups.splice(index, 1);\n\n          // Update layer group maps\n          $canvas.setLayer(layer, {\n            groups: groups\n          });\n\n        }\n\n      }\n\n    }\n    return $canvases;\n  };\n\n// Get topmost layer that intersects with event coordinates\n  function _getIntersectingLayer(data) {\n    var layer, i,\n        mask, m;\n\n    // Store the topmost layer\n    layer = null;\n\n    // Get the topmost layer whose visible area intersects event coordinates\n    for (i = data.intersecting.length - 1; i >= 0; i -= 1) {\n\n      // Get current layer\n      layer = data.intersecting[i];\n\n      // If layer has previous masks\n      if (layer._masks) {\n\n        // Search previous masks to ensure\n        // layer is visible at event coordinates\n        for (m = layer._masks.length - 1; m >= 0; m -= 1) {\n          mask = layer._masks[m];\n          // If mask does not intersect event coordinates\n          if (!mask.intersects) {\n            // Indicate that the mask does not\n            // intersect event coordinates\n            layer.intersects = false;\n            // Stop searching previous masks\n            break;\n          }\n\n        }\n\n        // If event coordinates intersect all previous masks\n        // and layer is not intangible\n        if (layer.intersects && !layer.intangible) {\n          // Stop searching for topmost layer\n          break;\n        }\n\n      }\n\n    }\n    // If resulting layer is intangible\n    if (layer && layer.intangible) {\n      // Cursor does not intersect this layer\n      layer = null;\n    }\n    return layer;\n  }\n\n// Draw individual layer (internal)\n  function _drawLayer($canvas, ctx, layer, nextLayerIndex) {\n    if (layer && layer.visible && layer._method) {\n      if (nextLayerIndex) {\n        layer._next = nextLayerIndex;\n      } else {\n        layer._next = null;\n      }\n      // If layer is an object, call its respective method\n      if (layer._method) {\n        layer._method.call($canvas, layer);\n      }\n    }\n  }\n\n// Handle dragging of the currently-dragged layer\n  function _handleLayerDrag($canvas, data, eventType) {\n    var layers, layer, l,\n        drag, dragGroups,\n        group, groupName, g,\n        newX, newY;\n\n    drag = data.drag;\n    layer = drag.layer;\n    dragGroups = (layer && layer.dragGroups) || [];\n    layers = data.layers;\n\n    if (eventType === 'mousemove' || eventType === 'touchmove') {\n      // Detect when user is currently dragging layer\n\n      if (!drag.dragging) {\n        // Detect when user starts dragging layer\n\n        // Signify that a layer on the canvas is being dragged\n        drag.dragging = true;\n        layer.dragging = true;\n\n        // Optionally bring layer to front when drag starts\n        if (layer.bringToFront) {\n          // Remove layer from its original position\n          layers.splice(layer.index, 1);\n          // Bring layer to front\n          // push() returns the new array length\n          layer.index = layers.push(layer);\n        }\n\n        // Set drag properties for this layer\n        layer._startX = layer.x;\n        layer._startY = layer.y;\n        layer._endX = layer._eventX;\n        layer._endY = layer._eventY;\n\n        // Trigger dragstart event\n        _triggerLayerEvent($canvas, data, layer, 'dragstart');\n\n      }\n\n      if (drag.dragging) {\n\n        // Calculate position after drag\n        newX = layer._eventX - (layer._endX - layer._startX);\n        newY = layer._eventY - (layer._endY - layer._startY);\n        if (layer.updateDragX) {\n          newX = layer.updateDragX.call($canvas[0], layer, newX);\n        }\n        if (layer.updateDragY) {\n          newY = layer.updateDragY.call($canvas[0], layer, newY);\n        }\n        layer.dx = newX - layer.x;\n        layer.dy = newY - layer.y;\n\n        if (layer.restrictDragToAxis !== 'y') {\n          layer.x = newX;\n        }\n        if (layer.restrictDragToAxis !== 'x') {\n          layer.y = newY;\n        }\n\n        if(layer.circlePath === true){\n          var centerX = layer.circleCenterX;\n          var centerY = layer.circleCenterY;\n          var r = layer.circleRadius;\n          var x1 = layer.x - centerX;\n          var y1 = layer.y - centerY;\n          var k = y1/x1;\n\n          if(x1<0){\n            var tempX = -Math.sqrt(Math.pow(r,2)/(1+Math.pow((k),2)));\n          }else{\n            var tempX = Math.sqrt(Math.pow(r,2)/(1+Math.pow((k),2)));\n          }\n          var tempY = tempX*k;\n\n          var px = layer.xMin;\n          var py = layer.yMin;\n          var qx = layer.xMax;\n          var qy = layer.yMax;\n          var rx = newX;\n          var ry = newY;\n          var Result = (Math.pow(px,2) + Math.pow(py,2)) * (qx * ry - qy * rx) -\n              (Math.pow(qx,2) + Math.pow(qy,2)) * (px * ry - py * rx) +\n              (Math.pow(rx,2) + Math.pow(ry,2)) * (px * qy - py * qx);\n\n          if(Result <= 0){\n            var absSumMin = Math.abs(layer.xMin - newX) + Math.abs(layer.yMin - newY);\n            var absSumMax = Math.abs(layer.xMax - newX) + Math.abs(layer.yMax - newY);\n            if(absSumMin < absSumMax){\n              tempX = layer.xMin - centerX;\n              tempY = layer.yMin - centerY;\n            }else{\n              tempX = layer.xMax - centerX;\n              tempY = layer.yMax - centerY;\n            }\n          }\n\n          var newX = tempX + centerX;\n          var newY = tempY + centerY;\n\n          layer.x = newX;\n          layer.y = newY;\n\n        }\n\n        // Trigger drag event\n        _triggerLayerEvent($canvas, data, layer, 'drag');\n\n        // Move groups with layer on drag\n        for (g = 0; g < dragGroups.length; g += 1) {\n\n          groupName = dragGroups[g];\n          group = data.layer.groups[groupName];\n          if (layer.groups && group) {\n\n            for (l = 0; l < group.length; l += 1) {\n              if (group[l] !== layer) {\n                if (layer.restrictDragToAxis !== 'y' && group[l].restrictDragToAxis !== 'y') {\n                  group[l].x += layer.dx;\n                }\n                if (layer.restrictDragToAxis !== 'x' && group[l].restrictDragToAxis !== 'x') {\n                  group[l].y += layer.dy;\n                }\n              }\n            }\n\n          }\n\n        }\n\n      }\n\n    } else if (eventType === 'mouseup' || eventType === 'touchend') {\n      // Detect when user stops dragging layer\n\n      if (drag.dragging) {\n        layer.dragging = false;\n        drag.dragging = false;\n        data.redrawOnMousemove = data.originalRedrawOnMousemove;\n        // Trigger dragstop event\n        _triggerLayerEvent($canvas, data, layer, 'dragstop');\n      }\n\n      // Cancel dragging\n      data.drag = {};\n\n    }\n  }\n\n\n// List of CSS3 cursors that need to be prefixed\n  css.cursors = ['grab', 'grabbing', 'zoom-in', 'zoom-out'];\n\n// Function to detect vendor prefix\n// Modified version of David Walsh's implementation\n// https://davidwalsh.name/vendor-prefix\n  css.prefix = (function () {\n    var styles = getComputedStyle(document.documentElement, ''),\n        pre = (arraySlice\n                .call(styles)\n                .join('')\n                .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\n        )[1];\n    return '-' + pre + '-';\n  })();\n\n// Set cursor on canvas\n  function _setCursor($canvas, layer, eventType) {\n    var cursor;\n    if (layer.cursors) {\n      // Retrieve cursor from cursors object if it exists\n      cursor = layer.cursors[eventType];\n    }\n    // Prefix any CSS3 cursor\n    if ($.inArray(cursor, css.cursors) !== -1) {\n      cursor = css.prefix + cursor;\n    }\n    // If cursor is defined\n    if (cursor) {\n      // Set canvas cursor\n      $canvas.css({\n        cursor: cursor\n      });\n    }\n  }\n\n// Reset cursor on canvas\n  function _resetCursor($canvas, data) {\n    $canvas.css({\n      cursor: data.cursor\n    });\n  }\n\n// Run the given event callback with the given arguments\n  function _runEventCallback($canvas, layer, eventType, callbacks, arg) {\n    // Prevent callback from firing recursively\n    if (callbacks[eventType] && layer._running && !layer._running[eventType]) {\n      // Signify the start of callback execution for this event\n      layer._running[eventType] = true;\n      // Run event callback with the given arguments\n      callbacks[eventType].call($canvas[0], layer, arg);\n      // Signify the end of callback execution for this event\n      layer._running[eventType] = false;\n    }\n  }\n\n// Determine if the given layer can \"legally\" fire the given event\n  function _layerCanFireEvent(layer, eventType) {\n    // If events are disable and if\n    // layer is tangible or event is not tangible\n    return (!layer.disableEvents &&\n        (!layer.intangible || $.inArray(eventType, tangibleEvents) === -1));\n  }\n\n// Trigger the given event on the given layer\n  function _triggerLayerEvent($canvas, data, layer, eventType, arg) {\n    // If layer can legally fire this event type\n    if (_layerCanFireEvent(layer, eventType)) {\n\n      // Do not set a custom cursor on layer mouseout\n      if (eventType !== 'mouseout') {\n        // Update cursor if one is defined for this event\n        _setCursor($canvas, layer, eventType);\n      }\n\n      // Trigger the user-defined event callback\n      _runEventCallback($canvas, layer, eventType, layer, arg);\n      // Trigger the canvas-bound event hook\n      _runEventCallback($canvas, layer, eventType, data.eventHooks, arg);\n      // Trigger the global event hook\n      _runEventCallback($canvas, layer, eventType, jCanvas.eventHooks, arg);\n\n    }\n  }\n\n// Manually trigger a layer event\n  $.fn.triggerLayerEvent = function (layer, eventType) {\n    var $canvases = this, $canvas, e,\n        data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layer);\n      if (layer) {\n        _triggerLayerEvent($canvas, data, layer, eventType);\n      }\n    }\n    return $canvases;\n  };\n\n// Draw layer with the given ID\n  $.fn.drawLayer = function drawLayer(layerId) {\n    var $canvases = this, e, ctx,\n        $canvas, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n        layer = $canvas.getLayer(layerId);\n        _drawLayer($canvas, ctx, layer);\n      }\n    }\n    return $canvases;\n  };\n\n// Draw all layers (or, if given, only layers starting at an index)\n  $.fn.drawLayers = function drawLayers(args) {\n    var $canvases = this, $canvas, e, ctx,\n        // Internal parameters for redrawing the canvas\n        params = args || {},\n        // Other variables\n        layers, layer, lastLayer, l, index, lastIndex,\n        data, eventCache, eventType, isImageLayer;\n\n    // The layer index from which to start redrawing the canvas\n    index = params.index;\n    if (!index) {\n      index = 0;\n    }\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        // Clear canvas first unless otherwise directed\n        if (params.clear !== false) {\n          $canvas.clearCanvas();\n        }\n\n        // Cache the layers array\n        layers = data.layers;\n\n        // Draw layers from first to last (bottom to top)\n        for (l = index; l < layers.length; l += 1) {\n          layer = layers[l];\n\n          // Ensure layer index is up-to-date\n          layer.index = l;\n\n          // Prevent any one event from firing excessively\n          if (params.resetFire) {\n            layer._fired = false;\n          }\n          // Draw layer\n          _drawLayer($canvas, ctx, layer, l + 1);\n          // Store list of previous masks for each layer\n          layer._masks = data.transforms.masks.slice(0);\n\n          // Allow image layers to load before drawing successive layers\n          if (layer._method === $.fn.drawImage && layer.visible) {\n            isImageLayer = true;\n            break;\n          }\n\n        }\n\n        // If layer is an image layer\n        if (isImageLayer) {\n          // Stop and wait for drawImage() to resume drawLayers()\n          break;\n        }\n\n        // Store the latest\n        lastIndex = l;\n\n        // Get first layer that intersects with event coordinates\n        layer = _getIntersectingLayer(data);\n\n        eventCache = data.event;\n        eventType = eventCache.type;\n\n        // If jCanvas has detected a dragstart\n        if (data.drag.layer) {\n          // Handle dragging of layer\n          _handleLayerDrag($canvas, data, eventType);\n        }\n\n        // Manage mouseout event\n        lastLayer = data.lastIntersected;\n        if (lastLayer !== null && layer !== lastLayer && lastLayer._hovered && !lastLayer._fired && !data.drag.dragging) {\n\n          data.lastIntersected = null;\n          lastLayer._fired = true;\n          lastLayer._hovered = false;\n          _triggerLayerEvent($canvas, data, lastLayer, 'mouseout');\n          _resetCursor($canvas, data);\n\n        }\n\n        if (layer) {\n\n          // Use mouse event callbacks if no touch event callbacks are given\n          if (!layer[eventType]) {\n            eventType = _getMouseEventName(eventType);\n          }\n\n          // Check events for intersecting layer\n          if (layer._event && layer.intersects) {\n\n            data.lastIntersected = layer;\n\n            // Detect mouseover events\n            if ((layer.mouseover || layer.mouseout || layer.cursors) && !data.drag.dragging) {\n\n              if (!layer._hovered && !layer._fired) {\n\n                // Prevent events from firing excessively\n                layer._fired = true;\n                layer._hovered = true;\n                _triggerLayerEvent($canvas, data, layer, 'mouseover');\n\n              }\n\n            }\n\n            // Detect any other mouse event\n            if (!layer._fired) {\n\n              // Prevent event from firing twice unintentionally\n              layer._fired = true;\n              eventCache.type = null;\n\n              _triggerLayerEvent($canvas, data, layer, eventType);\n\n            }\n\n            // Use the mousedown event to start drag\n            if (layer.draggable && !layer.disableEvents && (eventType === 'mousedown' || eventType === 'touchstart')) {\n\n              // Keep track of drag state\n              data.drag.layer = layer;\n              data.originalRedrawOnMousemove = data.redrawOnMousemove;\n              data.redrawOnMousemove = true;\n\n            }\n\n          }\n\n        }\n\n        // If cursor is not intersecting with any layer\n        if (layer === null && !data.drag.dragging) {\n          // Reset cursor to previous state\n          _resetCursor($canvas, data);\n        }\n\n        // If the last layer has been drawn\n        if (lastIndex === layers.length) {\n\n          // Reset list of intersecting layers\n          data.intersecting.length = 0;\n          // Reset transformation stack\n          data.transforms = _cloneTransforms(baseTransforms);\n          data.savedTransforms.length = 0;\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Add a jCanvas layer (internal)\n  function _addLayer(canvas, params, args, method) {\n    var $canvas, data,\n        layers, layer = (params._layer ? args : params);\n\n    // Store arguments object for later use\n    params._args = args;\n\n    // Convert all draggable drawings into jCanvas layers\n    if (params.draggable || params.dragGroups) {\n      params.layer = true;\n      params.draggable = true;\n    }\n\n    // Determine the layer's type using the available information\n    if (!params._method) {\n      if (method) {\n        params._method = method;\n      } else if (params.method) {\n        params._method = $.fn[params.method];\n      } else if (params.type) {\n        params._method = $.fn[maps.drawings[params.type]];\n      }\n    }\n\n    // If layer hasn't been added yet\n    if (params.layer && !params._layer) {\n      // Add layer to canvas\n\n      $canvas = $(canvas);\n\n      data = _getCanvasData(canvas);\n      layers = data.layers;\n\n      // Do not add duplicate layers of same name\n      if (layer.name === null || (isString(layer.name) && data.layer.names[layer.name] === undefined)) {\n\n        // Convert number properties to numbers\n        _coerceNumericProps(params);\n\n        // Ensure layers are unique across canvases by cloning them\n        layer = new jCanvasObject(params);\n        layer.canvas = canvas;\n        // Indicate that this is a layer for future checks\n        layer.layer = true;\n        layer._layer = true;\n        layer._running = {};\n        // If layer stores user-defined data\n        if (layer.data !== null) {\n          // Clone object\n          layer.data = extendObject({}, layer.data);\n        } else {\n          // Otherwise, create data object\n          layer.data = {};\n        }\n        // If layer stores a list of associated groups\n        if (layer.groups !== null) {\n          // Clone list\n          layer.groups = layer.groups.slice(0);\n        } else {\n          // Otherwise, create empty list\n          layer.groups = [];\n        }\n\n        // Update layer group maps\n        _updateLayerName($canvas, data, layer);\n        _updateLayerGroups($canvas, data, layer);\n\n        // Check for any associated jCanvas events and enable them\n        _addLayerEvents($canvas, data, layer);\n\n        // Optionally enable drag-and-drop support and cursor support\n        _enableDrag($canvas, data, layer);\n\n        // Copy _event property to parameters object\n        params._event = layer._event;\n\n        // Calculate width/height for text layers\n        if (layer._method === $.fn.drawText) {\n          $canvas.measureText(layer);\n        }\n\n        // Add layer to end of array if no index is specified\n        if (layer.index === null) {\n          layer.index = layers.length;\n        }\n\n        // Add layer to layers array at specified index\n        layers.splice(layer.index, 0, layer);\n\n        // Store layer on parameters object\n        params._args = layer;\n\n        // Trigger an 'add' event\n        _triggerLayerEvent($canvas, data, layer, 'add');\n\n      }\n\n    } else if (!params.layer) {\n      _coerceNumericProps(params);\n    }\n\n    return layer;\n  }\n\n// Add a jCanvas layer\n  $.fn.addLayer = function addLayer(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        params.layer = true;\n        _addLayer($canvases[e], params, args);\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Animation API */\n\n// Define properties used in both CSS and jCanvas\n  css.props = [\n    'width',\n    'height',\n    'opacity',\n    'lineHeight'\n  ];\n  css.propsObj = {};\n\n// Hide/show jCanvas/CSS properties so they can be animated using jQuery\n  function _showProps(obj) {\n    var cssProp, p;\n    for (p = 0; p < css.props.length; p += 1) {\n      cssProp = css.props[p];\n      obj[cssProp] = obj['_' + cssProp];\n    }\n  }\n  function _hideProps(obj, reset) {\n    var cssProp, p;\n    for (p = 0; p < css.props.length; p += 1) {\n      cssProp = css.props[p];\n      // Hide property using same name with leading underscore\n      if (obj[cssProp] !== undefined) {\n        obj['_' + cssProp] = obj[cssProp];\n        css.propsObj[cssProp] = true;\n        if (reset) {\n          delete obj[cssProp];\n        }\n      }\n    }\n  }\n\n// Evaluate property values that are functions\n  function _parseEndValues(canvas, layer, endValues) {\n    var propName, propValue,\n        subPropName, subPropValue;\n    // Loop through all properties in map of end values\n    for (propName in endValues) {\n      if (Object.prototype.hasOwnProperty.call(endValues, propName)) {\n        propValue = endValues[propName];\n        // If end value is function\n        if (isFunction(propValue)) {\n          // Call function and use its value as the end value\n          endValues[propName] = propValue.call(canvas, layer, propName);\n        }\n        // If end value is an object\n        if (typeOf(propValue) === 'object' && isPlainObject(propValue)) {\n          // Prepare to animate properties in object\n          for (subPropName in propValue) {\n            if (Object.prototype.hasOwnProperty.call(propValue, subPropName)) {\n              subPropValue = propValue[subPropName];\n              // Store property's start value at top-level of layer\n              if (layer[propName] !== undefined) {\n                layer[propName + '.' + subPropName] = layer[propName][subPropName];\n                // Store property's end value at top-level of end values map\n                endValues[propName + '.' + subPropName] = subPropValue;\n              }\n            }\n          }\n          // Delete sub-property of object as it's no longer needed\n          delete endValues[propName];\n        }\n      }\n    }\n    return endValues;\n  }\n\n// Remove sub-property aliases from layer object\n  function _removeSubPropAliases(layer) {\n    var propName;\n    for (propName in layer) {\n      if (Object.prototype.hasOwnProperty.call(layer, propName)) {\n        if (propName.indexOf('.') !== -1) {\n          delete layer[propName];\n        }\n      }\n    }\n  }\n\n// Convert a color value to an array of RGB values\n  function _colorToRgbArray(color) {\n    var originalColor, elem,\n        rgb = [],\n        multiple = 1;\n\n    // Deal with complete transparency\n    if (color === 'transparent') {\n      color = 'rgba(0, 0, 0, 0)';\n    } else if (color.match(/^([a-z]+|#[0-9a-f]+)$/gi)) {\n      // Deal with hexadecimal colors and color names\n      elem = document.head;\n      originalColor = elem.style.color;\n      elem.style.color = color;\n      color = $.css(elem, 'color');\n      elem.style.color = originalColor;\n    }\n    // Parse RGB string\n    if (color.match(/^rgb/gi)) {\n      rgb = color.match(/(\\d+(\\.\\d+)?)/gi);\n      // Deal with RGB percentages\n      if (color.match(/%/gi)) {\n        multiple = 2.55;\n      }\n      rgb[0] *= multiple;\n      rgb[1] *= multiple;\n      rgb[2] *= multiple;\n      // Ad alpha channel if given\n      if (rgb[3] !== undefined) {\n        rgb[3] = parseFloat(rgb[3]);\n      } else {\n        rgb[3] = 1;\n      }\n    }\n    return rgb;\n  }\n\n// Animate a hex or RGB color\n  function _animateColor(fx) {\n    var n = 3,\n        i;\n    // Only parse start and end colors once\n    if (typeOf(fx.start) !== 'array') {\n      fx.start = _colorToRgbArray(fx.start);\n      fx.end = _colorToRgbArray(fx.end);\n    }\n    fx.now = [];\n\n    // If colors are RGBA, animate transparency\n    if (fx.start[3] !== 1 || fx.end[3] !== 1) {\n      n = 4;\n    }\n\n    // Calculate current frame for red, green, blue, and alpha\n    for (i = 0; i < n; i += 1) {\n      fx.now[i] = fx.start[i] + ((fx.end[i] - fx.start[i]) * fx.pos);\n      // Only the red, green, and blue values must be integers\n      if (i < 3) {\n        fx.now[i] = round(fx.now[i]);\n      }\n    }\n    if (fx.start[3] !== 1 || fx.end[3] !== 1) {\n      // Only use RGBA if RGBA colors are given\n      fx.now = 'rgba(' + fx.now.join(',') + ')';\n    } else {\n      // Otherwise, animate as solid colors\n      fx.now.slice(0, 3);\n      fx.now = 'rgb(' + fx.now.join(',') + ')';\n    }\n    // Animate colors for both canvas layers and DOM elements\n    if (fx.elem.nodeName) {\n      fx.elem.style[fx.prop] = fx.now;\n    } else {\n      fx.elem[fx.prop] = fx.now;\n    }\n  }\n\n// Animate jCanvas layer\n  $.fn.animateLayer = function animateLayer() {\n    var $canvases = this, $canvas, e, ctx,\n        args = arraySlice.call(arguments, 0),\n        data, layer, props;\n\n    // Deal with all cases of argument placement\n    /*\n\t\t0. layer name/index\n\t\t1. properties\n\t\t2. duration/options\n\t\t3. easing\n\t\t4. complete function\n\t\t5. step function\n\t*/\n\n    if (typeOf(args[2]) === 'object') {\n\n      // Accept an options object for animation\n      args.splice(2, 0, args[2].duration || null);\n      args.splice(3, 0, args[3].easing || null);\n      args.splice(4, 0, args[4].complete || null);\n      args.splice(5, 0, args[5].step || null);\n\n    } else {\n\n      if (args[2] === undefined) {\n        // If object is the last argument\n        args.splice(2, 0, null);\n        args.splice(3, 0, null);\n        args.splice(4, 0, null);\n      } else if (isFunction(args[2])) {\n        // If callback comes after object\n        args.splice(2, 0, null);\n        args.splice(3, 0, null);\n      }\n      if (args[3] === undefined) {\n        // If duration is the last argument\n        args[3] = null;\n        args.splice(4, 0, null);\n      } else if (isFunction(args[3])) {\n        // If callback comes after duration\n        args.splice(3, 0, null);\n      }\n\n    }\n\n    // Run callback function when animation completes\n    function complete($canvas, data, layer) {\n\n      return function () {\n\n        _showProps(layer);\n        _removeSubPropAliases(layer);\n\n        // Prevent multiple redraw loops\n        if (!data.animating || data.animated === layer) {\n          // Redraw layers on last frame\n          $canvas.drawLayers();\n        }\n\n        // Signify the end of an animation loop\n        layer._animating = false;\n        data.animating = false;\n        data.animated = null;\n\n        // If callback is defined\n        if (args[4]) {\n          // Run callback at the end of the animation\n          args[4].call($canvas[0], layer);\n        }\n\n        _triggerLayerEvent($canvas, data, layer, 'animateend');\n\n      };\n\n    }\n\n    // Redraw layers on every frame of the animation\n    function step($canvas, data, layer) {\n\n      return function (now, fx) {\n        var parts, propName, subPropName,\n            hidden = false;\n\n        // If animated property has been hidden\n        if (fx.prop[0] === '_') {\n          hidden = true;\n          // Unhide property temporarily\n          fx.prop = fx.prop.replace('_', '');\n          layer[fx.prop] = layer['_' + fx.prop];\n        }\n\n        // If animating property of sub-object\n        if (fx.prop.indexOf('.') !== -1) {\n          parts = fx.prop.split('.');\n          propName = parts[0];\n          subPropName = parts[1];\n          if (layer[propName]) {\n            layer[propName][subPropName] = fx.now;\n          }\n        }\n\n        // Throttle animation to improve efficiency\n        if (layer._pos !== fx.pos) {\n\n          layer._pos = fx.pos;\n\n          // Signify the start of an animation loop\n          if (!layer._animating && !data.animating) {\n            layer._animating = true;\n            data.animating = true;\n            data.animated = layer;\n          }\n\n          // Prevent multiple redraw loops\n          if (!data.animating || data.animated === layer) {\n            // Redraw layers for every frame\n            $canvas.drawLayers();\n          }\n\n        }\n\n        // If callback is defined\n        if (args[5]) {\n          // Run callback for each step of animation\n          args[5].call($canvas[0], now, fx, layer);\n        }\n\n        _triggerLayerEvent($canvas, data, layer, 'animate', fx);\n\n        // If property should be hidden during animation\n        if (hidden) {\n          // Hide property again\n          fx.prop = '_' + fx.prop;\n        }\n\n      };\n\n    }\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        // If a layer object was passed, use it the layer to be animated\n        layer = $canvas.getLayer(args[0]);\n\n        // Ignore layers that are functions\n        if (layer && layer._method !== $.fn.draw) {\n\n          // Do not modify original object\n          props = extendObject({}, args[1]);\n\n          props = _parseEndValues($canvases[e], layer, props);\n\n          // Bypass jQuery CSS Hooks for CSS properties (width, opacity, etc.)\n          _hideProps(props, true);\n          _hideProps(layer);\n\n          // Fix for jQuery's vendor prefixing support, which affects how width/height/opacity are animated\n          layer.style = css.propsObj;\n\n          // Animate layer\n          $(layer).animate(props, {\n            duration: args[2],\n            easing: ($.easing[args[3]] ? args[3] : null),\n            // When animation completes\n            complete: complete($canvas, data, layer),\n            // Redraw canvas for every animation frame\n            step: step($canvas, data, layer)\n          });\n          _triggerLayerEvent($canvas, data, layer, 'animatestart');\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Animate all layers in a layer group\n  $.fn.animateLayerGroup = function animateLayerGroup(groupId) {\n    var $canvases = this, $canvas, e,\n        args = arraySlice.call(arguments, 0),\n        group, l;\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      group = $canvas.getLayerGroup(groupId);\n      if (group) {\n\n        // Animate all layers in the group\n        for (l = 0; l < group.length; l += 1) {\n\n          // Replace first argument with layer\n          args[0] = group[l];\n          $canvas.animateLayer.apply($canvas, args);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Delay layer animation by a given number of milliseconds\n  $.fn.delayLayer = function delayLayer(layerId, duration) {\n    var $canvases = this, $canvas, e,\n        data, layer;\n    duration = duration || 0;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n      // If layer exists\n      if (layer) {\n        // Delay animation\n        $(layer).delay(duration);\n        _triggerLayerEvent($canvas, data, layer, 'delay');\n      }\n    }\n    return $canvases;\n  };\n\n// Delay animation all layers in a layer group\n  $.fn.delayLayerGroup = function delayLayerGroup(groupId, duration) {\n    var $canvases = this, $canvas, e,\n        group, layer, l;\n    duration = duration || 0;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // Delay all layers in the group\n      if (group) {\n\n        for (l = 0; l < group.length; l += 1) {\n          // Delay each layer in the group\n          layer = group[l];\n          $canvas.delayLayer(layer, duration);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Stop layer animation\n  $.fn.stopLayer = function stopLayer(layerId, clearQueue) {\n    var $canvases = this, $canvas, e,\n        data, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n      // If layer exists\n      if (layer) {\n        // Stop animation\n        $(layer).stop(clearQueue);\n        _triggerLayerEvent($canvas, data, layer, 'stop');\n      }\n    }\n    return $canvases;\n  };\n\n// Stop animation of all layers in a layer group\n  $.fn.stopLayerGroup = function stopLayerGroup(groupId, clearQueue) {\n    var $canvases = this, $canvas, e,\n        group, layer, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // Stop all layers in the group\n      if (group) {\n\n        for (l = 0; l < group.length; l += 1) {\n          // Stop each layer in the group\n          layer = group[l];\n          $canvas.stopLayer(layer, clearQueue);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Enable animation for color properties\n  function _supportColorProps(props) {\n    var p;\n    for (p = 0; p < props.length; p += 1) {\n      $.fx.step[props[p]] = _animateColor;\n    }\n  }\n\n// Enable animation for color properties\n  _supportColorProps([\n    'color',\n    'backgroundColor',\n    'borderColor',\n    'borderTopColor',\n    'borderRightColor',\n    'borderBottomColor',\n    'borderLeftColor',\n    'fillStyle',\n    'outlineColor',\n    'strokeStyle',\n    'shadowColor'\n  ]);\n\n  /* Event API */\n\n// Map standard mouse events to touch events\n  maps.touchEvents = {\n    'mousedown': 'touchstart',\n    'mouseup': 'touchend',\n    'mousemove': 'touchmove'\n  };\n// Map standard touch events to mouse events\n  maps.mouseEvents = {\n    'touchstart': 'mousedown',\n    'touchend': 'mouseup',\n    'touchmove': 'mousemove'\n  };\n\n// Convert mouse event name to a corresponding touch event name (if possible)\n  function _getTouchEventName(eventName) {\n    // Detect touch event support\n    if (maps.touchEvents[eventName]) {\n      eventName = maps.touchEvents[eventName];\n    }\n    return eventName;\n  }\n// Convert touch event name to a corresponding mouse event name\n  function _getMouseEventName(eventName) {\n    if (maps.mouseEvents[eventName]) {\n      eventName = maps.mouseEvents[eventName];\n    }\n    return eventName;\n  }\n\n// Bind event to jCanvas layer using standard jQuery events\n  function _createEvent(eventName) {\n\n    jCanvas.events[eventName] = function ($canvas, data) {\n      var helperEventName, touchEventName, eventCache;\n\n      // Retrieve canvas's event cache\n      eventCache = data.event;\n\n      // Both mouseover/mouseout events will be managed by a single mousemove event\n      helperEventName = (eventName === 'mouseover' || eventName === 'mouseout') ? 'mousemove' : eventName;\n      touchEventName = _getTouchEventName(helperEventName);\n\n      function eventCallback(event) {\n        // Cache current mouse position and redraw layers\n        eventCache.x = event.offsetX;\n        eventCache.y = event.offsetY;\n        eventCache.type = helperEventName;\n        eventCache.event = event;\n        // Redraw layers on every trigger of the event; don't redraw if at\n        // least one layer is draggable and there are no layers with\n        // explicit mouseover/mouseout/mousemove events\n        if (event.type !== 'mousemove' || data.redrawOnMousemove || data.drag.dragging) {\n          $canvas.drawLayers({\n            resetFire: true\n          });\n        }\n        // Prevent default event behavior\n        event.preventDefault();\n      }\n\n      // Ensure the event is not bound more than once\n      if (!data.events[helperEventName]) {\n        // Bind one canvas event which handles all layer events of that type\n        if (touchEventName !== helperEventName) {\n          $canvas.bind(helperEventName + '.jCanvas ' + touchEventName + '.jCanvas', eventCallback);\n        } else {\n          $canvas.bind(helperEventName + '.jCanvas', eventCallback);\n        }\n        // Prevent this event from being bound twice\n        data.events[helperEventName] = true;\n      }\n    };\n  }\n  function _createEvents(eventNames) {\n    var n;\n    for (n = 0; n < eventNames.length; n += 1) {\n      _createEvent(eventNames[n]);\n    }\n  }\n// Populate jCanvas events object with some standard events\n  _createEvents([\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseup',\n    'mousemove',\n    'mouseover',\n    'mouseout',\n    'touchstart',\n    'touchmove',\n    'touchend',\n    'pointerdown',\n    'pointermove',\n    'pointerup',\n    'contextmenu'\n  ]);\n\n// Check if event fires when a drawing is drawn\n  function _detectEvents(canvas, ctx, params) {\n    var layer, data, eventCache, intersects,\n        transforms, x, y, angle;\n\n    // Use the layer object stored by the given parameters object\n    layer = params._args;\n    // Canvas must have event bindings\n    if (layer) {\n\n      data = _getCanvasData(canvas);\n      eventCache = data.event;\n      if (eventCache.x !== null && eventCache.y !== null) {\n        // Respect user-defined pixel ratio\n        x = eventCache.x * data.pixelRatio;\n        y = eventCache.y * data.pixelRatio;\n        // Determine if the given coordinates are in the current path\n        intersects = ctx.isPointInPath(x, y) || (ctx.isPointInStroke && ctx.isPointInStroke(x, y));\n      }\n      transforms = data.transforms;\n\n      // Allow callback functions to retrieve the mouse coordinates\n      layer.eventX = eventCache.x;\n      layer.eventY = eventCache.y;\n      layer.event = eventCache.event;\n\n      // Adjust coordinates to match current canvas transformation\n\n      // Keep track of some transformation values\n      angle = data.transforms.rotate;\n      x = layer.eventX;\n      y = layer.eventY;\n\n      if (angle !== 0) {\n        // Rotate coordinates if coordinate space has been rotated\n        layer._eventX = (x * cos(-angle)) - (y * sin(-angle));\n        layer._eventY = (y * cos(-angle)) + (x * sin(-angle));\n      } else {\n        // Otherwise, no calculations need to be made\n        layer._eventX = x;\n        layer._eventY = y;\n      }\n\n      // Scale coordinates\n      layer._eventX /= transforms.scaleX;\n      layer._eventY /= transforms.scaleY;\n\n      // If layer intersects with cursor\n      if (intersects) {\n        // Add it to a list of layers that intersect with cursor\n        data.intersecting.push(layer);\n      }\n      layer.intersects = Boolean(intersects);\n    }\n  }\n\n// Normalize offsetX and offsetY for all browsers\n  $.event.fix = function (event) {\n    var offset, originalEvent, touches;\n\n    event = jQueryEventFix.call($.event, event);\n    originalEvent = event.originalEvent;\n\n    // originalEvent does not exist for manually-triggered events\n    if (originalEvent) {\n\n      touches = originalEvent.changedTouches;\n\n      // If offsetX and offsetY are not supported, define them\n      if (event.pageX !== undefined && event.offsetX === undefined) {\n        try {\n          offset = $(event.currentTarget).offset();\n          if (offset) {\n            event.offsetX = event.pageX - offset.left;\n            event.offsetY = event.pageY - offset.top;\n          }\n        } catch (error) {\n          // Fail silently\n        }\n      } else if (touches) {\n        try {\n          // Enable offsetX and offsetY for mobile devices\n          offset = $(event.currentTarget).offset();\n          if (offset) {\n            event.offsetX = touches[0].pageX - offset.left;\n            event.offsetY = touches[0].pageY - offset.top;\n          }\n        } catch (error) {\n          // Fail silently\n        }\n      }\n\n    }\n    return event;\n  };\n\n  /* Drawing API */\n\n// Map drawing names with their respective method names\n  maps.drawings = {\n    'arc': 'drawArc',\n    'bezier': 'drawBezier',\n    'ellipse': 'drawEllipse',\n    'function': 'draw',\n    'image': 'drawImage',\n    'line': 'drawLine',\n    'path': 'drawPath',\n    'polygon': 'drawPolygon',\n    'slice': 'drawSlice',\n    'quadratic': 'drawQuadratic',\n    'rectangle': 'drawRect',\n    'text': 'drawText',\n    'vector': 'drawVector',\n    'save': 'saveCanvas',\n    'restore': 'restoreCanvas',\n    'rotate': 'rotateCanvas',\n    'scale': 'scaleCanvas',\n    'translate': 'translateCanvas'\n  };\n\n// Draws on canvas using a function\n  $.fn.draw = function draw(args) {\n    var $canvases = this, e, ctx,\n        params = new jCanvasObject(args);\n\n    // Draw using any other method\n    if (maps.drawings[params.type] && params.type !== 'function') {\n\n      $canvases[maps.drawings[params.type]](args);\n\n    } else {\n\n      for (e = 0; e < $canvases.length; e += 1) {\n        ctx = _getContext($canvases[e]);\n        if (ctx) {\n\n          params = new jCanvasObject(args);\n          _addLayer($canvases[e], params, args, draw);\n          if (params.visible) {\n\n            if (params.fn) {\n              // Call the given user-defined function\n              params.fn.call($canvases[e], ctx, params);\n            }\n\n          }\n\n        }\n      }\n\n    }\n    return $canvases;\n  };\n\n// Clears canvas\n  $.fn.clearCanvas = function clearCanvas(args) {\n    var $canvases = this, e, ctx,\n        params = new jCanvasObject(args);\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        if (params.width === null || params.height === null) {\n          // Clear entire canvas if width/height is not given\n\n          // Reset current transformation temporarily to ensure that the entire canvas is cleared\n          ctx.save();\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.clearRect(0, 0, $canvases[e].width, $canvases[e].height);\n          ctx.restore();\n\n        } else {\n          // Otherwise, clear the defined section of the canvas\n\n          // Transform clear rectangle\n          _addLayer($canvases[e], params, args, clearCanvas);\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          ctx.clearRect(params.x - (params.width / 2), params.y - (params.height / 2), params.width, params.height);\n          // Restore previous transformation\n          _restoreTransform(ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Transformation API */\n\n// Restores canvas\n  $.fn.saveCanvas = function saveCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, saveCanvas);\n\n        // Restore a number of times using the given count\n        for (i = 0; i < params.count; i += 1) {\n          _saveCanvas(ctx, data);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Restores canvas\n  $.fn.restoreCanvas = function restoreCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, restoreCanvas);\n\n        // Restore a number of times using the given count\n        for (i = 0; i < params.count; i += 1) {\n          _restoreCanvas(ctx, data);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Rotates canvas (internal)\n  function _rotateCanvas(ctx, params, transforms) {\n\n    // Get conversion factor for radians\n    params._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n    // Rotate canvas using shape as center of rotation\n    ctx.translate(params.x, params.y);\n    ctx.rotate(params.rotate * params._toRad);\n    ctx.translate(-params.x, -params.y);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.rotate += (params.rotate * params._toRad);\n    }\n  }\n\n// Scales canvas (internal)\n  function _scaleCanvas(ctx, params, transforms) {\n\n    // Scale both the x- and y- axis using the 'scale' property\n    if (params.scale !== 1) {\n      params.scaleX = params.scaleY = params.scale;\n    }\n\n    // Scale canvas using shape as center of rotation\n    ctx.translate(params.x, params.y);\n    ctx.scale(params.scaleX, params.scaleY);\n    ctx.translate(-params.x, -params.y);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.scaleX *= params.scaleX;\n      transforms.scaleY *= params.scaleY;\n    }\n  }\n\n// Translates canvas (internal)\n  function _translateCanvas(ctx, params, transforms) {\n\n    // Translate both the x- and y-axis using the 'translate' property\n    if (params.translate) {\n      params.translateX = params.translateY = params.translate;\n    }\n\n    // Translate canvas\n    ctx.translate(params.translateX, params.translateY);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.translateX += params.translateX;\n      transforms.translateY += params.translateY;\n    }\n  }\n\n// Rotates canvas\n  $.fn.rotateCanvas = function rotateCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, rotateCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _rotateCanvas(ctx, params, data.transforms);\n      }\n\n    }\n    return $canvases;\n  };\n\n// Scales canvas\n  $.fn.scaleCanvas = function scaleCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, scaleCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _scaleCanvas(ctx, params, data.transforms);\n\n      }\n    }\n    return $canvases;\n  };\n\n// Translates canvas\n  $.fn.translateCanvas = function translateCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, translateCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _translateCanvas(ctx, params, data.transforms);\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Shape API */\n\n// Draws rectangle\n  $.fn.drawRect = function drawRect(args) {\n    var $canvases = this, e, ctx,\n        params,\n        x1, y1,\n        x2, y2,\n        r, temp;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawRect);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          if (params.width && params.height) {\n            x1 = params.x - (params.width / 2);\n            y1 = params.y - (params.height / 2);\n            r = abs(params.cornerRadius);\n            // If corner radius is defined and is not zero\n            if (r) {\n              // Draw rectangle with rounded corners if cornerRadius is defined\n\n              x2 = params.x + (params.width / 2);\n              y2 = params.y + (params.height / 2);\n\n              // Handle negative width\n              if (params.width < 0) {\n                temp = x1;\n                x1 = x2;\n                x2 = temp;\n              }\n              // Handle negative height\n              if (params.height < 0) {\n                temp = y1;\n                y1 = y2;\n                y2 = temp;\n              }\n\n              // Prevent over-rounded corners\n              if ((x2 - x1) - (2 * r) < 0) {\n                r = (x2 - x1) / 2;\n              }\n              if ((y2 - y1) - (2 * r) < 0) {\n                r = (y2 - y1) / 2;\n              }\n\n              // Draw rectangle\n              ctx.moveTo(x1 + r, y1);\n              ctx.lineTo(x2 - r, y1);\n              ctx.arc(x2 - r, y1 + r, r, 3 * PI / 2, PI * 2, false);\n              ctx.lineTo(x2, y2 - r);\n              ctx.arc(x2 - r, y2 - r, r, 0, PI / 2, false);\n              ctx.lineTo(x1 + r, y2);\n              ctx.arc(x1 + r, y2 - r, r, PI / 2, PI, false);\n              ctx.lineTo(x1, y1 + r);\n              ctx.arc(x1 + r, y1 + r, r, PI, 3 * PI / 2, false);\n              // Always close path\n              params.closed = true;\n\n            } else {\n\n              // Otherwise, draw rectangle with square corners\n              ctx.rect(x1, y1, params.width, params.height);\n\n            }\n          }\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Close rectangle path\n          _closePath($canvases[e], ctx, params);\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves a coterminal angle between 0 and 2pi for the given angle\n  function _getCoterminal(angle) {\n    while (angle < 0) {\n      angle += (2 * PI);\n    }\n    return angle;\n  }\n\n// Retrieves the x-coordinate for the given angle in a circle\n  function _getArcX(params, angle) {\n    return params.x + (params.radius * cos(angle));\n  }\n// Retrieves the y-coordinate for the given angle in a circle\n  function _getArcY(params, angle) {\n    return params.y + (params.radius * sin(angle));\n  }\n\n// Draws arc (internal)\n  function _drawArc(canvas, ctx, params, path) {\n    var x1, y1, x2, y2,\n        x3, y3, x4, y4,\n        offsetX, offsetY,\n        diff;\n\n    // Determine offset from dragging\n    if (params === path) {\n      offsetX = 0;\n      offsetY = 0;\n    } else {\n      offsetX = params.x;\n      offsetY = params.y;\n    }\n\n    // Convert default end angle to radians\n    if (!path.inDegrees && path.end === 360) {\n      path.end = PI * 2;\n    }\n\n    // Convert angles to radians\n    path.start *= params._toRad;\n    path.end *= params._toRad;\n    // Consider 0deg due north of arc\n    path.start -= (PI / 2);\n    path.end -= (PI / 2);\n\n    // Ensure arrows are pointed correctly for CCW arcs\n    diff = PI / 180;\n    if (path.ccw) {\n      diff *= -1;\n    }\n\n    // Calculate coordinates for start arrow\n    x1 = _getArcX(path, path.start + diff);\n    y1 = _getArcY(path, path.start + diff);\n    x2 = _getArcX(path, path.start);\n    y2 = _getArcY(path, path.start);\n\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        x1, y1,\n        x2, y2\n    );\n\n    // Draw arc\n    ctx.arc(path.x + offsetX, path.y + offsetY, path.radius, path.start, path.end, path.ccw);\n\n    // Calculate coordinates for end arrow\n    x3 = _getArcX(path, path.end + diff);\n    y3 = _getArcY(path, path.end + diff);\n    x4 = _getArcX(path, path.end);\n    y4 = _getArcY(path, path.end);\n\n    _addEndArrow(\n        canvas, ctx,\n        params, path,\n        x4, y4,\n        x3, y3\n    );\n  }\n\n// Draws arc or circle\n  $.fn.drawArc = function drawArc(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawArc);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          _drawArc($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Draws ellipse\n  $.fn.drawEllipse = function drawEllipse(args) {\n    var $canvases = this, e, ctx,\n        params,\n        controlW,\n        controlH;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawEllipse);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Calculate control width and height\n          controlW = params.width * (4 / 3);\n          controlH = params.height;\n\n          // Create ellipse using curves\n          ctx.beginPath();\n          ctx.moveTo(params.x, params.y - (controlH / 2));\n          // Left side\n          ctx.bezierCurveTo(params.x - (controlW / 2), params.y - (controlH / 2), params.x - (controlW / 2), params.y + (controlH / 2), params.x, params.y + (controlH / 2));\n          // Right side\n          ctx.bezierCurveTo(params.x + (controlW / 2), params.y + (controlH / 2), params.x + (controlW / 2), params.y - (controlH / 2), params.x, params.y - (controlH / 2));\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws a regular (equal-angled) polygon\n  $.fn.drawPolygon = function drawPolygon(args) {\n    var $canvases = this, e, ctx,\n        params,\n        theta, dtheta, hdtheta,\n        apothem,\n        x, y, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawPolygon);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Polygon's central angle\n          dtheta = (2 * PI) / params.sides;\n          // Half of dtheta\n          hdtheta = dtheta / 2;\n          // Polygon's starting angle\n          theta = hdtheta + (PI / 2);\n          // Distance from polygon's center to the middle of its side\n          apothem = params.radius * cos(hdtheta);\n\n          // Calculate path and draw\n          ctx.beginPath();\n          for (i = 0; i < params.sides; i += 1) {\n\n            // Draw side of polygon\n            x = params.x + (params.radius * cos(theta));\n            y = params.y + (params.radius * sin(theta));\n\n            // Plot point on polygon\n            ctx.lineTo(x, y);\n\n            // Project side if chosen\n            if (params.concavity) {\n              // Sides are projected from the polygon's apothem\n              x = params.x + ((apothem + (-apothem * params.concavity)) * cos(theta + hdtheta));\n              y = params.y + ((apothem + (-apothem * params.concavity)) * sin(theta + hdtheta));\n              ctx.lineTo(x, y);\n            }\n\n            // Increment theta by delta theta\n            theta += dtheta;\n\n          }\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws pie-shaped slice\n  $.fn.drawSlice = function drawSlice(args) {\n    var $canvases = this, e, ctx,\n        params,\n        angle, dx, dy;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawSlice);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Perform extra calculations\n\n          // Convert angles to radians\n          params.start *= params._toRad;\n          params.end *= params._toRad;\n          // Consider 0deg at north of arc\n          params.start -= (PI / 2);\n          params.end -= (PI / 2);\n\n          // Find positive equivalents of angles\n          params.start = _getCoterminal(params.start);\n          params.end = _getCoterminal(params.end);\n          // Ensure start angle is less than end angle\n          if (params.end < params.start) {\n            params.end += (2 * PI);\n          }\n\n          // Calculate angular position of slice\n          angle = ((params.start + params.end) / 2);\n\n          // Calculate ratios for slice's angle\n          dx = (params.radius * params.spread * cos(angle));\n          dy = (params.radius * params.spread * sin(angle));\n\n          // Adjust position of slice\n          params.x += dx;\n          params.y += dy;\n\n          // Draw slice\n          ctx.beginPath();\n          ctx.arc(params.x, params.y, params.radius, params.start, params.end, params.ccw);\n          ctx.lineTo(params.x, params.y);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Path API */\n\n// Adds arrow to path using the given properties\n  function _addArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    var leftX, leftY,\n        rightX, rightY,\n        offsetX, offsetY,\n        angle;\n\n    // If arrow radius is given and path is not closed\n    if (path.arrowRadius && !params.closed) {\n\n      // Calculate angle\n      angle = atan2((y2 - y1), (x2 - x1));\n      // Adjust angle correctly\n      angle -= PI;\n      // Calculate offset to place arrow at edge of path\n      offsetX = (params.strokeWidth * cos(angle));\n      offsetY = (params.strokeWidth * sin(angle));\n\n      // Calculate coordinates for left half of arrow\n      leftX = x2 + (path.arrowRadius * cos(angle + (path.arrowAngle / 2)));\n      leftY = y2 + (path.arrowRadius * sin(angle + (path.arrowAngle / 2)));\n      // Calculate coordinates for right half of arrow\n      rightX = x2 + (path.arrowRadius * cos(angle - (path.arrowAngle / 2)));\n      rightY = y2 + (path.arrowRadius * sin(angle - (path.arrowAngle / 2)));\n\n      // Draw left half of arrow\n      ctx.moveTo(leftX - offsetX, leftY - offsetY);\n      ctx.lineTo(x2 - offsetX, y2 - offsetY);\n      // Draw right half of arrow\n      ctx.lineTo(rightX - offsetX, rightY - offsetY);\n\n      // Visually connect arrow to path\n      ctx.moveTo(x2 - offsetX, y2 - offsetY);\n      ctx.lineTo(x2 + offsetX, y2 + offsetY);\n      // Move back to end of path\n      ctx.moveTo(x2, y2);\n\n    }\n  }\n\n// Optionally adds arrow to start of path\n  function _addStartArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    if (!path._arrowAngleConverted) {\n      path.arrowAngle *= params._toRad;\n      path._arrowAngleConverted = true;\n    }\n    if (path.startArrow) {\n      _addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n    }\n  }\n\n// Optionally adds arrow to end of path\n  function _addEndArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    if (!path._arrowAngleConverted) {\n      path.arrowAngle *= params._toRad;\n      path._arrowAngleConverted = true;\n    }\n    if (path.endArrow) {\n      _addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n    }\n  }\n\n// Draws line (internal)\n  function _drawLine(canvas, ctx, params, path) {\n    var l,\n        lx, ly;\n    l = 2;\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        path.x2 + params.x,\n        path.y2 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      // If coordinates are given\n      if (lx !== undefined && ly !== undefined) {\n        // Draw next line\n        ctx.lineTo(lx + params.x, ly + params.y);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    // Optionally add arrows to path\n    _addEndArrow(\n        canvas, ctx,\n        params,\n        path,\n        path['x' + (l - 1)] + params.x,\n        path['y' + (l - 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws line\n  $.fn.drawLine = function drawLine(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawLine);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawLine($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Draws quadratic curve (internal)\n  function _drawQuadratic(canvas, ctx, params, path) {\n    var l,\n        lx, ly,\n        lcx, lcy;\n\n    l = 2;\n\n    _addStartArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path.cx1 + params.x,\n        path.cy1 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      lcx = path['cx' + (l - 1)];\n      lcy = path['cy' + (l - 1)];\n      // If coordinates are given\n      if (lx !== undefined && ly !== undefined && lcx !== undefined && lcy !== undefined) {\n        // Draw next curve\n        ctx.quadraticCurveTo(lcx + params.x, lcy + params.y, lx + params.x, ly + params.y);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    _addEndArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path['cx' + (l - 1)] + params.x,\n        path['cy' + (l - 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws quadratic curve\n  $.fn.drawQuadratic = function drawQuadratic(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawQuadratic);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawQuadratic($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws Bezier curve (internal)\n  function _drawBezier(canvas, ctx, params, path) {\n    var l, lc,\n        lx, ly,\n        lcx1, lcy1,\n        lcx2, lcy2;\n\n    l = 2;\n    lc = 1;\n\n    _addStartArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path.cx1 + params.x,\n        path.cy1 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      lcx1 = path['cx' + lc];\n      lcy1 = path['cy' + lc];\n      lcx2 = path['cx' + (lc + 1)];\n      lcy2 = path['cy' + (lc + 1)];\n      // If next coordinates are given\n      if (lx !== undefined && ly !== undefined && lcx1 !== undefined && lcy1 !== undefined && lcx2 !== undefined && lcy2 !== undefined) {\n        // Draw next curve\n        ctx.bezierCurveTo(lcx1 + params.x, lcy1 + params.y, lcx2 + params.x, lcy2 + params.y, lx + params.x, ly + params.y);\n        l += 1;\n        lc += 2;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    lc -= 2;\n    _addEndArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path['cx' + (lc + 1)] + params.x,\n        path['cy' + (lc + 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws Bezier curve\n  $.fn.drawBezier = function drawBezier(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawBezier);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawBezier($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves the x-coordinate for the given vector angle and length\n  function _getVectorX(params, angle, length) {\n    angle *= params._toRad;\n    angle -= (PI / 2);\n    return (length * cos(angle));\n  }\n// Retrieves the y-coordinate for the given vector angle and length\n  function _getVectorY(params, angle, length) {\n    angle *= params._toRad;\n    angle -= (PI / 2);\n    return (length * sin(angle));\n  }\n\n// Draws vector (internal) #2\n  function _drawVector(canvas, ctx, params, path) {\n    var l, angle, length,\n        offsetX, offsetY,\n        x, y,\n        x3, y3,\n        x4, y4;\n\n    // Determine offset from dragging\n    if (params === path) {\n      offsetX = 0;\n      offsetY = 0;\n    } else {\n      offsetX = params.x;\n      offsetY = params.y;\n    }\n\n    l = 1;\n    x = x3 = x4 = path.x + offsetX;\n    y = y3 = y4 = path.y + offsetY;\n\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        x + _getVectorX(params, path.a1, path.l1),\n        y + _getVectorY(params, path.a1, path.l1),\n        x,\n        y\n    );\n\n    // The vector starts at the given (x, y) coordinates\n    if (path.x !== undefined && path.y !== undefined) {\n      ctx.moveTo(x, y);\n    }\n    while (true) {\n\n      angle = path['a' + l];\n      length = path['l' + l];\n\n      if (angle !== undefined && length !== undefined) {\n        // Convert the angle to radians with 0 degrees starting at north\n        // Keep track of last two coordinates\n        x3 = x4;\n        y3 = y4;\n        // Compute (x, y) coordinates from angle and length\n        x4 += _getVectorX(params, angle, length);\n        y4 += _getVectorY(params, angle, length);\n        ctx.lineTo(x4, y4);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n\n    }\n    _addEndArrow(\n        canvas, ctx,\n        params, path,\n        x3, y3,\n        x4, y4\n    );\n  }\n\n// Draws vector\n  $.fn.drawVector = function drawVector(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawVector);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawVector($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws a path consisting of one or more subpaths\n  $.fn.drawPath = function drawPath(args) {\n    var $canvases = this, e, ctx,\n        params,\n        l, lp;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawPath);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          l = 1;\n          while (true) {\n            lp = params['p' + l];\n            if (lp !== undefined) {\n              lp = new jCanvasObject(lp);\n              if (lp.type === 'line') {\n                _drawLine($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'quadratic') {\n                _drawQuadratic($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'bezier') {\n                _drawBezier($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'vector') {\n                _drawVector($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'arc') {\n                _drawArc($canvases[e], ctx, params, lp);\n              }\n              l += 1;\n            } else {\n              break;\n            }\n          }\n\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Text API */\n\n// Calculates font string and set it as the canvas font\n  function _setCanvasFont(canvas, ctx, params) {\n    // Otherwise, use the given font attributes\n    if (!isNaN(Number(params.fontSize))) {\n      // Give font size units if it doesn't have any\n      params.fontSize += 'px';\n    }\n    // Set font using given font properties\n    ctx.font = params.fontStyle + ' ' + params.fontSize + ' ' + params.fontFamily;\n  }\n\n// Measures canvas text\n  function _measureText(canvas, ctx, params, lines) {\n    var originalSize, curWidth, l,\n        propCache = caches.propCache;\n\n    // Used cached width/height if possible\n    if (propCache.text === params.text && propCache.fontStyle === params.fontStyle && propCache.fontSize === params.fontSize && propCache.fontFamily === params.fontFamily && propCache.maxWidth === params.maxWidth && propCache.lineHeight === params.lineHeight) {\n\n      params.width = propCache.width;\n      params.height = propCache.height;\n\n    } else {\n      // Calculate text dimensions only once\n\n      // Calculate width of first line (for comparison)\n      params.width = ctx.measureText(lines[0]).width;\n\n      // Get width of longest line\n      for (l = 1; l < lines.length; l += 1) {\n\n        curWidth = ctx.measureText(lines[l]).width;\n        // Ensure text's width is the width of its longest line\n        if (curWidth > params.width) {\n          params.width = curWidth;\n        }\n\n      }\n\n      // Save original font size\n      originalSize = canvas.style.fontSize;\n      // Temporarily set canvas font size to retrieve size in pixels\n      canvas.style.fontSize = params.fontSize;\n      // Save text width and height in parameters object\n      params.height = parseFloat($.css(canvas, 'fontSize')) * lines.length * params.lineHeight;\n      // Reset font size to original size\n      canvas.style.fontSize = originalSize;\n    }\n  }\n\n// Wraps a string of text within a defined width\n  function _wrapText(ctx, params) {\n    var allText = String(params.text),\n        // Maximum line width (optional)\n        maxWidth = params.maxWidth,\n        // Lines created by manual line breaks (\\n)\n        manualLines = allText.split('\\n'),\n        // All lines created manually and by wrapping\n        allLines = [],\n        // Other variables\n        lines, line, l,\n        text, words, w;\n\n    // Loop through manually-broken lines\n    for (l = 0; l < manualLines.length; l += 1) {\n\n      text = manualLines[l];\n      // Split line into list of words\n      words = text.split(' ');\n      lines = [];\n      line = '';\n\n      // If text is short enough initially\n      // Or, if the text consists of only one word\n      if (words.length === 1 || ctx.measureText(text).width < maxWidth) {\n\n        // No need to wrap text\n        lines = [text];\n\n      } else {\n\n        // Wrap lines\n        for (w = 0; w < words.length; w += 1) {\n\n          // Once line gets too wide, push word to next line\n          if (ctx.measureText(line + words[w]).width > maxWidth) {\n            // This check prevents empty lines from being created\n            if (line !== '') {\n              lines.push(line);\n            }\n            // Start new line and repeat process\n            line = '';\n          }\n          // Add words to line until the line is too wide\n          line += words[w];\n          // Do not add a space after the last word\n          if (w !== (words.length - 1)) {\n            line += ' ';\n          }\n        }\n        // The last word should always be pushed\n        lines.push(line);\n\n      }\n      // Remove extra space at the end of each line\n      allLines = allLines.concat(\n          lines\n              .join('\\n')\n              .replace(/((\\n))|($)/gi, '$2')\n              .split('\\n')\n      );\n\n    }\n\n    return allLines;\n  }\n\n// Draws text on canvas\n  $.fn.drawText = function drawText(args) {\n    var $canvases = this, e, ctx,\n        params, layer,\n        lines, line, l,\n        fontSize, constantCloseness = 500,\n        nchars, chars, ch, c,\n        x, y;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawText);\n        if (params.visible) {\n\n          // Set text-specific properties\n          ctx.textBaseline = params.baseline;\n          ctx.textAlign = params.align;\n\n          // Set canvas font using given properties\n          _setCanvasFont($canvases[e], ctx, params);\n\n          if (params.maxWidth !== null) {\n            // Wrap text using an internal function\n            lines = _wrapText(ctx, params);\n          } else {\n            // Convert string of text to list of lines\n            lines = params.text\n                .toString()\n                .split('\\n');\n          }\n\n          // Calculate text's width and height\n          _measureText($canvases[e], ctx, params, lines);\n\n          // If text is a layer\n          if (layer) {\n            // Copy calculated width/height to layer object\n            layer.width = params.width;\n            layer.height = params.height;\n          }\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Adjust text position to accomodate different horizontal alignments\n          x = params.x;\n          if (params.align === 'left') {\n            if (params.respectAlign) {\n              // Realign text to the left if chosen\n              params.x += params.width / 2;\n            } else {\n              // Center text block by default\n              x -= params.width / 2;\n            }\n          } else if (params.align === 'right') {\n            if (params.respectAlign) {\n              // Realign text to the right if chosen\n              params.x -= params.width / 2;\n            } else {\n              // Center text block by default\n              x += params.width / 2;\n            }\n          }\n\n          if (params.radius) {\n\n            fontSize = parseFloat(params.fontSize);\n\n            // Greater values move clockwise\n            if (params.letterSpacing === null) {\n              params.letterSpacing = fontSize / constantCloseness;\n            }\n\n            // Loop through each line of text\n            for (l = 0; l < lines.length; l += 1) {\n              ctx.save();\n              ctx.translate(params.x, params.y);\n              line = lines[l];\n              if (params.flipArcText) {\n                chars = line.split('');\n                chars.reverse();\n                line = chars.join('');\n              }\n              nchars = line.length;\n              ctx.rotate(-(PI * params.letterSpacing * (nchars - 1)) / 2);\n              // Loop through characters on each line\n              for (c = 0; c < nchars; c += 1) {\n                ch = line[c];\n                // If character is not the first character\n                if (c !== 0) {\n                  // Rotate character onto arc\n                  ctx.rotate(PI * params.letterSpacing);\n                }\n                ctx.save();\n                ctx.translate(0, -params.radius);\n                if (params.flipArcText) {\n                  ctx.scale(-1, -1);\n                }\n                ctx.fillText(ch, 0, 0);\n                // Prevent extra shadow created by stroke (but only when fill is present)\n                if (params.fillStyle !== 'transparent') {\n                  ctx.shadowColor = 'transparent';\n                }\n                if (params.strokeWidth !== 0) {\n                  // Only stroke if the stroke is not 0\n                  ctx.strokeText(ch, 0, 0);\n                }\n                ctx.restore();\n              }\n              params.radius -= fontSize;\n              params.letterSpacing += fontSize / (constantCloseness * 2 * PI);\n              ctx.restore();\n            }\n\n          } else {\n\n            // Draw each line of text separately\n            for (l = 0; l < lines.length; l += 1) {\n              line = lines[l];\n              // Add line offset to center point, but subtract some to center everything\n              y = params.y + (l * params.height / lines.length) - (((lines.length - 1) * params.height / lines.length) / 2);\n\n              ctx.shadowColor = params.shadowColor;\n\n              // Fill & stroke text\n              ctx.fillText(line, x, y);\n              // Prevent extra shadow created by stroke (but only when fill is present)\n              if (params.fillStyle !== 'transparent') {\n                ctx.shadowColor = 'transparent';\n              }\n              if (params.strokeWidth !== 0) {\n                // Only stroke if the stroke is not 0\n                ctx.strokeText(line, x, y);\n              }\n\n            }\n\n          }\n\n          // Adjust bounding box according to text baseline\n          y = 0;\n          if (params.baseline === 'top') {\n            y += params.height / 2;\n          } else if (params.baseline === 'bottom') {\n            y -= params.height / 2;\n          }\n\n          // Detect jCanvas events\n          if (params._event) {\n            ctx.beginPath();\n            ctx.rect(\n                params.x - (params.width / 2),\n                params.y - (params.height / 2) + y,\n                params.width,\n                params.height\n            );\n            _detectEvents($canvases[e], ctx, params);\n            // Close path and configure masking\n            ctx.closePath();\n          }\n          _restoreTransform(ctx, params);\n\n        }\n      }\n    }\n    // Cache jCanvas parameters object for efficiency\n    caches.propCache = params;\n    return $canvases;\n  };\n\n// Measures text width/height using the given parameters\n  $.fn.measureText = function measureText(args) {\n    var $canvases = this, ctx,\n        params, lines;\n\n    // Attempt to retrieve layer\n    params = $canvases.getLayer(args);\n    // If layer does not exist or if returned object is not a jCanvas layer\n    if (!params || (params && !params._layer)) {\n      params = new jCanvasObject(args);\n    }\n\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      // Set canvas font using given properties\n      _setCanvasFont($canvases[0], ctx, params);\n      // Calculate width and height of text\n      if (params.maxWidth !== null) {\n        lines = _wrapText(ctx, params);\n      } else {\n        lines = params.text.split('\\n');\n      }\n      _measureText($canvases[0], ctx, params, lines);\n\n\n    }\n\n    return params;\n  };\n\n  /* Image API */\n\n// Draws image on canvas\n  $.fn.drawImage = function drawImage(args) {\n    var $canvases = this, canvas, e, ctx, data,\n        params, layer,\n        img, imgCtx, source,\n        imageCache = caches.imageCache;\n\n    // Draw image function\n    function draw(canvas, ctx, data, params, layer) {\n\n      // If width and sWidth are not defined, use image width\n      if (params.width === null && params.sWidth === null) {\n        params.width = params.sWidth = img.width;\n      }\n      // If width and sHeight are not defined, use image height\n      if (params.height === null && params.sHeight === null) {\n        params.height = params.sHeight = img.height;\n      }\n\n      // Ensure image layer's width and height are accurate\n      if (layer) {\n        layer.width = params.width;\n        layer.height = params.height;\n      }\n\n      // Only crop image if all cropping properties are given\n      if (params.sWidth !== null && params.sHeight !== null && params.sx !== null && params.sy !== null) {\n\n        // If width is not defined, use the given sWidth\n        if (params.width === null) {\n          params.width = params.sWidth;\n        }\n        // If height is not defined, use the given sHeight\n        if (params.height === null) {\n          params.height = params.sHeight;\n        }\n\n        // Optionally crop from top-left corner of region\n        if (params.cropFromCenter) {\n          params.sx += params.sWidth / 2;\n          params.sy += params.sHeight / 2;\n        }\n\n        // Ensure cropped region does not escape image boundaries\n\n        // Top\n        if ((params.sy - (params.sHeight / 2)) < 0) {\n          params.sy = (params.sHeight / 2);\n        }\n        // Bottom\n        if ((params.sy + (params.sHeight / 2)) > img.height) {\n          params.sy = img.height - (params.sHeight / 2);\n        }\n        // Left\n        if ((params.sx - (params.sWidth / 2)) < 0) {\n          params.sx = (params.sWidth / 2);\n        }\n        // Right\n        if ((params.sx + (params.sWidth / 2)) > img.width) {\n          params.sx = img.width - (params.sWidth / 2);\n        }\n\n        _transformShape(canvas, ctx, params, params.width, params.height);\n        _setGlobalProps(canvas, ctx, params);\n\n        // Draw image\n        ctx.drawImage(\n            img,\n            params.sx - (params.sWidth / 2),\n            params.sy - (params.sHeight / 2),\n            params.sWidth,\n            params.sHeight,\n            params.x - (params.width / 2),\n            params.y - (params.height / 2),\n            params.width,\n            params.height\n        );\n\n      } else {\n        // Show entire image if no crop region is defined\n\n        _transformShape(canvas, ctx, params, params.width, params.height);\n        _setGlobalProps(canvas, ctx, params);\n\n        // Draw image on canvas\n        ctx.drawImage(\n            img,\n            params.x - (params.width / 2),\n            params.y - (params.height / 2),\n            params.width,\n            params.height\n        );\n\n      }\n\n      // Draw invisible rectangle to allow for events and masking\n      ctx.beginPath();\n      ctx.rect(\n          params.x - (params.width / 2),\n          params.y - (params.height / 2),\n          params.width,\n          params.height\n      );\n      // Check for jCanvas events\n      _detectEvents(canvas, ctx, params);\n      // Close path and configure masking\n      ctx.closePath();\n      _restoreTransform(ctx, params);\n      _enableMasking(ctx, data, params);\n    }\n    // On load function\n    function onload(canvas, ctx, data, params, layer) {\n      return function () {\n        var $canvas = $(canvas);\n        draw(canvas, ctx, data, params, layer);\n        if (params.layer) {\n          // Trigger 'load' event for layers\n          _triggerLayerEvent($canvas, data, layer, 'load');\n        } else if (params.load) {\n          // Run 'load' callback for non-layers\n          params.load.call($canvas[0], layer);\n        }\n        // Continue drawing successive layers after this image layer has loaded\n        if (params.layer) {\n          // Store list of previous masks for each layer\n          layer._masks = data.transforms.masks.slice(0);\n          if (params._next) {\n            // Draw successive layers\n            $canvas.drawLayers({\n              clear: false,\n              resetFire: true,\n              index: params._next\n            });\n          }\n        }\n      };\n    }\n    for (e = 0; e < $canvases.length; e += 1) {\n      canvas = $canvases[e];\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n        params = new jCanvasObject(args);\n        layer = _addLayer($canvases[e], params, args, drawImage);\n        if (params.visible) {\n\n          // Cache the given source\n          source = params.source;\n\n          imgCtx = source.getContext;\n          if (source.src || imgCtx) {\n            // Use image or canvas element if given\n            img = source;\n          } else if (source) {\n            if (imageCache[source] && imageCache[source].complete) {\n              // Get the image element from the cache if possible\n              img = imageCache[source];\n            } else {\n              // Otherwise, get the image from the given source URL\n              img = new Image();\n              // If source URL is not a data URL\n              if (!source.match(/^data:/i)) {\n                // Set crossOrigin for this image\n                img.crossOrigin = params.crossOrigin;\n              }\n              img.src = source;\n              // Save image in cache for improved performance\n              imageCache[source] = img;\n            }\n          }\n\n          if (img) {\n            if (img.complete || imgCtx) {\n              // Draw image if already loaded\n              onload(canvas, ctx, data, params, layer)();\n            } else {\n              // Otherwise, draw image when it loads\n              img.onload = onload(canvas, ctx, data, params, layer);\n              // Fix onload() bug in IE9\n              img.src = img.src;\n            }\n          }\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Creates a canvas pattern object\n  $.fn.createPattern = function createPattern(args) {\n    var $canvases = this, ctx,\n        params,\n        img, imgCtx,\n        pattern, source;\n\n    // Function to be called when pattern loads\n    function onload() {\n      // Create pattern\n      pattern = ctx.createPattern(img, params.repeat);\n      // Run callback function if defined\n      if (params.load) {\n        params.load.call($canvases[0], pattern);\n      }\n    }\n\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      params = new jCanvasObject(args);\n\n      // Cache the given source\n      source = params.source;\n\n      // Draw when image is loaded (if load() callback function is defined)\n\n      if (isFunction(source)) {\n        // Draw pattern using function if given\n\n        img = $('<canvas />')[0];\n        img.width = params.width;\n        img.height = params.height;\n        imgCtx = _getContext(img);\n        source.call(img, imgCtx);\n        onload();\n\n      } else {\n        // Otherwise, draw pattern using source image\n\n        imgCtx = source.getContext;\n        if (source.src || imgCtx) {\n          // Use image element if given\n          img = source;\n        } else {\n          // Use URL if given to get the image\n          img = new Image();\n          // If source URL is not a data URL\n          if (!source.match(/^data:/i)) {\n            // Set crossOrigin for this image\n            img.crossOrigin = params.crossOrigin;\n          }\n          img.src = source;\n        }\n\n        // Create pattern if already loaded\n        if (img.complete || imgCtx) {\n          onload();\n        } else {\n          img.onload = onload;\n          // Fix onload() bug in IE9\n          img.src = img.src;\n        }\n\n      }\n\n    } else {\n\n      pattern = null;\n\n    }\n    return pattern;\n  };\n\n// Creates a canvas gradient object\n  $.fn.createGradient = function createGradient(args) {\n    var $canvases = this, ctx,\n        params,\n        gradient,\n        stops = [], nstops,\n        start, end,\n        i, a, n, p;\n\n    params = new jCanvasObject(args);\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      // Gradient coordinates must be defined\n      params.x1 = params.x1 || 0;\n      params.y1 = params.y1 || 0;\n      params.x2 = params.x2 || 0;\n      params.y2 = params.y2 || 0;\n\n      if (params.r1 !== null && params.r2 !== null) {\n        // Create radial gradient if chosen\n        gradient = ctx.createRadialGradient(params.x1, params.y1, params.r1, params.x2, params.y2, params.r2);\n      } else {\n        // Otherwise, create a linear gradient by default\n        gradient = ctx.createLinearGradient(params.x1, params.y1, params.x2, params.y2);\n      }\n\n      // Count number of color stops\n      for (i = 1; params['c' + i] !== undefined; i += 1) {\n        if (params['s' + i] !== undefined) {\n          stops.push(params['s' + i]);\n        } else {\n          stops.push(null);\n        }\n      }\n      nstops = stops.length;\n\n      // Define start stop if not already defined\n      if (stops[0] === null) {\n        stops[0] = 0;\n      }\n      // Define end stop if not already defined\n      if (stops[nstops - 1] === null) {\n        stops[nstops - 1] = 1;\n      }\n\n      // Loop through color stops to fill in the blanks\n      for (i = 0; i < nstops; i += 1) {\n        // A progression, in this context, is defined as all of the color stops between and including two known color stops\n\n        if (stops[i] !== null) {\n          // Start a new progression if stop is a number\n\n          // Number of stops in current progression\n          n = 1;\n          // Current iteration in current progression\n          p = 0;\n          start = stops[i];\n\n          // Look ahead to find end stop\n          for (a = (i + 1); a < nstops; a += 1) {\n            if (stops[a] !== null) {\n              // If this future stop is a number, make it the end stop for this progression\n              end = stops[a];\n              break;\n            } else {\n              // Otherwise, keep looking ahead\n              n += 1;\n            }\n          }\n\n          // Ensure start stop is not greater than end stop\n          if (start > end) {\n            stops[a] = stops[i];\n          }\n\n        } else if (stops[i] === null) {\n          // Calculate stop if not initially given\n          p += 1;\n          stops[i] = start + (p * ((end - start) / n));\n        }\n        // Add color stop to gradient object\n        gradient.addColorStop(stops[i], params['c' + (i + 1)]);\n      }\n\n    } else {\n      gradient = null;\n    }\n    return gradient;\n  };\n\n// Manipulates pixels on the canvas\n  $.fn.setPixels = function setPixels(args) {\n    var $canvases = this,\n        canvas, e, ctx, canvasData,\n        params,\n        px,\n        imgData, pixelData, i, len;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      canvas = $canvases[e];\n      ctx = _getContext(canvas);\n      canvasData = _getCanvasData($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer(canvas, params, args, setPixels);\n        _transformShape($canvases[e], ctx, params, params.width, params.height);\n\n        // Use entire canvas of x, y, width, or height is not defined\n        if (params.width === null || params.height === null) {\n          params.width = canvas.width;\n          params.height = canvas.height;\n          params.x = params.width / 2;\n          params.y = params.height / 2;\n        }\n\n        if (params.width !== 0 && params.height !== 0) {\n          // Only set pixels if width and height are not zero\n\n          imgData = ctx.getImageData(\n              (params.x - (params.width / 2)) * canvasData.pixelRatio,\n              (params.y - (params.height / 2)) * canvasData.pixelRatio,\n              params.width * canvasData.pixelRatio,\n              params.height * canvasData.pixelRatio\n          );\n          pixelData = imgData.data;\n          len = pixelData.length;\n\n          // Loop through pixels with the \"each\" callback function\n          if (params.each) {\n            for (i = 0; i < len; i += 4) {\n              px = {\n                r: pixelData[i],\n                g: pixelData[i + 1],\n                b: pixelData[i + 2],\n                a: pixelData[i + 3]\n              };\n              params.each.call(canvas, px, params);\n              pixelData[i] = px.r;\n              pixelData[i + 1] = px.g;\n              pixelData[i + 2] = px.b;\n              pixelData[i + 3] = px.a;\n            }\n          }\n          // Put pixels on canvas\n          ctx.putImageData(\n              imgData,\n              (params.x - (params.width / 2)) * canvasData.pixelRatio,\n              (params.y - (params.height / 2)) * canvasData.pixelRatio\n          );\n          // Restore transformation\n          ctx.restore();\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves canvas image as data URL\n  $.fn.getCanvasImage = function getCanvasImage(type, quality) {\n    var $canvases = this, canvas,\n        dataURL = null;\n    if ($canvases.length !== 0) {\n      canvas = $canvases[0];\n      if (canvas.toDataURL) {\n        // JPEG quality defaults to 1\n        if (quality === undefined) {\n          quality = 1;\n        }\n        dataURL = canvas.toDataURL('image/' + type, quality);\n      }\n    }\n    return dataURL;\n  };\n\n// Scales canvas based on the device's pixel ratio\n  $.fn.detectPixelRatio = function detectPixelRatio(callback) {\n    var $canvases = this,\n        canvas, e, ctx,\n        devicePixelRatio, backingStoreRatio, ratio,\n        oldWidth, oldHeight,\n        data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      // Get canvas and its associated data\n      canvas = $canvases[e];\n      ctx = _getContext(canvas);\n      data = _getCanvasData($canvases[e]);\n\n      // If canvas has not already been scaled with this method\n      if (!data.scaled) {\n\n        // Determine device pixel ratios\n        devicePixelRatio = window.devicePixelRatio || 1;\n        backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n            ctx.mozBackingStorePixelRatio ||\n            ctx.msBackingStorePixelRatio ||\n            ctx.oBackingStorePixelRatio ||\n            ctx.backingStorePixelRatio || 1;\n\n        // Calculate general ratio based on the two given ratios\n        ratio = devicePixelRatio / backingStoreRatio;\n\n        if (ratio !== 1) {\n          // Scale canvas relative to ratio\n\n          // Get the current canvas dimensions for future use\n          oldWidth = canvas.width;\n          oldHeight = canvas.height;\n\n          // Resize canvas relative to the determined ratio\n          canvas.width = oldWidth * ratio;\n          canvas.height = oldHeight * ratio;\n\n          // Scale canvas back to original dimensions via CSS\n          canvas.style.width = oldWidth + 'px';\n          canvas.style.height = oldHeight + 'px';\n\n          // Scale context to counter the manual scaling of canvas\n          ctx.scale(ratio, ratio);\n\n        }\n\n        // Set pixel ratio on canvas data object\n        data.pixelRatio = ratio;\n        // Ensure that this method can only be called once for any given canvas\n        data.scaled = true;\n\n        // Call the given callback function with the ratio as its only argument\n        if (callback) {\n          callback.call(canvas, ratio);\n        }\n\n      }\n\n    }\n    return $canvases;\n  };\n\n// Clears the jCanvas cache\n  jCanvas.clearCache = function clearCache() {\n    var cacheName;\n    for (cacheName in caches) {\n      if (Object.prototype.hasOwnProperty.call(caches, cacheName)) {\n        caches[cacheName] = {};\n      }\n    }\n  };\n\n// Enable canvas feature detection with $.support\n  $.support.canvas = ($('<canvas />')[0].getContext !== undefined);\n\n// Export jCanvas functions\n  extendObject(jCanvas, {\n    defaults: defaults,\n    setGlobalProps: _setGlobalProps,\n    transformShape: _transformShape,\n    detectEvents: _detectEvents,\n    closePath: _closePath,\n    setCanvasFont: _setCanvasFont,\n    measureText: _measureText\n  });\n  $.jCanvas = jCanvas;\n  $.jCanvasObject = jCanvasObject;\n\n}));"]}