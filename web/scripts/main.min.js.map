{"version":3,"sources":["script.js","main.js","jcanvas.js"],"names":["cartesian2Polar","x","y","upX","CenterX","upY","CenterY","distance","Math","sqrt","radians","atan2","degr","PI","polarCoor","cartesian2Dec","radius","tan","pow","decCoor","X","Y","cartesian2DecForBorder","newDegr","hexInArray","h","m","slice","match","parseInt","hexArrayInRgbString","rgb","changeColorLayers","color","numLayers","arColor","tempColor","arRBA","i","difColorRed","difColorGreen","difColorBlue","red","green","blue","floor","console","log","createSector","data","arColors","difRadius","bigRadius","$","drawArc","layer","name","id","strokeStyle","strokeWidth","start","beginAngle","end","endAngle","drawSlice","groups","fillStyle","dblclick","polar","eventX","eventY","link","attr","circle_id","removeClass","addClass","text","click","setLayer","shadowColor","shadowBlur","drawLayers","mouseout","drawText","fontFamily","fontSize","rotate","css","createSectorNew","sector_id","nameArc","nameSector","nameGroup","canvas","mask","restoreCanvas","drawLayer","createBorderSector","endCoord","drawVector","a1","l1","borderForSector","angle","sectorLeftId","sectorRightId","angleMin","angelMax","LabelCoord","leftCoord","rightCoord","draggable","radiusLabel","circlePath","circleRadius","circleCenterX","circleCenterY","xMin","yMin","xMax","yMax","sectorLeft","sectorRight","shadowLabelSize","dragstop","pol","getLayer","circleId","beginAngleL","colorL","endAngleR","colorR","newLeftSectorMinAngle","newRightSectorMinAngle","oldLeftSectorMinAngle","oldRightSectorMinAngle","coefficientLeft","coefficientRight","updateLabelPositionByChangingSector","removeLayerGroup","setHightMoveLayerToLayer","drag","mouseover","rayAndCircleByLabel","dec","colorRayAndCircleByLabel","drawLine","x1","y1","x2","y2","createNamePopUpLabel","heightPopUp","widthPopUp","drawRect","width","height","cornerRadius","maxWidth","createLabel","colorLabel","label_radius","label_angle","label_id","updateCoordinateLabel","delRayNamePopUpAndCircleByLabel","Label","colorSelectLabel","delRayNamePopUpAndCircleAllLabels","setLinkLabelsByRadiusAndAngle","removeLinkLabelsByRadiusAndAngle","setMoveLayerToLayer","index","array","moveLayer","dragLayers","getLayers","forEach","setFillStyleToLayer","angleBorderMin","angleBorderMax","radiusBorderMin","radiusBorderMax","labels","getLayerGroup","deleteFillStyleToLayer","delNamePopUpByLabel","border","updateLabelPosition","label","sector_left","newAngle","sector_right","labelId","post","done","removeLayer","deleteField","a","arrInput","parentNode","getElementsByTagName","contDiv","value","removeChild","countOfFields","addField","maxFieldLimit","alert","curFieldNameId","div","document","createElement","setAttribute","innerHTML","getElementById","appendChild","isLocalhost","Boolean","window","location","hostname","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","e","error","jQuery","global","factory","module","exports","w","this","jCanvasObject","args","propName","params","Object","prototype","hasOwnProperty","call","jCanvasDefaults","extendObject","baseDefaults","isString","operand","typeOf","isNumeric","isNaN","Number","parseFloat","_getContext","getContext","_coerceNumericProps","props","propType","propValue","undefined","String","_cloneTransforms","transforms","masks","_saveCanvas","ctx","save","savedTransforms","push","_restoreCanvas","length","baseTransforms","restore","pop","_setStyle","styleName","isFunction","_setGlobalProps","lineWidth","rounded","lineCap","lineJoin","strokeCap","strokeJoin","miterLimit","strokeDash","setLineDash","webkitLineDash","lineDashOffset","webkitLineDashOffset","mozDashOffset","strokeDashOffset","shadowOffsetX","shadowX","shadowOffsetY","shadowY","globalAlpha","opacity","globalCompositeOperation","compositing","imageSmoothing","imageSmoothingEnabled","_enableMasking","autosave","clip","_args","_restoreTransform","_transformed","_closePath","closed","closePath","shadowStroke","stroke","fill","_getCanvasData","_transformShape","_toRad","inDegrees","fromCenter","_centered","_rotateCanvas","scale","scaleX","scaleY","_scaleCanvas","translate","translateX","translateY","_translateCanvas","dataCache","caches","_canvas","_data","layers","names","eventHooks","intersecting","lastIntersected","cursor","dragging","event","type","events","animating","animated","pixelRatio","scaled","redrawOnMousemove","_addLayerEvents","$canvas","eventName","jCanvas","cursors","_addExplicitLayerEvent","bind","l","_triggerLayerEvent","_hovered","triggerLayerEvent","_addLayerEvent","_event","_enableDrag","dragHelperEvents","_updateLayerName","nameMap","_updateLayerGroups","group","groupName","g","groupMap","splice","_getIntersectingLayer","_masks","intersects","intangible","_drawLayer","nextLayerIndex","visible","_method","_next","_handleLayerDrag","eventType","dragGroups","newX","newY","bringToFront","_startX","_startY","_endX","_eventX","_endY","_eventY","updateDragX","updateDragY","dx","dy","restrictDragToAxis","centerX","centerY","r","k","tempX","tempY","px","py","qx","qy","rx","ry","Result","absSumMin","abs","absSumMax","originalRedrawOnMousemove","_setCursor","inArray","prefix","_resetCursor","_runEventCallback","callbacks","arg","_running","_layerCanFireEvent","disableEvents","tangibleEvents","_addLayer","method","_layer","fn","maps","drawings","measureText","_showProps","obj","cssProp","p","_hideProps","reset","propsObj","_parseEndValues","endValues","subPropName","subPropValue","isPlainObject","_removeSubPropAliases","indexOf","_colorToRgbArray","originalColor","elem","multiple","head","style","_animateColor","fx","n","now","pos","round","join","nodeName","prop","_supportColorProps","step","_getTouchEventName","touchEvents","_getMouseEventName","mouseEvents","_createEvent","eventCallback","eventCache","offsetX","offsetY","helperEventName","resetFire","preventDefault","touchEventName","_createEvents","eventNames","_detectEvents","isPointInPath","isPointInStroke","cos","sin","_getCoterminal","_getArcX","_getArcY","_drawArc","path","x3","y3","x4","y4","diff","ccw","_addStartArrow","arc","_addEndArrow","_addArrow","leftX","leftY","rightX","rightY","arrowRadius","arrowAngle","moveTo","lineTo","_arrowAngleConverted","startArrow","endArrow","_drawLine","lx","ly","_drawQuadratic","lcx","lcy","cx1","cy1","quadraticCurveTo","_drawBezier","lc","lcx1","lcy1","lcx2","lcy2","bezierCurveTo","_getVectorX","_getVectorY","_drawVector","_setCanvasFont","font","fontStyle","_measureText","lines","originalSize","curWidth","propCache","lineHeight","_wrapText","line","words","allText","manualLines","split","allLines","concat","replace","defaults","Image","Array","getComputedStyle","extend","toString","toLowerCase","arraySlice","jQueryEventFix","fix","imageCache","future","align","baseline","concavity","count","cropFromCenter","crossOrigin","letterSpacing","r1","r2","repeat","respectAlign","sHeight","sides","source","spread","sWidth","sx","sy","plugin","self","$canvases","getEventHooks","setEventHooks","callback","matching","layerId","idType","groupId","getLayerIndex","substr","isEmptyObject","setLayers","setLayerGroup","removeLayers","addLayerToGroup","removeLayerFromGroup","styles","documentElement","pre","OLink","lastLayer","lastIndex","isImageLayer","clear","clearCanvas","_fired","drawImage","addLayer","animateLayer","complete","_animating","parts","hidden","_pos","arguments","duration","easing","draw","animate","animateLayerGroup","apply","delayLayer","delay","delayLayerGroup","stopLayer","clearQueue","stop","stopLayerGroup","mousedown","mouseup","mousemove","touchstart","touchend","touchmove","offset","originalEvent","touches","changedTouches","pageX","currentTarget","left","pageY","top","bezier","ellipse","function","image","polygon","quadratic","rectangle","vector","setTransform","clearRect","saveCanvas","rotateCanvas","scaleCanvas","translateCanvas","temp","beginPath","rect","drawEllipse","controlW","controlH","drawPolygon","theta","dtheta","hdtheta","apothem","drawQuadratic","drawBezier","drawPath","lp","nchars","chars","ch","c","constantCloseness","textBaseline","textAlign","flipArcText","reverse","fillText","strokeText","img","onload","load","imgCtx","src","createPattern","pattern","createGradient","gradient","nstops","stops","createRadialGradient","createLinearGradient","addColorStop","setPixels","canvasData","imgData","pixelData","len","getImageData","each","b","putImageData","getCanvasImage","quality","dataURL","toDataURL","detectPixelRatio","devicePixelRatio","backingStoreRatio","ratio","oldWidth","oldHeight","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","clearCache","cacheName","support","setGlobalProps","transformShape","detectEvents","setCanvasFont","dataSector1","dataSector2","dataSector3","dataLabel1","dataLabel2","dataLabel3","dataLabel4","dataLabel5","ready"],"mappings":"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","file":"main.min.js","sourcesContent":["var CenterX = 300;\nvar CenterY = 300;\nconst bigRadius = 250;\nvar colorRayAndCircleByLabel = '#48D1CC';\nvar colorLabel = '#36c';\nvar radiusLabel = 15;\nvar colorSelectLabel = \"Red\";\nvar shadowLabelSize = 10;\nvar shadowColor = \"white\";\n\n/*\n * General functions\n * */\n\n/**\n *      .\n *\n * @param {float} x\n * @param {float} y\n * @returns {object}\n */\nfunction cartesian2Polar(x, y) {\n  var upX = (x-CenterX);\n  var upY = (y-CenterY);\n  distance = Math.sqrt(upX * upX + upY * upY);\n  radians = Math.atan2(upY, upX);\n  degr = radians*180/Math.PI+90;\n  polarCoor = {distance: distance, degr: degr};\n  return polarCoor;\n}\n\n/**\n * From polar in dec\n *\n * @param {float} radius\n * @param {float} degr\n * @returns {object}\n */\nfunction cartesian2Dec(radius, degr) {\n  radians = (degr-90)*(Math.PI/180);\n  if(degr >= 0 && degr <= 180){\n    tan  = Math.tan(radians);\n    x = Math.sqrt((Math.pow(radius,2))/(Math.pow(tan,2)+1));\n    y = x*tan;\n  }else{\n    tan  = Math.tan(-radians);\n    x = -Math.sqrt((Math.pow(radius,2))/(Math.pow(tan,2)+1));\n    y = -x*tan;\n  }\n  decCoor = {X: x+CenterX, Y: y+CenterY};\n  return decCoor;\n}\n\n/**\n * From polar in dec\n *\n * @param {float} radius\n * @param {float} degr\n * @returns {object}\n */\nfunction cartesian2DecForBorder(radius, degr) {\n  var newDegr = (degr-90);\n  radians = newDegr*(Math.PI/180);\n\n  if(newDegr >= 0 && newDegr <= 180){\n    tan  = Math.tan(radians);\n    x = Math.sqrt((radius*radius)/(tan*tan+1));\n    y = x*tan;\n  }else{\n    tan  = Math.tan(-radians);\n    x = Math.sqrt((radius*radius)/(tan*tan+1));\n    y = x*tan;\n  }\n\n  decCoor = {X: x, Y: y};\n\n  return decCoor;\n}\n\n/**\n *function for convert HEX -> rgba\n * */\n\nfunction hexInArray(h){\n  var m = h.slice(1).match(/.{2}/g);\n  m[0]=parseInt(m[0], 16);\n  m[1]=parseInt(m[1], 16);\n  m[2]=parseInt(m[2], 16);\n  return m;\n};\n\nfunction hexArrayInRgbString(m) {\n  var rgb = 'rgb('+m[0]+', '+m[1]+', '+m[2]+')';\n  return rgb;\n}\n\nfunction changeColorLayers(color,numLayers) {\n  var arColor = hexInArray(color);\n  var tempColor = arColor;\n  var arRBA = [];\n  var i = 0;\n  var difColorRed = (256-arColor[0])/numLayers;\n  var difColorGreen = (arColor[1])/(numLayers-1);\n  var difColorBlue = (arColor[2])/(numLayers-1);\n  var red = arColor[0] + difColorRed;\n  var green = arColor[1];\n  var blue = arColor[2];\n  for(red; red <= 256.01; red = red + difColorRed){\n    tempColor[0] = Math.floor(red);\n    tempColor[1] = Math.floor(green);\n    tempColor[2] = Math.floor(blue);\n    arRBA[i] = hexArrayInRgbString(tempColor);\n    green = green - difColorGreen;\n    blue = blue - difColorBlue;\n    i++;\n  }\n  console.log(arRBA);\n  return arRBA;\n}\n\n/*\n * Block functions for sectors\n * */\n\nfunction createSector(data) {\n  var arColors = changeColorLayers(data.color,data.numLayers);\n  var i;\n  var difRadius = bigRadius/data.numLayers;\n  var radius = bigRadius;\n\n  $('canvas').drawArc({\n    layer: true,\n    name: 'mainArc'+data.id,\n    strokeStyle: '#000',\n    strokeWidth: 2,\n    x: CenterX, y: CenterY,\n    radius: bigRadius,\n    start: data.beginAngle, end: data.endAngle,\n  });\n\n  for(i=1;i<=data.numLayers;i++){\n    $('canvas').drawSlice({\n      layer: true,\n      name: 'slice'+data.id+i,\n      groups: ['chart', 'slices'],\n      fillStyle: arColors[i-1],\n      x: CenterX, y: CenterY,\n      start: data.beginAngle, end: data.endAngle,\n      radius: radius,\n      strokeStyle: '#f60',\n      strokeWidth: 3,\n      dblclick: function(layer) {\n        var polar = cartesian2Polar(layer.eventX, layer.eventY);\n        var link = $('#create_label_link').attr('href','/app_dev.php/notes/new/'+data.circle_id+'?radius='+polar.distance/bigRadius+'&degr='+polar.degr);\n        link.removeClass( \"btn-primary\" ).addClass( \"btn-danger\" );\n        link.text('    ');\n      },\n      click: function(layer) {\n        $('canvas').setLayer('mainArc'+data.id, {\n          shadowColor: shadowColor,\n          shadowBlur: 20\n        })\n            .drawLayers();\n      },\n      mouseout: function(layer) {\n        $('canvas').setLayer('mainArc'+data.id, {\n          shadowBlur: 0\n        })\n            .drawLayers();\n      }\n    });\n    radius = radius - difRadius;\n  }\n\n  $('canvas')\n      .drawText({\n        layer: true,\n        fillStyle: '#c33',\n        fontFamily: 'Trebuchet MS, sans-serif',\n        fontSize: 18,\n        text: data.name,\n        x: CenterX, y: CenterY,\n        radius: bigRadius+20,\n        rotate: (data.beginAngle<data.endAngle)?(data.beginAngle+data.endAngle)/2:(data.beginAngle+data.endAngle+360)/2,\n        dblclick: function(layer) {\n          $('#pop_sector').css('display','block').attr('id',555);\n        },\n      });\n}\n\nfunction createSectorNew(sector_id, beginAngle, endAngle, circle_id, numLayers, color) {\n  var i;\n\n  var sector_id = sector_id;\n  var beginAngle = beginAngle;\n  var endAngle = endAngle;\n  var circle_id = circle_id;\n  var numLayers = numLayers;\n  var color = color;\n\n  var arColors = changeColorLayers(color,numLayers);\n  var difRadius = bigRadius/numLayers;\n  var radius = bigRadius;\n\n  var nameArc = 'mainArc_'+sector_id;\n  var nameSector = 'main_sector_'+sector_id;\n  var nameGroup = 'sector_'+sector_id;\n  var canvas = $('canvas');\n\n  for(i=1;i<=numLayers;i++){\n    canvas.drawSlice({\n      layer: true,\n      mask: true,\n      groups: [nameGroup],\n      fillStyle: arColors[i-1],\n      x: CenterX, y: CenterY,\n      start: beginAngle,\n      end: endAngle,\n      radius: radius,\n      strokeStyle: '#f60',\n      strokeWidth: 3,\n    }).restoreCanvas({\n      layer: true\n    });\n\n    radius = radius - difRadius;\n  }\n\n  canvas.drawSlice({\n    layer: true,\n    mask: true,\n    x: CenterX, y: CenterY,\n    start: beginAngle,\n    end: endAngle,\n    name: nameSector,\n    groups: [nameGroup],\n    circle_id: circle_id,\n    sector_id: sector_id,\n    radius: bigRadius,\n    numLayers : numLayers,\n    color : color,\n    dblclick: function(layer) {\n      var polar = cartesian2Polar(layer.eventX, layer.eventY);\n      var link = $('#create_label_link').attr('href','/app_dev.php/notes/new/'+layer.circle_id+'?radius='+polar.distance/bigRadius+'&degr='+polar.degr);\n      link.removeClass( \"btn-primary\" ).addClass( \"btn-danger\" );\n      link.text('    ');\n    },\n    click: function(layer) {\n      $('canvas').drawArc({\n        shadowBlur: 40,\n        shadowColor: 'white',\n        strokeStyle: 'white',\n        name: nameArc,\n        groups: [nameGroup],\n        strokeWidth: 3,\n        x: CenterX, y: CenterY,\n        radius: bigRadius,\n        start: beginAngle,\n        end: endAngle,\n      }).restoreCanvas({\n        layer: true\n      });\n    },\n    mouseout: function(layer) {\n      $('canvas').setLayer(nameArc, {\n        shadowBlur: 0\n      }).drawLayer();\n    }\n  });\n\n  canvas.restoreCanvas({\n    layer: true\n  });\n}\n\nfunction createBorderSector(data) {\n  var endCoord = cartesian2DecForBorder(bigRadius, data.beginAngle);\n  $('canvas').drawVector({\n    strokeStyle: 'white',\n    strokeWidth: 4,\n    x: CenterX, y: CenterY,\n    a1: endCoord.X, l1: endCoord.Y\n  });\n}\n\nfunction borderForSector(angle, sectorLeftId, sectorRightId, angleMin, angelMax) {\n  var LabelCoord = cartesian2Dec(bigRadius, angle);\n  var leftCoord = cartesian2Dec(bigRadius, angleMin+5);\n  var rightCoord = cartesian2Dec(bigRadius, angelMax-5);\n  $('canvas').drawArc({\n    layer: true,\n    draggable: true,\n    sectorLeftId: sectorLeftId,\n    sectorRightId: sectorRightId,\n    name: 'border_'+sectorLeftId+'_'+sectorRightId,\n    fillStyle: 'yellow',\n    x: LabelCoord.X, y: LabelCoord.Y,\n    radius: radiusLabel,\n    circlePath: true,\n    circleRadius: bigRadius,\n    circleCenterX: CenterX,\n    circleCenterY: CenterY,\n    xMin: leftCoord.X, yMin: leftCoord.Y,\n    xMax: rightCoord.X, yMax: rightCoord.Y,\n    data: {'sectorLeft': sectorLeftId , 'sectorRight': sectorRightId},\n    shadowColor: shadowColor,\n    shadowBlur: shadowLabelSize,\n    dragstop: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n      var sectorLeft = $('canvas').getLayer( 'main_sector_'+layer.sectorLeftId);\n      var sectorRight = $('canvas').getLayer('main_sector_'+layer.sectorRightId);\n\n      var circleId = sectorLeft.circle_id;\n      var numLayers = sectorLeft.numLayers;\n\n      var beginAngleL = sectorLeft.start;\n      var colorL = sectorLeft.color;\n\n      var endAngleR = sectorRight.end;\n      var colorR = sectorRight.color;\n\n      // sectorLeft.end = pol.degr;\n      // sectorRight.start = pol.degr;\n\n      var newLeftSectorMinAngle = sectorLeft.start;\n      var newRightSectorMinAngle = pol.degr;\n      var oldLeftSectorMinAngle = sectorLeft.start;\n      var oldRightSectorMinAngle = sectorRight.start;\n      var coefficientLeft = (pol.degr - beginAngleL)/(sectorLeft.end - sectorLeft.start);\n      var coefficientRight = (endAngleR - pol.degr)/(sectorRight.end - sectorRight.start);\n\n      updateLabelPositionByChangingSector(layer,coefficientLeft,coefficientRight,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle);\n\n      $('canvas').removeLayerGroup('sector_'+sectorLeftId);\n      createSectorNew(sectorLeftId,beginAngleL,pol.degr, circleId, numLayers, colorL);\n\n      $('canvas').removeLayerGroup('sector_'+sectorRightId);\n      createSectorNew(sectorRightId,pol.degr,endAngleR, circleId, numLayers, colorR);\n\n      setHightMoveLayerToLayer();\n\n      // $('canvas').removeLayer('border_'+sectorLeftId+'_'+sectorRightId);\n      // borderForSector(pol.degr,sectorLeftId,sectorRightId);\n\n\n      // updateCoordinateLabel(layer.data.circleId,layer.data.id,pol.distance/bigRadius,pol.degr);\n      // delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    drag: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n\n      $('canvas').drawVector({\n        strokeStyle: 'white',\n        strokeWidth: 4,\n        x: CenterX, y: CenterY,\n        a1: pol.degr, l1: pol.distance\n      });\n    },\n    mouseover: function(layer) {\n      $('canvas').drawVector({\n        strokeStyle: 'white',\n        strokeWidth: 4,\n        x: CenterX, y: CenterY,\n        a1: angle, l1: bigRadius\n      });\n    },\n    mouseout: function(layer) {\n      // var Label = $('canvas').getLayer(layer.name);\n      // Label.fillStyle = colorLabel;\n      // delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    dblclick: function(layer) {\n      // $('#pop_label_link').css('display','block').attr('href','/app_dev.php/notes/list/'+layer.data.circleId+'/'+layer.data.id+'/');\n    },\n  });\n}\n\n/*\n* Block functions for labels\n* */\n\nfunction rayAndCircleByLabel(layer,id) {\n  var pol = cartesian2Polar(layer.x, layer.y);\n  var dec = cartesian2Dec(bigRadius*2,pol.degr);\n  $('canvas').drawArc({\n    layer: true,\n    strokeStyle: colorRayAndCircleByLabel,\n    strokeWidth: 3,\n    name: 'circleByLabel'+id,\n    groups: ['circleByLabel'],\n    x: CenterX, y: CenterY,\n    radius: pol.distance,\n  });\n  $('canvas').drawLine({\n    layer: true,\n    strokeWidth: 3,\n    name: 'lineByLabel'+id,\n    groups: ['lineByLabel'],\n    strokeStyle: colorRayAndCircleByLabel,\n    x1: CenterX, y1: CenterY,\n    x2: dec.X, y2: dec.Y,\n  });\n}\n\nfunction createNamePopUpLabel(id,x,y,text) {\n  var heightPopUp = 30;\n  var widthPopUp = 150;\n\n  $('canvas').drawRect({\n    layer: true,\n    fillStyle: 'white',\n    strokeStyle: '#c33',\n    strokeWidth: 2,\n    name: 'nameLabelPopup'+id,\n    groups: ['nameLabelPopup'],\n    x: x + widthPopUp/2, y: y - heightPopUp/2 - 10,\n    width: widthPopUp,\n    height: heightPopUp,\n    cornerRadius: 10\n  });\n  $('canvas').drawText({\n    layer: true,\n    name: 'nameLabelPopupText'+id,\n    groups: ['nameLabelPopupText'],\n    fillStyle: 'black',\n    strokeWidth: 2,\n    x: x + widthPopUp/2, y: y - heightPopUp/2 - 10,\n    fontSize: '10pt',\n    fontFamily: 'Verdana, sans-serif',\n    maxWidth: widthPopUp,\n    text: text\n  })\n}\n\n\nfunction createLabel(data) {\n  var LabelCoord = cartesian2Dec(data.radius*bigRadius, data.degr);\n  // console.log(data.radius);\n  $('canvas').drawArc({\n    layer: true,\n    draggable: true,\n    groups: ['note_labels'],\n    name: 'myLabel'+data.id,\n    fillStyle: colorLabel,\n    x: LabelCoord.X, y: LabelCoord.Y,\n    radius: radiusLabel,\n    data: {'id' : data.id, 'name': data.name , 'circleId': data.circleId},\n    label_radius: data.radius,\n    label_angle: data.degr,\n    label_id: data.id,\n    shadowColor: shadowColor,\n    shadowBlur: shadowLabelSize,\n    dragstop: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n      var dec = cartesian2Dec(pol.distance,pol.degr);\n\n      layer.label_radius = pol.distance/bigRadius;\n      layer.label_angle = pol.degr;\n      // console.log(layer.label_radius,layer.label_angle);\n\n      updateCoordinateLabel(layer.data.circleId,layer.data.id,pol.distance/bigRadius,pol.degr);\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    drag: function(layer) {\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n      rayAndCircleByLabel(layer,layer.data.id);\n    },\n    mouseover: function(layer) {\n      var Label = $('canvas').getLayer(layer.name);\n      Label.fillStyle = colorSelectLabel;\n      delRayNamePopUpAndCircleAllLabels();\n      rayAndCircleByLabel(layer,layer.data.id);\n      setLinkLabelsByRadiusAndAngle(layer.label_radius,layer.label_angle, layer.label_id);\n      createNamePopUpLabel(layer.data.id,layer.x,layer.y,layer.data.name);\n    },\n    mouseout: function(layer) {\n      var Label = $('canvas').getLayer(layer.name);\n      Label.fillStyle = colorLabel;\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n      removeLinkLabelsByRadiusAndAngle(layer.label_radius,layer.label_angle, layer.label_id);\n    },\n    dblclick: function(layer) {\n      $('#pop_label_link').css('display','block').attr('href','/app_dev.php/notes/list/'+layer.data.circleId+'/'+layer.data.id+'/');\n    },\n  });\n}\n\nfunction setHightMoveLayerToLayer(){\n  // Returns an array containing all draggable layers\n  var dragLayers = $('canvas').getLayers(function(layer) {\n    return (layer.draggable === true);\n  });\n\n  function setMoveLayerToLayer(layer, index, array) {\n    $('canvas').moveLayer(layer.name, 100);\n  }\n  dragLayers.forEach(setMoveLayerToLayer);\n}\n\nfunction setLinkLabelsByRadiusAndAngle(radius, angle, label_id){\n  var labels = $('canvas').getLayerGroup('note_labels');\n  var radiusBorderMin = radius - 0.05;\n  var radiusBorderMax = radius + 0.05;\n  var angleBorderMin = angle - 10;\n  var angleBorderMax = angle + 10;\n  // console.log(radiusBorderMin,radiusBorderMax,angleBorderMin,angleBorderMax);\n\n  function setFillStyleToLayer(layer, index, array) {\n    if(layer.id !== label_id){\n      if((layer.label_angle > angleBorderMin && layer.label_angle < angleBorderMax)\n          || (layer.label_radius > radiusBorderMin && layer.label_radius < radiusBorderMax) ){\n        // console.log(layer.label_angle,layer.label_radius);\n        createNamePopUpLabel(layer.label_id,layer.x,layer.y,layer.data.name);\n        layer.fillStyle = colorSelectLabel;\n      }\n    }\n  }\n  labels.forEach(setFillStyleToLayer);\n}\n\nfunction removeLinkLabelsByRadiusAndAngle(radius, angle, label_id){\n  var labels = $('canvas').getLayerGroup('note_labels');\n  var radiusBorderMin = radius - 0.03;\n  var radiusBorderMax = radius + 0.03;\n  var angleBorderMin = angle - 10;\n  var angleBorderMax = angle + 10;\n  // console.log(radiusBorderMin,radiusBorderMax,angleBorderMin,angleBorderMax);\n\n  function deleteFillStyleToLayer(layer, index, array) {\n    if(layer.label_id !== label_id){\n      if((layer.label_angle > angleBorderMin && layer.label_angle < angleBorderMax)\n          || (layer.label_radius > radiusBorderMin && layer.label_radius < radiusBorderMax) ){\n        // console.log(layer.label_angle,layer.label_radius);\n        layer.fillStyle = colorLabel;\n        delNamePopUpByLabel(layer.label_id);\n      }\n    }\n  }\n  labels.forEach(deleteFillStyleToLayer);\n}\n\nfunction updateLabelPositionByChangingSector(border,coefficientLeft,coefficientRight,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle) {\n  var sector_left = $('canvas').getLayer('main_sector_'+border.sectorLeftId);\n  var sector_right = $('canvas').getLayer('main_sector_'+border.sectorRightId);\n  var labels = $('canvas').getLayerGroup('note_labels');\n\n  function updateLabelPosition(label, index, array) {\n\n    if(label.label_angle > sector_left.start && label.label_angle < sector_left.end){\n        var newAngle = (label.label_angle-oldLeftSectorMinAngle)*coefficientLeft+newLeftSectorMinAngle;\n        var LabelCoord = cartesian2Dec(label.label_radius*bigRadius, newAngle);\n        label.x = LabelCoord.X;\n        label.y = LabelCoord.Y;\n        console.log(label.name,label.label_angle,newAngle,sector_left,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle,coefficientLeft);\n        label.label_angle = newAngle;\n      }else if(label.label_angle > sector_right.start && label.label_angle < sector_right.end){\n        var newAngle = (label.label_angle-oldRightSectorMinAngle)*coefficientRight+newRightSectorMinAngle;\n        var LabelCoord = cartesian2Dec(label.label_radius*bigRadius, newAngle);\n        label.x = LabelCoord.X;\n        label.y = LabelCoord.Y;\n        label.label_angle = newAngle;\n    }\n  }\n  labels.forEach(updateLabelPosition);\n\n  // console.log(sector_left,sector_right);\n}\n\n\nfunction updateCoordinateLabel(circleId,labelId,radius,angle) {\n  $.post(\n      \"/app_dev.php/circle/editLabelAjax\",\n      {\n        circleId: circleId,\n        labelId:labelId,\n        radius:radius,\n        angle:angle\n      }).done(\n      function (data) {\n        console.log(data);\n\n      })\n}\n\n\nfunction delRayNamePopUpAndCircleByLabel(id) {\n  $('canvas').removeLayer('circleByLabel'+id);\n  $('canvas').removeLayer('lineByLabel'+id);\n  $('canvas').removeLayer('nameLabelPopup'+id);\n  $('canvas').removeLayer('nameLabelPopupText'+id);\n}\n\nfunction delNamePopUpByLabel(id) {\n  $('canvas').removeLayer('nameLabelPopup'+id);\n  $('canvas').removeLayer('nameLabelPopupText'+id);\n}\n\nfunction delRayNamePopUpAndCircleAllLabels() {\n  $('canvas').removeLayerGroup('circleByLabel');\n  $('canvas').removeLayerGroup('lineByLabel');\n  $('canvas').removeLayerGroup('nameLabelPopup');\n  $('canvas').removeLayerGroup('nameLabelPopupText');\n}\n\n\n/*\n* block for creating sectors\n* */\n\nvar countOfFields = 3; //   \nvar curFieldNameId = 3; //     name\nvar maxFieldLimit = 12; //    \nfunction deleteField(a) {\n//if (countOfFields > 0) {\n  var arrInput = a.parentNode.getElementsByTagName('input');\n  var name = arrInput[0].value;\n\n//            BX.ajax.post(window.location.href, {delete_name : name} ,function(){});\n//    ,  \n  var contDiv = a.parentNode;\n//     DOM-\n  contDiv.parentNode.removeChild(contDiv);\n//     \n  countOfFields--;\n//}\n//  false,      \n  return false;\n}\n\nfunction addField() {\n// ,      \n  if (countOfFields >= maxFieldLimit) {\n    alert(\"     = \" + maxFieldLimit);\n    return false;\n  }\n//     \n  countOfFields++;\n//  ID\n  curFieldNameId++;\n//   \n  var div = document.createElement(\"div\");\n  div.setAttribute(\"class\", \"form-group create_sector\");\n//  HTML-  .  innerHTML\n  div.innerHTML = \"<input type=\\\"text\\\" placeholder=\\\" \\\"  name=\\\"sector_name[\" + curFieldNameId + \"]\\\" class=\\\"form-control\\\" value=\\\"\\\" autocomplete=\\\"off\\\"/>\" +\n      \"<input type=\\\"color\\\" placeholder=\\\" \\\"  name=\\\"sector_color[\" + curFieldNameId + \"]\\\" class=\\\"form-control\\\" value=\\\"#FFFAFA\\\" autocomplete=\\\"off\\\"/>\" +\n      \" <input type=\\\"button\\\" class=\\\"form-control\\\" onclick=\\\"return deleteField(this)\\\" href=\\\"#\\\" value=\\\"x\\\">\";\n//       \n  document.getElementById(\"formCircleCreate\").appendChild(div);\n//  false,      \n  return false;\n}\n\n\n\n\n\n\n\n\nvar numLayers = 4;\n\nvar dataSector1 = {\n  id: 1,\n  numLayers: numLayers,\n  color: '#8FBC8F',\n  beginAngle: 10,\n  endAngle: 90,\n  name: 'Example1',\n  circle_id: 1,\n};\n\nvar dataSector2 = {\n  id: 2,\n  numLayers: numLayers,\n  color: '#FFD700',\n  beginAngle: 90,\n  endAngle: 200,\n  name: 'Example2',\n  circle_id: 1,\n};\nvar dataSector3 = {\n  id: 3,\n  numLayers: numLayers,\n  color: '#BA55D3',\n  beginAngle: 200,\n  endAngle: 10,\n  name: 'Example3',\n  circle_id: 1,\n};\n\n// createSectorNew(dataSector1);\n// createSectorNew(dataSector2);\n// createSectorNew(dataSector3);\n\ncreateSectorNew(dataSector1.id, dataSector1.beginAngle, dataSector1.endAngle, dataSector1.circle_id, dataSector1.numLayers, dataSector1.color)\ncreateSectorNew(dataSector2.id, dataSector2.beginAngle, dataSector2.endAngle, dataSector2.circle_id, dataSector2.numLayers, dataSector2.color)\ncreateSectorNew(dataSector3.id, dataSector3.beginAngle, dataSector3.endAngle, dataSector3.circle_id, dataSector3.numLayers, dataSector3.color)\n\nborderForSector(dataSector1.endAngle,dataSector1.id,dataSector2.id, dataSector1.beginAngle,dataSector2.endAngle);\nborderForSector(dataSector2.endAngle,dataSector2.id,dataSector3.id, dataSector2.beginAngle,dataSector3.endAngle);\nborderForSector(dataSector3.endAngle,dataSector3.id,dataSector1.id, dataSector3.beginAngle,dataSector1.endAngle);\n\nvar dataLabel1 = {\n  id: 1,\n  radius: 0.43,\n  degr: 30,\n  name: 'Note1'\n};\n\nvar dataLabel2 = {\n  id: 2,\n  radius: 0.71,\n  degr: 60,\n  name: 'Note2'\n};\n\nvar dataLabel3 = {\n  id: 3,\n  radius: 0.41,\n  degr: 100,\n  name: 'Note3'\n};\n\nvar dataLabel4 = {\n  id: 4,\n  radius: 0.81,\n  degr: 170,\n  name: 'Note4'\n};\n\nvar dataLabel5 = {\n  id: 5,\n  radius: 0.91,\n  degr: 140,\n  name: 'Note5'\n};\n\n\ncreateLabel(dataLabel1);\ncreateLabel(dataLabel2);\ncreateLabel(dataLabel3);\ncreateLabel(dataLabel4);\ncreateLabel(dataLabel5);\n\n\n$(document).ready(function () {\n  // $('canvas').triggerLayerEvent('myLabel1', 'mouseover');\n  $('canvas').triggerLayerEvent('slice11', 'click');\n});","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","/**\n * @license jCanvas v20.1.4\n * Copyright 2017 Caleb Evans\n * Released under the MIT license\n */\n(function (jQuery, global, factory) {\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = function (jQuery, w) {\n      return factory(jQuery, w);\n    };\n  } else {\n    factory(jQuery, global);\n  }\n\n// Pass this if window is not defined yet\n}(typeof window !== 'undefined' ? window.jQuery : {}, typeof window !== 'undefined' ? window : this, function ($, window) {\n  'use strict';\n\n  var document = window.document,\n      Image = window.Image,\n      Array = window.Array,\n      getComputedStyle = window.getComputedStyle,\n      Math = window.Math,\n      Number = window.Number,\n      parseFloat = window.parseFloat;\n\n// Define local aliases to frequently used properties\n  var defaults,\n      // Aliases to jQuery methods\n      extendObject = $.extend,\n      inArray = $.inArray,\n      typeOf = function (operand) {\n        return Object.prototype.toString.call(operand)\n            .slice(8, -1).toLowerCase();\n      },\n      isFunction = $.isFunction,\n      isPlainObject = $.isPlainObject,\n      // Math constants and functions\n      PI = Math.PI,\n      round = Math.round,\n      abs = Math.abs,\n      sin = Math.sin,\n      cos = Math.cos,\n      atan2 = Math.atan2,\n      // The Array slice() method\n      arraySlice = Array.prototype.slice,\n      // jQuery's internal event normalization function\n      jQueryEventFix = $.event.fix,\n      // Object for storing a number of internal property maps\n      maps = {},\n      // jQuery internal caches\n      caches = {\n        dataCache: {},\n        propCache: {},\n        imageCache: {}\n      },\n      // Base transformations\n      baseTransforms = {\n        rotate: 0,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        // Store all previous masks\n        masks: []\n      },\n      // Object for storing CSS-related properties\n      css = {},\n      tangibleEvents = [\n        'mousedown',\n        'mousemove',\n        'mouseup',\n        'mouseover',\n        'mouseout',\n        'touchstart',\n        'touchmove',\n        'touchend'\n      ];\n\n// Constructor for creating objects that inherit from jCanvas preferences and defaults\n  function jCanvasObject(args) {\n    var params = this,\n        propName;\n    // Copy the given parameters into new object\n    for (propName in args) {\n      // Do not merge defaults into parameters\n      if (Object.prototype.hasOwnProperty.call(args, propName)) {\n        params[propName] = args[propName];\n      }\n    }\n    return params;\n  }\n\n// jCanvas object in which global settings are other data are stored\n  var jCanvas = {\n    // Events object for storing jCanvas event initiation functions\n    events: {},\n    // Object containing all jCanvas event hooks\n    eventHooks: {},\n    // Settings for enabling future jCanvas features\n    future: {}\n  };\n\n// jCanvas default property values\n  function jCanvasDefaults() {\n    extendObject(this, jCanvasDefaults.baseDefaults);\n  }\n  jCanvasDefaults.baseDefaults = {\n    align: 'center',\n    arrowAngle: 90,\n    arrowRadius: 0,\n    autosave: true,\n    baseline: 'middle',\n    bringToFront: false,\n    ccw: false,\n    closed: false,\n    compositing: 'source-over',\n    concavity: 0,\n    cornerRadius: 0,\n    count: 1,\n    cropFromCenter: true,\n    crossOrigin: null,\n    cursors: null,\n    disableEvents: false,\n    draggable: false,\n    dragGroups: null,\n    groups: null,\n    data: null,\n    dx: null,\n    dy: null,\n    end: 360,\n    eventX: null,\n    eventY: null,\n    fillStyle: 'transparent',\n    fontStyle: 'normal',\n    fontSize: '12pt',\n    fontFamily: 'sans-serif',\n    fromCenter: true,\n    height: null,\n    imageSmoothing: true,\n    inDegrees: true,\n    intangible: false,\n    index: null,\n    letterSpacing: null,\n    lineHeight: 1,\n    layer: false,\n    mask: false,\n    maxWidth: null,\n    miterLimit: 10,\n    name: null,\n    opacity: 1,\n    r1: null,\n    r2: null,\n    radius: 0,\n    repeat: 'repeat',\n    respectAlign: false,\n    restrictDragToAxis: null,\n    rotate: 0,\n    rounded: false,\n    scale: 1,\n    scaleX: 1,\n    scaleY: 1,\n    shadowBlur: 0,\n    shadowColor: 'transparent',\n    shadowStroke: false,\n    shadowX: 0,\n    shadowY: 0,\n    sHeight: null,\n    sides: 0,\n    source: '',\n    spread: 0,\n    start: 0,\n    strokeCap: 'butt',\n    strokeDash: null,\n    strokeDashOffset: 0,\n    strokeJoin: 'miter',\n    strokeStyle: 'transparent',\n    strokeWidth: 1,\n    sWidth: null,\n    sx: null,\n    sy: null,\n    text: '',\n    translate: 0,\n    translateX: 0,\n    translateY: 0,\n    type: null,\n    visible: true,\n    width: null,\n    x: 0,\n    y: 0\n  };\n  defaults = new jCanvasDefaults();\n  jCanvasObject.prototype = defaults;\n\n  /* Internal helper methods */\n\n// Determines if the given operand is a string\n  function isString(operand) {\n    return (typeOf(operand) === 'string');\n  }\n\n// Determines if the given operand is numeric\n  function isNumeric(operand) {\n    return !isNaN(Number(operand)) && !isNaN(parseFloat(operand));\n  }\n\n// Get 2D context for the given canvas\n  function _getContext(canvas) {\n    return (canvas && canvas.getContext ? canvas.getContext('2d') : null);\n  }\n\n// Coerce designated number properties from strings to numbers\n  function _coerceNumericProps(props) {\n    var propName, propType, propValue;\n    // Loop through all properties in given property map\n    for (propName in props) {\n      if (Object.prototype.hasOwnProperty.call(props, propName)) {\n        propValue = props[propName];\n        propType = typeOf(propValue);\n        // If property is non-empty string and value is numeric\n        if (propType === 'string' && isNumeric(propValue) && propName !== 'text') {\n          // Convert value to number\n          props[propName] = parseFloat(propValue);\n        }\n      }\n    }\n    // Ensure value of text property is always a string\n    if (props.text !== undefined) {\n      props.text = String(props.text);\n    }\n  }\n\n// Clone the given transformations object\n  function _cloneTransforms(transforms) {\n    // Clone the object itself\n    transforms = extendObject({}, transforms);\n    // Clone the object's masks array\n    transforms.masks = transforms.masks.slice(0);\n    return transforms;\n  }\n\n// Save canvas context and update transformation stack\n  function _saveCanvas(ctx, data) {\n    var transforms;\n    ctx.save();\n    transforms = _cloneTransforms(data.transforms);\n    data.savedTransforms.push(transforms);\n  }\n\n// Restore canvas context update transformation stack\n  function _restoreCanvas(ctx, data) {\n    if (data.savedTransforms.length === 0) {\n      // Reset transformation state if it can't be restored any more\n      data.transforms = _cloneTransforms(baseTransforms);\n    } else {\n      // Restore canvas context\n      ctx.restore();\n      // Restore current transform state to the last saved state\n      data.transforms = data.savedTransforms.pop();\n    }\n  }\n\n// Set the style with the given name\n  function _setStyle(canvas, ctx, params, styleName) {\n    if (params[styleName]) {\n      if (isFunction(params[styleName])) {\n        // Handle functions\n        ctx[styleName] = params[styleName].call(canvas, params);\n      } else {\n        // Handle string values\n        ctx[styleName] = params[styleName];\n      }\n    }\n  }\n\n// Set canvas context properties\n  function _setGlobalProps(canvas, ctx, params) {\n    _setStyle(canvas, ctx, params, 'fillStyle');\n    _setStyle(canvas, ctx, params, 'strokeStyle');\n    ctx.lineWidth = params.strokeWidth;\n    // Optionally round corners for paths\n    if (params.rounded) {\n      ctx.lineCap = ctx.lineJoin = 'round';\n    } else {\n      ctx.lineCap = params.strokeCap;\n      ctx.lineJoin = params.strokeJoin;\n      ctx.miterLimit = params.miterLimit;\n    }\n    // Reset strokeDash if null\n    if (!params.strokeDash) {\n      params.strokeDash = [];\n    }\n    // Dashed lines\n    if (ctx.setLineDash) {\n      ctx.setLineDash(params.strokeDash);\n    }\n    ctx.webkitLineDash = params.strokeDash;\n    ctx.lineDashOffset = ctx.webkitLineDashOffset = ctx.mozDashOffset = params.strokeDashOffset;\n    // Drop shadow\n    ctx.shadowOffsetX = params.shadowX;\n    ctx.shadowOffsetY = params.shadowY;\n    ctx.shadowBlur = params.shadowBlur;\n    ctx.shadowColor = params.shadowColor;\n    // Opacity and composite operation\n    ctx.globalAlpha = params.opacity;\n    ctx.globalCompositeOperation = params.compositing;\n    // Support cross-browser toggling of image smoothing\n    if (params.imageSmoothing) {\n      ctx.imageSmoothingEnabled = params.imageSmoothing;\n    }\n  }\n\n// Optionally enable masking support for this path\n  function _enableMasking(ctx, data, params) {\n    if (params.mask) {\n      // If jCanvas autosave is enabled\n      if (params.autosave) {\n        // Automatically save transformation state by default\n        _saveCanvas(ctx, data);\n      }\n      // Clip the current path\n      ctx.clip();\n      // Keep track of current masks\n      data.transforms.masks.push(params._args);\n    }\n  }\n\n// Restore individual shape transformation\n  function _restoreTransform(ctx, params) {\n    // If shape has been transformed by jCanvas\n    if (params._transformed) {\n      // Restore canvas context\n      ctx.restore();\n    }\n  }\n\n// Close current canvas path\n  function _closePath(canvas, ctx, params) {\n    var data;\n\n    // Optionally close path\n    if (params.closed) {\n      ctx.closePath();\n    }\n\n    if (params.shadowStroke && params.strokeWidth !== 0) {\n      // Extend the shadow to include the stroke of a drawing\n\n      // Add a stroke shadow by stroking before filling\n      ctx.stroke();\n      ctx.fill();\n      // Ensure the below stroking does not inherit a shadow\n      ctx.shadowColor = 'transparent';\n      ctx.shadowBlur = 0;\n      // Stroke over fill as usual\n      ctx.stroke();\n\n    } else {\n      // If shadowStroke is not enabled, stroke & fill as usual\n\n      ctx.fill();\n      // Prevent extra shadow created by stroke (but only when fill is present)\n      if (params.fillStyle !== 'transparent') {\n        ctx.shadowColor = 'transparent';\n      }\n      if (params.strokeWidth !== 0) {\n        // Only stroke if the stroke is not 0\n        ctx.stroke();\n      }\n\n    }\n\n    // Optionally close path\n    if (!params.closed) {\n      ctx.closePath();\n    }\n\n    // Restore individual shape transformation\n    _restoreTransform(ctx, params);\n\n    // Mask shape if chosen\n    if (params.mask) {\n      // Retrieve canvas data\n      data = _getCanvasData(canvas);\n      _enableMasking(ctx, data, params);\n    }\n\n  }\n\n// Transform (translate, scale, or rotate) shape\n  function _transformShape(canvas, ctx, params, width, height) {\n\n    // Get conversion factor for radians\n    params._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n    params._transformed = true;\n    ctx.save();\n\n    // Optionally measure (x, y) position from top-left corner\n    if (!params.fromCenter && !params._centered && width !== undefined) {\n      // Always draw from center unless otherwise specified\n      if (height === undefined) {\n        height = width;\n      }\n      params.x += width / 2;\n      params.y += height / 2;\n      params._centered = true;\n    }\n    // Optionally rotate shape\n    if (params.rotate) {\n      _rotateCanvas(ctx, params, null);\n    }\n    // Optionally scale shape\n    if (params.scale !== 1 || params.scaleX !== 1 || params.scaleY !== 1) {\n      _scaleCanvas(ctx, params, null);\n    }\n    // Optionally translate shape\n    if (params.translate || params.translateX || params.translateY) {\n      _translateCanvas(ctx, params, null);\n    }\n\n  }\n\n  /* Plugin API */\n\n// Extend jCanvas with a user-defined method\n  jCanvas.extend = function extend(plugin) {\n\n    // Create plugin\n    if (plugin.name) {\n      // Merge properties with defaults\n      if (plugin.props) {\n        extendObject(defaults, plugin.props);\n      }\n      // Define plugin method\n      $.fn[plugin.name] = function self(args) {\n        var $canvases = this, canvas, e, ctx,\n            params;\n\n        for (e = 0; e < $canvases.length; e += 1) {\n          canvas = $canvases[e];\n          ctx = _getContext(canvas);\n          if (ctx) {\n\n            params = new jCanvasObject(args);\n            _addLayer(canvas, params, args, self);\n\n            _setGlobalProps(canvas, ctx, params);\n            plugin.fn.call(canvas, ctx, params);\n\n          }\n        }\n        return $canvases;\n      };\n      // Add drawing type to drawing map\n      if (plugin.type) {\n        maps.drawings[plugin.type] = plugin.name;\n      }\n    }\n    return $.fn[plugin.name];\n  };\n\n  /* Layer API */\n\n// Retrieved the stored jCanvas data for a canvas element\n  function _getCanvasData(canvas) {\n    var dataCache = caches.dataCache, data;\n    if (dataCache._canvas === canvas && dataCache._data) {\n\n      // Retrieve canvas data from cache if possible\n      data = dataCache._data;\n\n    } else {\n\n      // Retrieve canvas data from jQuery's internal data storage\n      data = $.data(canvas, 'jCanvas');\n      if (!data) {\n\n        // Create canvas data object if it does not already exist\n        data = {\n          // The associated canvas element\n          canvas: canvas,\n          // Layers array\n          layers: [],\n          // Layer maps\n          layer: {\n            names: {},\n            groups: {}\n          },\n          eventHooks: {},\n          // All layers that intersect with the event coordinates (regardless of visibility)\n          intersecting: [],\n          // The topmost layer whose area contains the event coordinates\n          lastIntersected: null,\n          cursor: $(canvas).css('cursor'),\n          // Properties for the current drag event\n          drag: {\n            layer: null,\n            dragging: false\n          },\n          // Data for the current event\n          event: {\n            type: null,\n            x: null,\n            y: null\n          },\n          // Events which already have been bound to the canvas\n          events: {},\n          // The canvas's current transformation state\n          transforms: _cloneTransforms(baseTransforms),\n          savedTransforms: [],\n          // Whether a layer is being animated or not\n          animating: false,\n          // The layer currently being animated\n          animated: null,\n          // The device pixel ratio\n          pixelRatio: 1,\n          // Whether pixel ratio transformations have been applied\n          scaled: false,\n          // Whether the canvas should be redrawn when a layer mousemove\n          // event triggers (either directly, or indirectly via dragging)\n          redrawOnMousemove: false\n        };\n        // Use jQuery to store canvas data\n        $.data(canvas, 'jCanvas', data);\n\n      }\n      // Cache canvas data for faster retrieval\n      dataCache._canvas = canvas;\n      dataCache._data = data;\n\n    }\n    return data;\n  }\n\n// Initialize all of a layer's associated jCanvas events\n  function _addLayerEvents($canvas, data, layer) {\n    var eventName;\n    // Determine which jCanvas events need to be bound to this layer\n    for (eventName in jCanvas.events) {\n      if (Object.prototype.hasOwnProperty.call(jCanvas.events, eventName)) {\n        // If layer has callback function to complement it\n        if (layer[eventName] || (layer.cursors && layer.cursors[eventName])) {\n          // Bind event to layer\n          _addExplicitLayerEvent($canvas, data, layer, eventName);\n        }\n      }\n    }\n    if (!data.events.mouseout) {\n      $canvas.bind('mouseout.jCanvas', function () {\n        // Retrieve the layer whose drag event was canceled\n        var layer = data.drag.layer, l;\n        // If cursor mouses out of canvas while dragging\n        if (layer) {\n          // Cancel drag\n          data.drag = {};\n          _triggerLayerEvent($canvas, data, layer, 'dragcancel');\n        }\n        // Loop through all layers\n        for (l = 0; l < data.layers.length; l += 1) {\n          layer = data.layers[l];\n          // If layer thinks it's still being moused over\n          if (layer._hovered) {\n            // Trigger mouseout on layer\n            $canvas.triggerLayerEvent(data.layers[l], 'mouseout');\n          }\n        }\n        // Redraw layers\n        $canvas.drawLayers();\n      });\n      // Indicate that an event handler has been bound\n      data.events.mouseout = true;\n    }\n  }\n\n// Initialize the given event on the given layer\n  function _addLayerEvent($canvas, data, layer, eventName) {\n    // Use touch events if appropriate\n    // eventName = _getMouseEventName(eventName);\n    // Bind event to layer\n    jCanvas.events[eventName]($canvas, data);\n    layer._event = true;\n  }\n\n// Add a layer event that was explicitly declared in the layer's parameter map,\n// excluding events added implicitly (e.g. mousemove event required by draggable\n// layers)\n  function _addExplicitLayerEvent($canvas, data, layer, eventName) {\n    _addLayerEvent($canvas, data, layer, eventName);\n    if (eventName === 'mouseover' || eventName === 'mouseout' || eventName === 'mousemove') {\n      data.redrawOnMousemove = true;\n    }\n  }\n\n// Enable drag support for this layer\n  function _enableDrag($canvas, data, layer) {\n    var dragHelperEvents, eventName, i;\n    // Only make layer draggable if necessary\n    if (layer.draggable || layer.cursors) {\n\n      // Organize helper events which enable drag support\n      dragHelperEvents = ['mousedown', 'mousemove', 'mouseup'];\n\n      // Bind each helper event to the canvas\n      for (i = 0; i < dragHelperEvents.length; i += 1) {\n        // Use touch events if appropriate\n        eventName = dragHelperEvents[i];\n        // Bind event\n        _addLayerEvent($canvas, data, layer, eventName);\n      }\n      // Indicate that this layer has events bound to it\n      layer._event = true;\n\n    }\n  }\n\n// Update a layer property map if property is changed\n  function _updateLayerName($canvas, data, layer, props) {\n    var nameMap = data.layer.names;\n\n    // If layer name is being added, not changed\n    if (!props) {\n\n      props = layer;\n\n    } else {\n\n      // Remove old layer name entry because layer name has changed\n      if (props.name !== undefined && isString(layer.name) && layer.name !== props.name) {\n        delete nameMap[layer.name];\n      }\n\n    }\n\n    // Add new entry to layer name map with new name\n    if (isString(props.name)) {\n      nameMap[props.name] = layer;\n    }\n  }\n\n// Create or update the data map for the given layer and group type\n  function _updateLayerGroups($canvas, data, layer, props) {\n    var groupMap = data.layer.groups,\n        group, groupName, g,\n        index, l;\n\n    // If group name is not changing\n    if (!props) {\n\n      props = layer;\n\n    } else {\n\n      // Remove layer from all of its associated groups\n      if (props.groups !== undefined && layer.groups !== null) {\n        for (g = 0; g < layer.groups.length; g += 1) {\n          groupName = layer.groups[g];\n          group = groupMap[groupName];\n          if (group) {\n            // Remove layer from its old layer group entry\n            for (l = 0; l < group.length; l += 1) {\n              if (group[l] === layer) {\n                // Keep track of the layer's initial index\n                index = l;\n                // Remove layer once found\n                group.splice(l, 1);\n                break;\n              }\n            }\n            // Remove layer group entry if group is empty\n            if (group.length === 0) {\n              delete groupMap[groupName];\n            }\n          }\n        }\n      }\n\n    }\n\n    // Add layer to new group if a new group name is given\n    if (props.groups !== undefined && props.groups !== null) {\n\n      for (g = 0; g < props.groups.length; g += 1) {\n\n        groupName = props.groups[g];\n\n        group = groupMap[groupName];\n        if (!group) {\n          // Create new group entry if it doesn't exist\n          group = groupMap[groupName] = [];\n          group.name = groupName;\n        }\n        if (index === undefined) {\n          // Add layer to end of group unless otherwise stated\n          index = group.length;\n        }\n        // Add layer to its new layer group\n        group.splice(index, 0, layer);\n\n      }\n\n    }\n  }\n\n// Get event hooks object for the first selected canvas\n  $.fn.getEventHooks = function getEventHooks() {\n    var $canvases = this, canvas, data,\n        eventHooks = {};\n\n    if ($canvases.length !== 0) {\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      eventHooks = data.eventHooks;\n    }\n    return eventHooks;\n  };\n\n// Set event hooks for the selected canvases\n  $.fn.setEventHooks = function setEventHooks(eventHooks) {\n    var $canvases = this, e,\n        data;\n    for (e = 0; e < $canvases.length; e += 1) {\n      data = _getCanvasData($canvases[e]);\n      extendObject(data.eventHooks, eventHooks);\n    }\n    return $canvases;\n  };\n\n// Get jCanvas layers array\n  $.fn.getLayers = function getLayers(callback) {\n    var $canvases = this, canvas, data,\n        layers, layer, l,\n        matching = [];\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      // Retrieve layers array for this canvas\n      layers = data.layers;\n\n      // If a callback function is given\n      if (isFunction(callback)) {\n\n        // Filter the layers array using the callback\n        for (l = 0; l < layers.length; l += 1) {\n          layer = layers[l];\n          if (callback.call(canvas, layer)) {\n            // Add layer to array of matching layers if test passes\n            matching.push(layer);\n          }\n        }\n\n      } else {\n        // Otherwise, get all layers\n\n        matching = layers;\n\n      }\n\n    }\n    return matching;\n  };\n\n// Get a single jCanvas layer object\n  $.fn.getLayer = function getLayer(layerId) {\n    var $canvases = this, canvas,\n        data, layers, layer, l,\n        idType;\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      layers = data.layers;\n      idType = typeOf(layerId);\n\n      if (layerId && layerId.layer) {\n\n        // Return the actual layer object if given\n        layer = layerId;\n\n      } else if (idType === 'number') {\n\n        // Retrieve the layer using the given index\n\n        // Allow for negative indices\n        if (layerId < 0) {\n          layerId = layers.length + layerId;\n        }\n        // Get layer with the given index\n        layer = layers[layerId];\n\n      } else if (idType === 'regexp') {\n\n        // Get layer with the name that matches the given regex\n        for (l = 0; l < layers.length; l += 1) {\n          // Check if layer matches name\n          if (isString(layers[l].name) && layers[l].name.match(layerId)) {\n            layer = layers[l];\n            break;\n          }\n        }\n\n      } else {\n\n        // Get layer with the given name\n        layer = data.layer.names[layerId];\n\n      }\n\n    }\n    return layer;\n  };\n\n// Get all layers in the given group\n  $.fn.getLayerGroup = function getLayerGroup(groupId) {\n    var $canvases = this, canvas, data,\n        groups, groupName, group,\n        idType = typeOf(groupId);\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n\n      if (idType === 'array') {\n\n        // Return layer group if given\n        group = groupId;\n\n      } else if (idType === 'regexp') {\n\n        // Get canvas data\n        data = _getCanvasData(canvas);\n        groups = data.layer.groups;\n        // Loop through all layers groups for this canvas\n        for (groupName in groups) {\n          // Find a group whose name matches the given regex\n          if (groupName.match(groupId)) {\n            group = groups[groupName];\n            // Stop after finding the first matching group\n            break;\n          }\n        }\n\n      } else {\n\n        // Find layer group with the given group name\n        data = _getCanvasData(canvas);\n        group = data.layer.groups[groupId];\n      }\n\n    }\n    return group;\n  };\n\n// Get index of layer in layers array\n  $.fn.getLayerIndex = function getLayerIndex(layerId) {\n    var $canvases = this,\n        layers = $canvases.getLayers(),\n        layer = $canvases.getLayer(layerId);\n\n    return inArray(layer, layers);\n  };\n\n// Set properties of a layer\n  $.fn.setLayer = function setLayer(layerId, props) {\n    var $canvases = this, $canvas, e,\n        data, layer,\n        propName, propValue, propType;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      layer = $($canvases[e]).getLayer(layerId);\n      if (layer) {\n\n        // Update layer property maps\n        _updateLayerName($canvas, data, layer, props);\n        _updateLayerGroups($canvas, data, layer, props);\n\n        _coerceNumericProps(props);\n\n        // Merge properties with layer\n        for (propName in props) {\n          if (Object.prototype.hasOwnProperty.call(props, propName)) {\n            propValue = props[propName];\n            propType = typeOf(propValue);\n            if (propType === 'object' && isPlainObject(propValue)) {\n              // Clone objects\n              layer[propName] = extendObject({}, propValue);\n              _coerceNumericProps(layer[propName]);\n            } else if (propType === 'array') {\n              // Clone arrays\n              layer[propName] = propValue.slice(0);\n            } else if (propType === 'string') {\n              if (propValue.indexOf('+=') === 0) {\n                // Increment numbers prefixed with +=\n                layer[propName] += parseFloat(propValue.substr(2));\n              } else if (propValue.indexOf('-=') === 0) {\n                // Decrement numbers prefixed with -=\n                layer[propName] -= parseFloat(propValue.substr(2));\n              } else if (!isNaN(propValue) && isNumeric(propValue) && propName !== 'text') {\n                // Convert numeric values as strings to numbers\n                layer[propName] = parseFloat(propValue);\n              } else {\n                // Otherwise, set given string value\n                layer[propName] = propValue;\n              }\n            } else {\n              // Otherwise, set given value\n              layer[propName] = propValue;\n            }\n          }\n        }\n\n        // Update layer events\n        _addLayerEvents($canvas, data, layer);\n        _enableDrag($canvas, data, layer);\n\n        // If layer's properties were changed\n        if ($.isEmptyObject(props) === false) {\n          _triggerLayerEvent($canvas, data, layer, 'change', props);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Set properties of all layers (optionally filtered by a callback)\n  $.fn.setLayers = function setLayers(props, callback) {\n    var $canvases = this, $canvas, e,\n        layers, l;\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      layers = $canvas.getLayers(callback);\n      // Loop through all layers\n      for (l = 0; l < layers.length; l += 1) {\n        // Set properties of each layer\n        $canvas.setLayer(layers[l], props);\n      }\n    }\n    return $canvases;\n  };\n\n// Set properties of all layers in the given group\n  $.fn.setLayerGroup = function setLayerGroup(groupId, props) {\n    var $canvases = this, $canvas, e,\n        group, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      // Get layer group\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // If group exists\n      if (group) {\n\n        // Loop through layers in group\n        for (l = 0; l < group.length; l += 1) {\n          // Merge given properties with layer\n          $canvas.setLayer(group[l], props);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Move a layer to the given index in the layers array\n  $.fn.moveLayer = function moveLayer(layerId, index) {\n    var $canvases = this, $canvas, e,\n        data, layers, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      // Retrieve layers array and desired layer\n      layers = data.layers;\n      layer = $canvas.getLayer(layerId);\n      if (layer) {\n\n        // Ensure layer index is accurate\n        layer.index = inArray(layer, layers);\n\n        // Remove layer from its current placement\n        layers.splice(layer.index, 1);\n        // Add layer in its new placement\n        layers.splice(index, 0, layer);\n\n        // Handle negative indices\n        if (index < 0) {\n          index = layers.length + index;\n        }\n        // Update layer's stored index\n        layer.index = index;\n\n        _triggerLayerEvent($canvas, data, layer, 'move');\n\n      }\n    }\n    return $canvases;\n  };\n\n// Remove a jCanvas layer\n  $.fn.removeLayer = function removeLayer(layerId) {\n    var $canvases = this, $canvas, e, data,\n        layers, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      // Retrieve layers array and desired layer\n      layers = $canvas.getLayers();\n      layer = $canvas.getLayer(layerId);\n      // Remove layer if found\n      if (layer) {\n\n        // Ensure layer index is accurate\n        layer.index = inArray(layer, layers);\n        // Remove layer and allow it to be re-added later\n        layers.splice(layer.index, 1);\n        delete layer._layer;\n\n        // Update layer name map\n        _updateLayerName($canvas, data, layer, {\n          name: null\n        });\n        // Update layer group map\n        _updateLayerGroups($canvas, data, layer, {\n          groups: null\n        });\n\n        // Trigger 'remove' event\n        _triggerLayerEvent($canvas, data, layer, 'remove');\n\n      }\n    }\n    return $canvases;\n  };\n\n// Remove all layers\n  $.fn.removeLayers = function removeLayers(callback) {\n    var $canvases = this, $canvas, e,\n        data, layers, layer, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layers = $canvas.getLayers(callback);\n      // Remove all layers individually\n      for (l = 0; l < layers.length; l += 1) {\n        layer = layers[l];\n        $canvas.removeLayer(layer);\n        // Ensure no layer is skipped over\n        l -= 1;\n      }\n      // Update layer maps\n      data.layer.names = {};\n      data.layer.groups = {};\n    }\n    return $canvases;\n  };\n\n// Remove all layers in the group with the given ID\n  $.fn.removeLayerGroup = function removeLayerGroup(groupId) {\n    var $canvases = this, $canvas, e, group, l;\n\n    if (groupId !== undefined) {\n      for (e = 0; e < $canvases.length; e += 1) {\n        $canvas = $($canvases[e]);\n\n        group = $canvas.getLayerGroup(groupId);\n        // Remove layer group using given group name\n        if (group) {\n\n          // Clone groups array\n          group = group.slice(0);\n\n          // Loop through layers in group\n          for (l = 0; l < group.length; l += 1) {\n            $canvas.removeLayer(group[l]);\n          }\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Add an existing layer to a layer group\n  $.fn.addLayerToGroup = function addLayerToGroup(layerId, groupName) {\n    var $canvases = this, $canvas, e,\n        layer, groups = [groupName];\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n\n      // If layer is not already in group\n      if (layer.groups) {\n        // Clone groups list\n        groups = layer.groups.slice(0);\n        // If layer is not already in group\n        if (inArray(groupName, layer.groups) === -1) {\n          // Add layer to group\n          groups.push(groupName);\n        }\n      }\n      // Update layer group maps\n      $canvas.setLayer(layer, {\n        groups: groups\n      });\n\n    }\n    return $canvases;\n  };\n\n// Remove an existing layer from a layer group\n  $.fn.removeLayerFromGroup = function removeLayerFromGroup(layerId, groupName) {\n    var $canvases = this, $canvas, e,\n        layer, groups = [],\n        index;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n\n      if (layer.groups) {\n\n        // Find index of layer in group\n        index = inArray(groupName, layer.groups);\n\n        // If layer is in group\n        if (index !== -1) {\n\n          // Clone groups list\n          groups = layer.groups.slice(0);\n\n          // Remove layer from group\n          groups.splice(index, 1);\n\n          // Update layer group maps\n          $canvas.setLayer(layer, {\n            groups: groups\n          });\n\n        }\n\n      }\n\n    }\n    return $canvases;\n  };\n\n// Get topmost layer that intersects with event coordinates\n  function _getIntersectingLayer(data) {\n    var layer, i,\n        mask, m;\n\n    // Store the topmost layer\n    layer = null;\n\n    // Get the topmost layer whose visible area intersects event coordinates\n    for (i = data.intersecting.length - 1; i >= 0; i -= 1) {\n\n      // Get current layer\n      layer = data.intersecting[i];\n\n      // If layer has previous masks\n      if (layer._masks) {\n\n        // Search previous masks to ensure\n        // layer is visible at event coordinates\n        for (m = layer._masks.length - 1; m >= 0; m -= 1) {\n          mask = layer._masks[m];\n          // If mask does not intersect event coordinates\n          if (!mask.intersects) {\n            // Indicate that the mask does not\n            // intersect event coordinates\n            layer.intersects = false;\n            // Stop searching previous masks\n            break;\n          }\n\n        }\n\n        // If event coordinates intersect all previous masks\n        // and layer is not intangible\n        if (layer.intersects && !layer.intangible) {\n          // Stop searching for topmost layer\n          break;\n        }\n\n      }\n\n    }\n    // If resulting layer is intangible\n    if (layer && layer.intangible) {\n      // Cursor does not intersect this layer\n      layer = null;\n    }\n    return layer;\n  }\n\n// Draw individual layer (internal)\n  function _drawLayer($canvas, ctx, layer, nextLayerIndex) {\n    if (layer && layer.visible && layer._method) {\n      if (nextLayerIndex) {\n        layer._next = nextLayerIndex;\n      } else {\n        layer._next = null;\n      }\n      // If layer is an object, call its respective method\n      if (layer._method) {\n        layer._method.call($canvas, layer);\n      }\n    }\n  }\n\n// Handle dragging of the currently-dragged layer\n  function _handleLayerDrag($canvas, data, eventType) {\n    var layers, layer, l,\n        drag, dragGroups,\n        group, groupName, g,\n        newX, newY;\n\n    drag = data.drag;\n    layer = drag.layer;\n    dragGroups = (layer && layer.dragGroups) || [];\n    layers = data.layers;\n\n    if (eventType === 'mousemove' || eventType === 'touchmove') {\n      // Detect when user is currently dragging layer\n\n      if (!drag.dragging) {\n        // Detect when user starts dragging layer\n\n        // Signify that a layer on the canvas is being dragged\n        drag.dragging = true;\n        layer.dragging = true;\n\n        // Optionally bring layer to front when drag starts\n        if (layer.bringToFront) {\n          // Remove layer from its original position\n          layers.splice(layer.index, 1);\n          // Bring layer to front\n          // push() returns the new array length\n          layer.index = layers.push(layer);\n        }\n\n        // Set drag properties for this layer\n        layer._startX = layer.x;\n        layer._startY = layer.y;\n        layer._endX = layer._eventX;\n        layer._endY = layer._eventY;\n\n        // Trigger dragstart event\n        _triggerLayerEvent($canvas, data, layer, 'dragstart');\n\n      }\n\n      if (drag.dragging) {\n\n        // Calculate position after drag\n        newX = layer._eventX - (layer._endX - layer._startX);\n        newY = layer._eventY - (layer._endY - layer._startY);\n        if (layer.updateDragX) {\n          newX = layer.updateDragX.call($canvas[0], layer, newX);\n        }\n        if (layer.updateDragY) {\n          newY = layer.updateDragY.call($canvas[0], layer, newY);\n        }\n        layer.dx = newX - layer.x;\n        layer.dy = newY - layer.y;\n\n        if (layer.restrictDragToAxis !== 'y') {\n          layer.x = newX;\n        }\n        if (layer.restrictDragToAxis !== 'x') {\n          layer.y = newY;\n        }\n\n        if(layer.circlePath === true){\n          var centerX = layer.circleCenterX;\n          var centerY = layer.circleCenterY;\n          var r = layer.circleRadius;\n          var x1 = layer.x - centerX;\n          var y1 = layer.y - centerY;\n          var k = y1/x1;\n\n          if(x1<0){\n            var tempX = -Math.sqrt(Math.pow(r,2)/(1+Math.pow((k),2)));\n          }else{\n            var tempX = Math.sqrt(Math.pow(r,2)/(1+Math.pow((k),2)));\n          }\n          var tempY = tempX*k;\n\n          var px = layer.xMin;\n          var py = layer.yMin;\n          var qx = layer.xMax;\n          var qy = layer.yMax;\n          var rx = newX;\n          var ry = newY;\n          var Result = (Math.pow(px,2) + Math.pow(py,2)) * (qx * ry - qy * rx) -\n              (Math.pow(qx,2) + Math.pow(qy,2)) * (px * ry - py * rx) +\n              (Math.pow(rx,2) + Math.pow(ry,2)) * (px * qy - py * qx);\n\n          if(Result <= 0){\n            var absSumMin = Math.abs(layer.xMin - newX) + Math.abs(layer.yMin - newY);\n            var absSumMax = Math.abs(layer.xMax - newX) + Math.abs(layer.yMax - newY);\n            if(absSumMin < absSumMax){\n              tempX = layer.xMin - centerX;\n              tempY = layer.yMin - centerY;\n            }else{\n              tempX = layer.xMax - centerX;\n              tempY = layer.yMax - centerY;\n            }\n          }\n\n          var newX = tempX + centerX;\n          var newY = tempY + centerY;\n\n          layer.x = newX;\n          layer.y = newY;\n\n        }\n\n        // Trigger drag event\n        _triggerLayerEvent($canvas, data, layer, 'drag');\n\n        // Move groups with layer on drag\n        for (g = 0; g < dragGroups.length; g += 1) {\n\n          groupName = dragGroups[g];\n          group = data.layer.groups[groupName];\n          if (layer.groups && group) {\n\n            for (l = 0; l < group.length; l += 1) {\n              if (group[l] !== layer) {\n                if (layer.restrictDragToAxis !== 'y' && group[l].restrictDragToAxis !== 'y') {\n                  group[l].x += layer.dx;\n                }\n                if (layer.restrictDragToAxis !== 'x' && group[l].restrictDragToAxis !== 'x') {\n                  group[l].y += layer.dy;\n                }\n              }\n            }\n\n          }\n\n        }\n\n      }\n\n    } else if (eventType === 'mouseup' || eventType === 'touchend') {\n      // Detect when user stops dragging layer\n\n      if (drag.dragging) {\n        layer.dragging = false;\n        drag.dragging = false;\n        data.redrawOnMousemove = data.originalRedrawOnMousemove;\n        // Trigger dragstop event\n        _triggerLayerEvent($canvas, data, layer, 'dragstop');\n      }\n\n      // Cancel dragging\n      data.drag = {};\n\n    }\n  }\n\n\n// List of CSS3 cursors that need to be prefixed\n  css.cursors = ['grab', 'grabbing', 'zoom-in', 'zoom-out'];\n\n// Function to detect vendor prefix\n// Modified version of David Walsh's implementation\n// https://davidwalsh.name/vendor-prefix\n  css.prefix = (function () {\n    var styles = getComputedStyle(document.documentElement, ''),\n        pre = (arraySlice\n                .call(styles)\n                .join('')\n                .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\n        )[1];\n    return '-' + pre + '-';\n  })();\n\n// Set cursor on canvas\n  function _setCursor($canvas, layer, eventType) {\n    var cursor;\n    if (layer.cursors) {\n      // Retrieve cursor from cursors object if it exists\n      cursor = layer.cursors[eventType];\n    }\n    // Prefix any CSS3 cursor\n    if ($.inArray(cursor, css.cursors) !== -1) {\n      cursor = css.prefix + cursor;\n    }\n    // If cursor is defined\n    if (cursor) {\n      // Set canvas cursor\n      $canvas.css({\n        cursor: cursor\n      });\n    }\n  }\n\n// Reset cursor on canvas\n  function _resetCursor($canvas, data) {\n    $canvas.css({\n      cursor: data.cursor\n    });\n  }\n\n// Run the given event callback with the given arguments\n  function _runEventCallback($canvas, layer, eventType, callbacks, arg) {\n    // Prevent callback from firing recursively\n    if (callbacks[eventType] && layer._running && !layer._running[eventType]) {\n      // Signify the start of callback execution for this event\n      layer._running[eventType] = true;\n      // Run event callback with the given arguments\n      callbacks[eventType].call($canvas[0], layer, arg);\n      // Signify the end of callback execution for this event\n      layer._running[eventType] = false;\n    }\n  }\n\n// Determine if the given layer can \"legally\" fire the given event\n  function _layerCanFireEvent(layer, eventType) {\n    // If events are disable and if\n    // layer is tangible or event is not tangible\n    return (!layer.disableEvents &&\n        (!layer.intangible || $.inArray(eventType, tangibleEvents) === -1));\n  }\n\n// Trigger the given event on the given layer\n  function _triggerLayerEvent($canvas, data, layer, eventType, arg) {\n    // If layer can legally fire this event type\n    if (_layerCanFireEvent(layer, eventType)) {\n\n      // Do not set a custom cursor on layer mouseout\n      if (eventType !== 'mouseout') {\n        // Update cursor if one is defined for this event\n        _setCursor($canvas, layer, eventType);\n      }\n\n      // Trigger the user-defined event callback\n      _runEventCallback($canvas, layer, eventType, layer, arg);\n      // Trigger the canvas-bound event hook\n      _runEventCallback($canvas, layer, eventType, data.eventHooks, arg);\n      // Trigger the global event hook\n      _runEventCallback($canvas, layer, eventType, jCanvas.eventHooks, arg);\n\n    }\n  }\n\n// Manually trigger a layer event\n  $.fn.triggerLayerEvent = function (layer, eventType) {\n    var $canvases = this, $canvas, e,\n        data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layer);\n      if (layer) {\n        _triggerLayerEvent($canvas, data, layer, eventType);\n      }\n    }\n    return $canvases;\n  };\n\n// Draw layer with the given ID\n  $.fn.drawLayer = function drawLayer(layerId) {\n    var $canvases = this, e, ctx,\n        $canvas, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n        layer = $canvas.getLayer(layerId);\n        _drawLayer($canvas, ctx, layer);\n      }\n    }\n    return $canvases;\n  };\n\n// Draw all layers (or, if given, only layers starting at an index)\n  $.fn.drawLayers = function drawLayers(args) {\n    var $canvases = this, $canvas, e, ctx,\n        // Internal parameters for redrawing the canvas\n        params = args || {},\n        // Other variables\n        layers, layer, lastLayer, l, index, lastIndex,\n        data, eventCache, eventType, isImageLayer;\n\n    // The layer index from which to start redrawing the canvas\n    index = params.index;\n    if (!index) {\n      index = 0;\n    }\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        // Clear canvas first unless otherwise directed\n        if (params.clear !== false) {\n          $canvas.clearCanvas();\n        }\n\n        // Cache the layers array\n        layers = data.layers;\n\n        // Draw layers from first to last (bottom to top)\n        for (l = index; l < layers.length; l += 1) {\n          layer = layers[l];\n\n          // Ensure layer index is up-to-date\n          layer.index = l;\n\n          // Prevent any one event from firing excessively\n          if (params.resetFire) {\n            layer._fired = false;\n          }\n          // Draw layer\n          _drawLayer($canvas, ctx, layer, l + 1);\n          // Store list of previous masks for each layer\n          layer._masks = data.transforms.masks.slice(0);\n\n          // Allow image layers to load before drawing successive layers\n          if (layer._method === $.fn.drawImage && layer.visible) {\n            isImageLayer = true;\n            break;\n          }\n\n        }\n\n        // If layer is an image layer\n        if (isImageLayer) {\n          // Stop and wait for drawImage() to resume drawLayers()\n          break;\n        }\n\n        // Store the latest\n        lastIndex = l;\n\n        // Get first layer that intersects with event coordinates\n        layer = _getIntersectingLayer(data);\n\n        eventCache = data.event;\n        eventType = eventCache.type;\n\n        // If jCanvas has detected a dragstart\n        if (data.drag.layer) {\n          // Handle dragging of layer\n          _handleLayerDrag($canvas, data, eventType);\n        }\n\n        // Manage mouseout event\n        lastLayer = data.lastIntersected;\n        if (lastLayer !== null && layer !== lastLayer && lastLayer._hovered && !lastLayer._fired && !data.drag.dragging) {\n\n          data.lastIntersected = null;\n          lastLayer._fired = true;\n          lastLayer._hovered = false;\n          _triggerLayerEvent($canvas, data, lastLayer, 'mouseout');\n          _resetCursor($canvas, data);\n\n        }\n\n        if (layer) {\n\n          // Use mouse event callbacks if no touch event callbacks are given\n          if (!layer[eventType]) {\n            eventType = _getMouseEventName(eventType);\n          }\n\n          // Check events for intersecting layer\n          if (layer._event && layer.intersects) {\n\n            data.lastIntersected = layer;\n\n            // Detect mouseover events\n            if ((layer.mouseover || layer.mouseout || layer.cursors) && !data.drag.dragging) {\n\n              if (!layer._hovered && !layer._fired) {\n\n                // Prevent events from firing excessively\n                layer._fired = true;\n                layer._hovered = true;\n                _triggerLayerEvent($canvas, data, layer, 'mouseover');\n\n              }\n\n            }\n\n            // Detect any other mouse event\n            if (!layer._fired) {\n\n              // Prevent event from firing twice unintentionally\n              layer._fired = true;\n              eventCache.type = null;\n\n              _triggerLayerEvent($canvas, data, layer, eventType);\n\n            }\n\n            // Use the mousedown event to start drag\n            if (layer.draggable && !layer.disableEvents && (eventType === 'mousedown' || eventType === 'touchstart')) {\n\n              // Keep track of drag state\n              data.drag.layer = layer;\n              data.originalRedrawOnMousemove = data.redrawOnMousemove;\n              data.redrawOnMousemove = true;\n\n            }\n\n          }\n\n        }\n\n        // If cursor is not intersecting with any layer\n        if (layer === null && !data.drag.dragging) {\n          // Reset cursor to previous state\n          _resetCursor($canvas, data);\n        }\n\n        // If the last layer has been drawn\n        if (lastIndex === layers.length) {\n\n          // Reset list of intersecting layers\n          data.intersecting.length = 0;\n          // Reset transformation stack\n          data.transforms = _cloneTransforms(baseTransforms);\n          data.savedTransforms.length = 0;\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Add a jCanvas layer (internal)\n  function _addLayer(canvas, params, args, method) {\n    var $canvas, data,\n        layers, layer = (params._layer ? args : params);\n\n    // Store arguments object for later use\n    params._args = args;\n\n    // Convert all draggable drawings into jCanvas layers\n    if (params.draggable || params.dragGroups) {\n      params.layer = true;\n      params.draggable = true;\n    }\n\n    // Determine the layer's type using the available information\n    if (!params._method) {\n      if (method) {\n        params._method = method;\n      } else if (params.method) {\n        params._method = $.fn[params.method];\n      } else if (params.type) {\n        params._method = $.fn[maps.drawings[params.type]];\n      }\n    }\n\n    // If layer hasn't been added yet\n    if (params.layer && !params._layer) {\n      // Add layer to canvas\n\n      $canvas = $(canvas);\n\n      data = _getCanvasData(canvas);\n      layers = data.layers;\n\n      // Do not add duplicate layers of same name\n      if (layer.name === null || (isString(layer.name) && data.layer.names[layer.name] === undefined)) {\n\n        // Convert number properties to numbers\n        _coerceNumericProps(params);\n\n        // Ensure layers are unique across canvases by cloning them\n        layer = new jCanvasObject(params);\n        layer.canvas = canvas;\n        // Indicate that this is a layer for future checks\n        layer.layer = true;\n        layer._layer = true;\n        layer._running = {};\n        // If layer stores user-defined data\n        if (layer.data !== null) {\n          // Clone object\n          layer.data = extendObject({}, layer.data);\n        } else {\n          // Otherwise, create data object\n          layer.data = {};\n        }\n        // If layer stores a list of associated groups\n        if (layer.groups !== null) {\n          // Clone list\n          layer.groups = layer.groups.slice(0);\n        } else {\n          // Otherwise, create empty list\n          layer.groups = [];\n        }\n\n        // Update layer group maps\n        _updateLayerName($canvas, data, layer);\n        _updateLayerGroups($canvas, data, layer);\n\n        // Check for any associated jCanvas events and enable them\n        _addLayerEvents($canvas, data, layer);\n\n        // Optionally enable drag-and-drop support and cursor support\n        _enableDrag($canvas, data, layer);\n\n        // Copy _event property to parameters object\n        params._event = layer._event;\n\n        // Calculate width/height for text layers\n        if (layer._method === $.fn.drawText) {\n          $canvas.measureText(layer);\n        }\n\n        // Add layer to end of array if no index is specified\n        if (layer.index === null) {\n          layer.index = layers.length;\n        }\n\n        // Add layer to layers array at specified index\n        layers.splice(layer.index, 0, layer);\n\n        // Store layer on parameters object\n        params._args = layer;\n\n        // Trigger an 'add' event\n        _triggerLayerEvent($canvas, data, layer, 'add');\n\n      }\n\n    } else if (!params.layer) {\n      _coerceNumericProps(params);\n    }\n\n    return layer;\n  }\n\n// Add a jCanvas layer\n  $.fn.addLayer = function addLayer(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        params.layer = true;\n        _addLayer($canvases[e], params, args);\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Animation API */\n\n// Define properties used in both CSS and jCanvas\n  css.props = [\n    'width',\n    'height',\n    'opacity',\n    'lineHeight'\n  ];\n  css.propsObj = {};\n\n// Hide/show jCanvas/CSS properties so they can be animated using jQuery\n  function _showProps(obj) {\n    var cssProp, p;\n    for (p = 0; p < css.props.length; p += 1) {\n      cssProp = css.props[p];\n      obj[cssProp] = obj['_' + cssProp];\n    }\n  }\n  function _hideProps(obj, reset) {\n    var cssProp, p;\n    for (p = 0; p < css.props.length; p += 1) {\n      cssProp = css.props[p];\n      // Hide property using same name with leading underscore\n      if (obj[cssProp] !== undefined) {\n        obj['_' + cssProp] = obj[cssProp];\n        css.propsObj[cssProp] = true;\n        if (reset) {\n          delete obj[cssProp];\n        }\n      }\n    }\n  }\n\n// Evaluate property values that are functions\n  function _parseEndValues(canvas, layer, endValues) {\n    var propName, propValue,\n        subPropName, subPropValue;\n    // Loop through all properties in map of end values\n    for (propName in endValues) {\n      if (Object.prototype.hasOwnProperty.call(endValues, propName)) {\n        propValue = endValues[propName];\n        // If end value is function\n        if (isFunction(propValue)) {\n          // Call function and use its value as the end value\n          endValues[propName] = propValue.call(canvas, layer, propName);\n        }\n        // If end value is an object\n        if (typeOf(propValue) === 'object' && isPlainObject(propValue)) {\n          // Prepare to animate properties in object\n          for (subPropName in propValue) {\n            if (Object.prototype.hasOwnProperty.call(propValue, subPropName)) {\n              subPropValue = propValue[subPropName];\n              // Store property's start value at top-level of layer\n              if (layer[propName] !== undefined) {\n                layer[propName + '.' + subPropName] = layer[propName][subPropName];\n                // Store property's end value at top-level of end values map\n                endValues[propName + '.' + subPropName] = subPropValue;\n              }\n            }\n          }\n          // Delete sub-property of object as it's no longer needed\n          delete endValues[propName];\n        }\n      }\n    }\n    return endValues;\n  }\n\n// Remove sub-property aliases from layer object\n  function _removeSubPropAliases(layer) {\n    var propName;\n    for (propName in layer) {\n      if (Object.prototype.hasOwnProperty.call(layer, propName)) {\n        if (propName.indexOf('.') !== -1) {\n          delete layer[propName];\n        }\n      }\n    }\n  }\n\n// Convert a color value to an array of RGB values\n  function _colorToRgbArray(color) {\n    var originalColor, elem,\n        rgb = [],\n        multiple = 1;\n\n    // Deal with complete transparency\n    if (color === 'transparent') {\n      color = 'rgba(0, 0, 0, 0)';\n    } else if (color.match(/^([a-z]+|#[0-9a-f]+)$/gi)) {\n      // Deal with hexadecimal colors and color names\n      elem = document.head;\n      originalColor = elem.style.color;\n      elem.style.color = color;\n      color = $.css(elem, 'color');\n      elem.style.color = originalColor;\n    }\n    // Parse RGB string\n    if (color.match(/^rgb/gi)) {\n      rgb = color.match(/(\\d+(\\.\\d+)?)/gi);\n      // Deal with RGB percentages\n      if (color.match(/%/gi)) {\n        multiple = 2.55;\n      }\n      rgb[0] *= multiple;\n      rgb[1] *= multiple;\n      rgb[2] *= multiple;\n      // Ad alpha channel if given\n      if (rgb[3] !== undefined) {\n        rgb[3] = parseFloat(rgb[3]);\n      } else {\n        rgb[3] = 1;\n      }\n    }\n    return rgb;\n  }\n\n// Animate a hex or RGB color\n  function _animateColor(fx) {\n    var n = 3,\n        i;\n    // Only parse start and end colors once\n    if (typeOf(fx.start) !== 'array') {\n      fx.start = _colorToRgbArray(fx.start);\n      fx.end = _colorToRgbArray(fx.end);\n    }\n    fx.now = [];\n\n    // If colors are RGBA, animate transparency\n    if (fx.start[3] !== 1 || fx.end[3] !== 1) {\n      n = 4;\n    }\n\n    // Calculate current frame for red, green, blue, and alpha\n    for (i = 0; i < n; i += 1) {\n      fx.now[i] = fx.start[i] + ((fx.end[i] - fx.start[i]) * fx.pos);\n      // Only the red, green, and blue values must be integers\n      if (i < 3) {\n        fx.now[i] = round(fx.now[i]);\n      }\n    }\n    if (fx.start[3] !== 1 || fx.end[3] !== 1) {\n      // Only use RGBA if RGBA colors are given\n      fx.now = 'rgba(' + fx.now.join(',') + ')';\n    } else {\n      // Otherwise, animate as solid colors\n      fx.now.slice(0, 3);\n      fx.now = 'rgb(' + fx.now.join(',') + ')';\n    }\n    // Animate colors for both canvas layers and DOM elements\n    if (fx.elem.nodeName) {\n      fx.elem.style[fx.prop] = fx.now;\n    } else {\n      fx.elem[fx.prop] = fx.now;\n    }\n  }\n\n// Animate jCanvas layer\n  $.fn.animateLayer = function animateLayer() {\n    var $canvases = this, $canvas, e, ctx,\n        args = arraySlice.call(arguments, 0),\n        data, layer, props;\n\n    // Deal with all cases of argument placement\n    /*\n\t\t0. layer name/index\n\t\t1. properties\n\t\t2. duration/options\n\t\t3. easing\n\t\t4. complete function\n\t\t5. step function\n\t*/\n\n    if (typeOf(args[2]) === 'object') {\n\n      // Accept an options object for animation\n      args.splice(2, 0, args[2].duration || null);\n      args.splice(3, 0, args[3].easing || null);\n      args.splice(4, 0, args[4].complete || null);\n      args.splice(5, 0, args[5].step || null);\n\n    } else {\n\n      if (args[2] === undefined) {\n        // If object is the last argument\n        args.splice(2, 0, null);\n        args.splice(3, 0, null);\n        args.splice(4, 0, null);\n      } else if (isFunction(args[2])) {\n        // If callback comes after object\n        args.splice(2, 0, null);\n        args.splice(3, 0, null);\n      }\n      if (args[3] === undefined) {\n        // If duration is the last argument\n        args[3] = null;\n        args.splice(4, 0, null);\n      } else if (isFunction(args[3])) {\n        // If callback comes after duration\n        args.splice(3, 0, null);\n      }\n\n    }\n\n    // Run callback function when animation completes\n    function complete($canvas, data, layer) {\n\n      return function () {\n\n        _showProps(layer);\n        _removeSubPropAliases(layer);\n\n        // Prevent multiple redraw loops\n        if (!data.animating || data.animated === layer) {\n          // Redraw layers on last frame\n          $canvas.drawLayers();\n        }\n\n        // Signify the end of an animation loop\n        layer._animating = false;\n        data.animating = false;\n        data.animated = null;\n\n        // If callback is defined\n        if (args[4]) {\n          // Run callback at the end of the animation\n          args[4].call($canvas[0], layer);\n        }\n\n        _triggerLayerEvent($canvas, data, layer, 'animateend');\n\n      };\n\n    }\n\n    // Redraw layers on every frame of the animation\n    function step($canvas, data, layer) {\n\n      return function (now, fx) {\n        var parts, propName, subPropName,\n            hidden = false;\n\n        // If animated property has been hidden\n        if (fx.prop[0] === '_') {\n          hidden = true;\n          // Unhide property temporarily\n          fx.prop = fx.prop.replace('_', '');\n          layer[fx.prop] = layer['_' + fx.prop];\n        }\n\n        // If animating property of sub-object\n        if (fx.prop.indexOf('.') !== -1) {\n          parts = fx.prop.split('.');\n          propName = parts[0];\n          subPropName = parts[1];\n          if (layer[propName]) {\n            layer[propName][subPropName] = fx.now;\n          }\n        }\n\n        // Throttle animation to improve efficiency\n        if (layer._pos !== fx.pos) {\n\n          layer._pos = fx.pos;\n\n          // Signify the start of an animation loop\n          if (!layer._animating && !data.animating) {\n            layer._animating = true;\n            data.animating = true;\n            data.animated = layer;\n          }\n\n          // Prevent multiple redraw loops\n          if (!data.animating || data.animated === layer) {\n            // Redraw layers for every frame\n            $canvas.drawLayers();\n          }\n\n        }\n\n        // If callback is defined\n        if (args[5]) {\n          // Run callback for each step of animation\n          args[5].call($canvas[0], now, fx, layer);\n        }\n\n        _triggerLayerEvent($canvas, data, layer, 'animate', fx);\n\n        // If property should be hidden during animation\n        if (hidden) {\n          // Hide property again\n          fx.prop = '_' + fx.prop;\n        }\n\n      };\n\n    }\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        // If a layer object was passed, use it the layer to be animated\n        layer = $canvas.getLayer(args[0]);\n\n        // Ignore layers that are functions\n        if (layer && layer._method !== $.fn.draw) {\n\n          // Do not modify original object\n          props = extendObject({}, args[1]);\n\n          props = _parseEndValues($canvases[e], layer, props);\n\n          // Bypass jQuery CSS Hooks for CSS properties (width, opacity, etc.)\n          _hideProps(props, true);\n          _hideProps(layer);\n\n          // Fix for jQuery's vendor prefixing support, which affects how width/height/opacity are animated\n          layer.style = css.propsObj;\n\n          // Animate layer\n          $(layer).animate(props, {\n            duration: args[2],\n            easing: ($.easing[args[3]] ? args[3] : null),\n            // When animation completes\n            complete: complete($canvas, data, layer),\n            // Redraw canvas for every animation frame\n            step: step($canvas, data, layer)\n          });\n          _triggerLayerEvent($canvas, data, layer, 'animatestart');\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Animate all layers in a layer group\n  $.fn.animateLayerGroup = function animateLayerGroup(groupId) {\n    var $canvases = this, $canvas, e,\n        args = arraySlice.call(arguments, 0),\n        group, l;\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      group = $canvas.getLayerGroup(groupId);\n      if (group) {\n\n        // Animate all layers in the group\n        for (l = 0; l < group.length; l += 1) {\n\n          // Replace first argument with layer\n          args[0] = group[l];\n          $canvas.animateLayer.apply($canvas, args);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Delay layer animation by a given number of milliseconds\n  $.fn.delayLayer = function delayLayer(layerId, duration) {\n    var $canvases = this, $canvas, e,\n        data, layer;\n    duration = duration || 0;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n      // If layer exists\n      if (layer) {\n        // Delay animation\n        $(layer).delay(duration);\n        _triggerLayerEvent($canvas, data, layer, 'delay');\n      }\n    }\n    return $canvases;\n  };\n\n// Delay animation all layers in a layer group\n  $.fn.delayLayerGroup = function delayLayerGroup(groupId, duration) {\n    var $canvases = this, $canvas, e,\n        group, layer, l;\n    duration = duration || 0;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // Delay all layers in the group\n      if (group) {\n\n        for (l = 0; l < group.length; l += 1) {\n          // Delay each layer in the group\n          layer = group[l];\n          $canvas.delayLayer(layer, duration);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Stop layer animation\n  $.fn.stopLayer = function stopLayer(layerId, clearQueue) {\n    var $canvases = this, $canvas, e,\n        data, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n      // If layer exists\n      if (layer) {\n        // Stop animation\n        $(layer).stop(clearQueue);\n        _triggerLayerEvent($canvas, data, layer, 'stop');\n      }\n    }\n    return $canvases;\n  };\n\n// Stop animation of all layers in a layer group\n  $.fn.stopLayerGroup = function stopLayerGroup(groupId, clearQueue) {\n    var $canvases = this, $canvas, e,\n        group, layer, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // Stop all layers in the group\n      if (group) {\n\n        for (l = 0; l < group.length; l += 1) {\n          // Stop each layer in the group\n          layer = group[l];\n          $canvas.stopLayer(layer, clearQueue);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Enable animation for color properties\n  function _supportColorProps(props) {\n    var p;\n    for (p = 0; p < props.length; p += 1) {\n      $.fx.step[props[p]] = _animateColor;\n    }\n  }\n\n// Enable animation for color properties\n  _supportColorProps([\n    'color',\n    'backgroundColor',\n    'borderColor',\n    'borderTopColor',\n    'borderRightColor',\n    'borderBottomColor',\n    'borderLeftColor',\n    'fillStyle',\n    'outlineColor',\n    'strokeStyle',\n    'shadowColor'\n  ]);\n\n  /* Event API */\n\n// Map standard mouse events to touch events\n  maps.touchEvents = {\n    'mousedown': 'touchstart',\n    'mouseup': 'touchend',\n    'mousemove': 'touchmove'\n  };\n// Map standard touch events to mouse events\n  maps.mouseEvents = {\n    'touchstart': 'mousedown',\n    'touchend': 'mouseup',\n    'touchmove': 'mousemove'\n  };\n\n// Convert mouse event name to a corresponding touch event name (if possible)\n  function _getTouchEventName(eventName) {\n    // Detect touch event support\n    if (maps.touchEvents[eventName]) {\n      eventName = maps.touchEvents[eventName];\n    }\n    return eventName;\n  }\n// Convert touch event name to a corresponding mouse event name\n  function _getMouseEventName(eventName) {\n    if (maps.mouseEvents[eventName]) {\n      eventName = maps.mouseEvents[eventName];\n    }\n    return eventName;\n  }\n\n// Bind event to jCanvas layer using standard jQuery events\n  function _createEvent(eventName) {\n\n    jCanvas.events[eventName] = function ($canvas, data) {\n      var helperEventName, touchEventName, eventCache;\n\n      // Retrieve canvas's event cache\n      eventCache = data.event;\n\n      // Both mouseover/mouseout events will be managed by a single mousemove event\n      helperEventName = (eventName === 'mouseover' || eventName === 'mouseout') ? 'mousemove' : eventName;\n      touchEventName = _getTouchEventName(helperEventName);\n\n      function eventCallback(event) {\n        // Cache current mouse position and redraw layers\n        eventCache.x = event.offsetX;\n        eventCache.y = event.offsetY;\n        eventCache.type = helperEventName;\n        eventCache.event = event;\n        // Redraw layers on every trigger of the event; don't redraw if at\n        // least one layer is draggable and there are no layers with\n        // explicit mouseover/mouseout/mousemove events\n        if (event.type !== 'mousemove' || data.redrawOnMousemove || data.drag.dragging) {\n          $canvas.drawLayers({\n            resetFire: true\n          });\n        }\n        // Prevent default event behavior\n        event.preventDefault();\n      }\n\n      // Ensure the event is not bound more than once\n      if (!data.events[helperEventName]) {\n        // Bind one canvas event which handles all layer events of that type\n        if (touchEventName !== helperEventName) {\n          $canvas.bind(helperEventName + '.jCanvas ' + touchEventName + '.jCanvas', eventCallback);\n        } else {\n          $canvas.bind(helperEventName + '.jCanvas', eventCallback);\n        }\n        // Prevent this event from being bound twice\n        data.events[helperEventName] = true;\n      }\n    };\n  }\n  function _createEvents(eventNames) {\n    var n;\n    for (n = 0; n < eventNames.length; n += 1) {\n      _createEvent(eventNames[n]);\n    }\n  }\n// Populate jCanvas events object with some standard events\n  _createEvents([\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseup',\n    'mousemove',\n    'mouseover',\n    'mouseout',\n    'touchstart',\n    'touchmove',\n    'touchend',\n    'pointerdown',\n    'pointermove',\n    'pointerup',\n    'contextmenu'\n  ]);\n\n// Check if event fires when a drawing is drawn\n  function _detectEvents(canvas, ctx, params) {\n    var layer, data, eventCache, intersects,\n        transforms, x, y, angle;\n\n    // Use the layer object stored by the given parameters object\n    layer = params._args;\n    // Canvas must have event bindings\n    if (layer) {\n\n      data = _getCanvasData(canvas);\n      eventCache = data.event;\n      if (eventCache.x !== null && eventCache.y !== null) {\n        // Respect user-defined pixel ratio\n        x = eventCache.x * data.pixelRatio;\n        y = eventCache.y * data.pixelRatio;\n        // Determine if the given coordinates are in the current path\n        intersects = ctx.isPointInPath(x, y) || (ctx.isPointInStroke && ctx.isPointInStroke(x, y));\n      }\n      transforms = data.transforms;\n\n      // Allow callback functions to retrieve the mouse coordinates\n      layer.eventX = eventCache.x;\n      layer.eventY = eventCache.y;\n      layer.event = eventCache.event;\n\n      // Adjust coordinates to match current canvas transformation\n\n      // Keep track of some transformation values\n      angle = data.transforms.rotate;\n      x = layer.eventX;\n      y = layer.eventY;\n\n      if (angle !== 0) {\n        // Rotate coordinates if coordinate space has been rotated\n        layer._eventX = (x * cos(-angle)) - (y * sin(-angle));\n        layer._eventY = (y * cos(-angle)) + (x * sin(-angle));\n      } else {\n        // Otherwise, no calculations need to be made\n        layer._eventX = x;\n        layer._eventY = y;\n      }\n\n      // Scale coordinates\n      layer._eventX /= transforms.scaleX;\n      layer._eventY /= transforms.scaleY;\n\n      // If layer intersects with cursor\n      if (intersects) {\n        // Add it to a list of layers that intersect with cursor\n        data.intersecting.push(layer);\n      }\n      layer.intersects = Boolean(intersects);\n    }\n  }\n\n// Normalize offsetX and offsetY for all browsers\n  $.event.fix = function (event) {\n    var offset, originalEvent, touches;\n\n    event = jQueryEventFix.call($.event, event);\n    originalEvent = event.originalEvent;\n\n    // originalEvent does not exist for manually-triggered events\n    if (originalEvent) {\n\n      touches = originalEvent.changedTouches;\n\n      // If offsetX and offsetY are not supported, define them\n      if (event.pageX !== undefined && event.offsetX === undefined) {\n        try {\n          offset = $(event.currentTarget).offset();\n          if (offset) {\n            event.offsetX = event.pageX - offset.left;\n            event.offsetY = event.pageY - offset.top;\n          }\n        } catch (error) {\n          // Fail silently\n        }\n      } else if (touches) {\n        try {\n          // Enable offsetX and offsetY for mobile devices\n          offset = $(event.currentTarget).offset();\n          if (offset) {\n            event.offsetX = touches[0].pageX - offset.left;\n            event.offsetY = touches[0].pageY - offset.top;\n          }\n        } catch (error) {\n          // Fail silently\n        }\n      }\n\n    }\n    return event;\n  };\n\n  /* Drawing API */\n\n// Map drawing names with their respective method names\n  maps.drawings = {\n    'arc': 'drawArc',\n    'bezier': 'drawBezier',\n    'ellipse': 'drawEllipse',\n    'function': 'draw',\n    'image': 'drawImage',\n    'line': 'drawLine',\n    'path': 'drawPath',\n    'polygon': 'drawPolygon',\n    'slice': 'drawSlice',\n    'quadratic': 'drawQuadratic',\n    'rectangle': 'drawRect',\n    'text': 'drawText',\n    'vector': 'drawVector',\n    'save': 'saveCanvas',\n    'restore': 'restoreCanvas',\n    'rotate': 'rotateCanvas',\n    'scale': 'scaleCanvas',\n    'translate': 'translateCanvas'\n  };\n\n// Draws on canvas using a function\n  $.fn.draw = function draw(args) {\n    var $canvases = this, e, ctx,\n        params = new jCanvasObject(args);\n\n    // Draw using any other method\n    if (maps.drawings[params.type] && params.type !== 'function') {\n\n      $canvases[maps.drawings[params.type]](args);\n\n    } else {\n\n      for (e = 0; e < $canvases.length; e += 1) {\n        ctx = _getContext($canvases[e]);\n        if (ctx) {\n\n          params = new jCanvasObject(args);\n          _addLayer($canvases[e], params, args, draw);\n          if (params.visible) {\n\n            if (params.fn) {\n              // Call the given user-defined function\n              params.fn.call($canvases[e], ctx, params);\n            }\n\n          }\n\n        }\n      }\n\n    }\n    return $canvases;\n  };\n\n// Clears canvas\n  $.fn.clearCanvas = function clearCanvas(args) {\n    var $canvases = this, e, ctx,\n        params = new jCanvasObject(args);\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        if (params.width === null || params.height === null) {\n          // Clear entire canvas if width/height is not given\n\n          // Reset current transformation temporarily to ensure that the entire canvas is cleared\n          ctx.save();\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.clearRect(0, 0, $canvases[e].width, $canvases[e].height);\n          ctx.restore();\n\n        } else {\n          // Otherwise, clear the defined section of the canvas\n\n          // Transform clear rectangle\n          _addLayer($canvases[e], params, args, clearCanvas);\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          ctx.clearRect(params.x - (params.width / 2), params.y - (params.height / 2), params.width, params.height);\n          // Restore previous transformation\n          _restoreTransform(ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Transformation API */\n\n// Restores canvas\n  $.fn.saveCanvas = function saveCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, saveCanvas);\n\n        // Restore a number of times using the given count\n        for (i = 0; i < params.count; i += 1) {\n          _saveCanvas(ctx, data);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Restores canvas\n  $.fn.restoreCanvas = function restoreCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, restoreCanvas);\n\n        // Restore a number of times using the given count\n        for (i = 0; i < params.count; i += 1) {\n          _restoreCanvas(ctx, data);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Rotates canvas (internal)\n  function _rotateCanvas(ctx, params, transforms) {\n\n    // Get conversion factor for radians\n    params._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n    // Rotate canvas using shape as center of rotation\n    ctx.translate(params.x, params.y);\n    ctx.rotate(params.rotate * params._toRad);\n    ctx.translate(-params.x, -params.y);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.rotate += (params.rotate * params._toRad);\n    }\n  }\n\n// Scales canvas (internal)\n  function _scaleCanvas(ctx, params, transforms) {\n\n    // Scale both the x- and y- axis using the 'scale' property\n    if (params.scale !== 1) {\n      params.scaleX = params.scaleY = params.scale;\n    }\n\n    // Scale canvas using shape as center of rotation\n    ctx.translate(params.x, params.y);\n    ctx.scale(params.scaleX, params.scaleY);\n    ctx.translate(-params.x, -params.y);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.scaleX *= params.scaleX;\n      transforms.scaleY *= params.scaleY;\n    }\n  }\n\n// Translates canvas (internal)\n  function _translateCanvas(ctx, params, transforms) {\n\n    // Translate both the x- and y-axis using the 'translate' property\n    if (params.translate) {\n      params.translateX = params.translateY = params.translate;\n    }\n\n    // Translate canvas\n    ctx.translate(params.translateX, params.translateY);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.translateX += params.translateX;\n      transforms.translateY += params.translateY;\n    }\n  }\n\n// Rotates canvas\n  $.fn.rotateCanvas = function rotateCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, rotateCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _rotateCanvas(ctx, params, data.transforms);\n      }\n\n    }\n    return $canvases;\n  };\n\n// Scales canvas\n  $.fn.scaleCanvas = function scaleCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, scaleCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _scaleCanvas(ctx, params, data.transforms);\n\n      }\n    }\n    return $canvases;\n  };\n\n// Translates canvas\n  $.fn.translateCanvas = function translateCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, translateCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _translateCanvas(ctx, params, data.transforms);\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Shape API */\n\n// Draws rectangle\n  $.fn.drawRect = function drawRect(args) {\n    var $canvases = this, e, ctx,\n        params,\n        x1, y1,\n        x2, y2,\n        r, temp;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawRect);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          if (params.width && params.height) {\n            x1 = params.x - (params.width / 2);\n            y1 = params.y - (params.height / 2);\n            r = abs(params.cornerRadius);\n            // If corner radius is defined and is not zero\n            if (r) {\n              // Draw rectangle with rounded corners if cornerRadius is defined\n\n              x2 = params.x + (params.width / 2);\n              y2 = params.y + (params.height / 2);\n\n              // Handle negative width\n              if (params.width < 0) {\n                temp = x1;\n                x1 = x2;\n                x2 = temp;\n              }\n              // Handle negative height\n              if (params.height < 0) {\n                temp = y1;\n                y1 = y2;\n                y2 = temp;\n              }\n\n              // Prevent over-rounded corners\n              if ((x2 - x1) - (2 * r) < 0) {\n                r = (x2 - x1) / 2;\n              }\n              if ((y2 - y1) - (2 * r) < 0) {\n                r = (y2 - y1) / 2;\n              }\n\n              // Draw rectangle\n              ctx.moveTo(x1 + r, y1);\n              ctx.lineTo(x2 - r, y1);\n              ctx.arc(x2 - r, y1 + r, r, 3 * PI / 2, PI * 2, false);\n              ctx.lineTo(x2, y2 - r);\n              ctx.arc(x2 - r, y2 - r, r, 0, PI / 2, false);\n              ctx.lineTo(x1 + r, y2);\n              ctx.arc(x1 + r, y2 - r, r, PI / 2, PI, false);\n              ctx.lineTo(x1, y1 + r);\n              ctx.arc(x1 + r, y1 + r, r, PI, 3 * PI / 2, false);\n              // Always close path\n              params.closed = true;\n\n            } else {\n\n              // Otherwise, draw rectangle with square corners\n              ctx.rect(x1, y1, params.width, params.height);\n\n            }\n          }\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Close rectangle path\n          _closePath($canvases[e], ctx, params);\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves a coterminal angle between 0 and 2pi for the given angle\n  function _getCoterminal(angle) {\n    while (angle < 0) {\n      angle += (2 * PI);\n    }\n    return angle;\n  }\n\n// Retrieves the x-coordinate for the given angle in a circle\n  function _getArcX(params, angle) {\n    return params.x + (params.radius * cos(angle));\n  }\n// Retrieves the y-coordinate for the given angle in a circle\n  function _getArcY(params, angle) {\n    return params.y + (params.radius * sin(angle));\n  }\n\n// Draws arc (internal)\n  function _drawArc(canvas, ctx, params, path) {\n    var x1, y1, x2, y2,\n        x3, y3, x4, y4,\n        offsetX, offsetY,\n        diff;\n\n    // Determine offset from dragging\n    if (params === path) {\n      offsetX = 0;\n      offsetY = 0;\n    } else {\n      offsetX = params.x;\n      offsetY = params.y;\n    }\n\n    // Convert default end angle to radians\n    if (!path.inDegrees && path.end === 360) {\n      path.end = PI * 2;\n    }\n\n    // Convert angles to radians\n    path.start *= params._toRad;\n    path.end *= params._toRad;\n    // Consider 0deg due north of arc\n    path.start -= (PI / 2);\n    path.end -= (PI / 2);\n\n    // Ensure arrows are pointed correctly for CCW arcs\n    diff = PI / 180;\n    if (path.ccw) {\n      diff *= -1;\n    }\n\n    // Calculate coordinates for start arrow\n    x1 = _getArcX(path, path.start + diff);\n    y1 = _getArcY(path, path.start + diff);\n    x2 = _getArcX(path, path.start);\n    y2 = _getArcY(path, path.start);\n\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        x1, y1,\n        x2, y2\n    );\n\n    // Draw arc\n    ctx.arc(path.x + offsetX, path.y + offsetY, path.radius, path.start, path.end, path.ccw);\n\n    // Calculate coordinates for end arrow\n    x3 = _getArcX(path, path.end + diff);\n    y3 = _getArcY(path, path.end + diff);\n    x4 = _getArcX(path, path.end);\n    y4 = _getArcY(path, path.end);\n\n    _addEndArrow(\n        canvas, ctx,\n        params, path,\n        x4, y4,\n        x3, y3\n    );\n  }\n\n// Draws arc or circle\n  $.fn.drawArc = function drawArc(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawArc);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          _drawArc($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Draws ellipse\n  $.fn.drawEllipse = function drawEllipse(args) {\n    var $canvases = this, e, ctx,\n        params,\n        controlW,\n        controlH;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawEllipse);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Calculate control width and height\n          controlW = params.width * (4 / 3);\n          controlH = params.height;\n\n          // Create ellipse using curves\n          ctx.beginPath();\n          ctx.moveTo(params.x, params.y - (controlH / 2));\n          // Left side\n          ctx.bezierCurveTo(params.x - (controlW / 2), params.y - (controlH / 2), params.x - (controlW / 2), params.y + (controlH / 2), params.x, params.y + (controlH / 2));\n          // Right side\n          ctx.bezierCurveTo(params.x + (controlW / 2), params.y + (controlH / 2), params.x + (controlW / 2), params.y - (controlH / 2), params.x, params.y - (controlH / 2));\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws a regular (equal-angled) polygon\n  $.fn.drawPolygon = function drawPolygon(args) {\n    var $canvases = this, e, ctx,\n        params,\n        theta, dtheta, hdtheta,\n        apothem,\n        x, y, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawPolygon);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Polygon's central angle\n          dtheta = (2 * PI) / params.sides;\n          // Half of dtheta\n          hdtheta = dtheta / 2;\n          // Polygon's starting angle\n          theta = hdtheta + (PI / 2);\n          // Distance from polygon's center to the middle of its side\n          apothem = params.radius * cos(hdtheta);\n\n          // Calculate path and draw\n          ctx.beginPath();\n          for (i = 0; i < params.sides; i += 1) {\n\n            // Draw side of polygon\n            x = params.x + (params.radius * cos(theta));\n            y = params.y + (params.radius * sin(theta));\n\n            // Plot point on polygon\n            ctx.lineTo(x, y);\n\n            // Project side if chosen\n            if (params.concavity) {\n              // Sides are projected from the polygon's apothem\n              x = params.x + ((apothem + (-apothem * params.concavity)) * cos(theta + hdtheta));\n              y = params.y + ((apothem + (-apothem * params.concavity)) * sin(theta + hdtheta));\n              ctx.lineTo(x, y);\n            }\n\n            // Increment theta by delta theta\n            theta += dtheta;\n\n          }\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws pie-shaped slice\n  $.fn.drawSlice = function drawSlice(args) {\n    var $canvases = this, e, ctx,\n        params,\n        angle, dx, dy;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawSlice);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Perform extra calculations\n\n          // Convert angles to radians\n          params.start *= params._toRad;\n          params.end *= params._toRad;\n          // Consider 0deg at north of arc\n          params.start -= (PI / 2);\n          params.end -= (PI / 2);\n\n          // Find positive equivalents of angles\n          params.start = _getCoterminal(params.start);\n          params.end = _getCoterminal(params.end);\n          // Ensure start angle is less than end angle\n          if (params.end < params.start) {\n            params.end += (2 * PI);\n          }\n\n          // Calculate angular position of slice\n          angle = ((params.start + params.end) / 2);\n\n          // Calculate ratios for slice's angle\n          dx = (params.radius * params.spread * cos(angle));\n          dy = (params.radius * params.spread * sin(angle));\n\n          // Adjust position of slice\n          params.x += dx;\n          params.y += dy;\n\n          // Draw slice\n          ctx.beginPath();\n          ctx.arc(params.x, params.y, params.radius, params.start, params.end, params.ccw);\n          ctx.lineTo(params.x, params.y);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Path API */\n\n// Adds arrow to path using the given properties\n  function _addArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    var leftX, leftY,\n        rightX, rightY,\n        offsetX, offsetY,\n        angle;\n\n    // If arrow radius is given and path is not closed\n    if (path.arrowRadius && !params.closed) {\n\n      // Calculate angle\n      angle = atan2((y2 - y1), (x2 - x1));\n      // Adjust angle correctly\n      angle -= PI;\n      // Calculate offset to place arrow at edge of path\n      offsetX = (params.strokeWidth * cos(angle));\n      offsetY = (params.strokeWidth * sin(angle));\n\n      // Calculate coordinates for left half of arrow\n      leftX = x2 + (path.arrowRadius * cos(angle + (path.arrowAngle / 2)));\n      leftY = y2 + (path.arrowRadius * sin(angle + (path.arrowAngle / 2)));\n      // Calculate coordinates for right half of arrow\n      rightX = x2 + (path.arrowRadius * cos(angle - (path.arrowAngle / 2)));\n      rightY = y2 + (path.arrowRadius * sin(angle - (path.arrowAngle / 2)));\n\n      // Draw left half of arrow\n      ctx.moveTo(leftX - offsetX, leftY - offsetY);\n      ctx.lineTo(x2 - offsetX, y2 - offsetY);\n      // Draw right half of arrow\n      ctx.lineTo(rightX - offsetX, rightY - offsetY);\n\n      // Visually connect arrow to path\n      ctx.moveTo(x2 - offsetX, y2 - offsetY);\n      ctx.lineTo(x2 + offsetX, y2 + offsetY);\n      // Move back to end of path\n      ctx.moveTo(x2, y2);\n\n    }\n  }\n\n// Optionally adds arrow to start of path\n  function _addStartArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    if (!path._arrowAngleConverted) {\n      path.arrowAngle *= params._toRad;\n      path._arrowAngleConverted = true;\n    }\n    if (path.startArrow) {\n      _addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n    }\n  }\n\n// Optionally adds arrow to end of path\n  function _addEndArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    if (!path._arrowAngleConverted) {\n      path.arrowAngle *= params._toRad;\n      path._arrowAngleConverted = true;\n    }\n    if (path.endArrow) {\n      _addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n    }\n  }\n\n// Draws line (internal)\n  function _drawLine(canvas, ctx, params, path) {\n    var l,\n        lx, ly;\n    l = 2;\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        path.x2 + params.x,\n        path.y2 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      // If coordinates are given\n      if (lx !== undefined && ly !== undefined) {\n        // Draw next line\n        ctx.lineTo(lx + params.x, ly + params.y);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    // Optionally add arrows to path\n    _addEndArrow(\n        canvas, ctx,\n        params,\n        path,\n        path['x' + (l - 1)] + params.x,\n        path['y' + (l - 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws line\n  $.fn.drawLine = function drawLine(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawLine);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawLine($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Draws quadratic curve (internal)\n  function _drawQuadratic(canvas, ctx, params, path) {\n    var l,\n        lx, ly,\n        lcx, lcy;\n\n    l = 2;\n\n    _addStartArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path.cx1 + params.x,\n        path.cy1 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      lcx = path['cx' + (l - 1)];\n      lcy = path['cy' + (l - 1)];\n      // If coordinates are given\n      if (lx !== undefined && ly !== undefined && lcx !== undefined && lcy !== undefined) {\n        // Draw next curve\n        ctx.quadraticCurveTo(lcx + params.x, lcy + params.y, lx + params.x, ly + params.y);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    _addEndArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path['cx' + (l - 1)] + params.x,\n        path['cy' + (l - 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws quadratic curve\n  $.fn.drawQuadratic = function drawQuadratic(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawQuadratic);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawQuadratic($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws Bezier curve (internal)\n  function _drawBezier(canvas, ctx, params, path) {\n    var l, lc,\n        lx, ly,\n        lcx1, lcy1,\n        lcx2, lcy2;\n\n    l = 2;\n    lc = 1;\n\n    _addStartArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path.cx1 + params.x,\n        path.cy1 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      lcx1 = path['cx' + lc];\n      lcy1 = path['cy' + lc];\n      lcx2 = path['cx' + (lc + 1)];\n      lcy2 = path['cy' + (lc + 1)];\n      // If next coordinates are given\n      if (lx !== undefined && ly !== undefined && lcx1 !== undefined && lcy1 !== undefined && lcx2 !== undefined && lcy2 !== undefined) {\n        // Draw next curve\n        ctx.bezierCurveTo(lcx1 + params.x, lcy1 + params.y, lcx2 + params.x, lcy2 + params.y, lx + params.x, ly + params.y);\n        l += 1;\n        lc += 2;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    lc -= 2;\n    _addEndArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path['cx' + (lc + 1)] + params.x,\n        path['cy' + (lc + 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws Bezier curve\n  $.fn.drawBezier = function drawBezier(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawBezier);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawBezier($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves the x-coordinate for the given vector angle and length\n  function _getVectorX(params, angle, length) {\n    angle *= params._toRad;\n    angle -= (PI / 2);\n    return (length * cos(angle));\n  }\n// Retrieves the y-coordinate for the given vector angle and length\n  function _getVectorY(params, angle, length) {\n    angle *= params._toRad;\n    angle -= (PI / 2);\n    return (length * sin(angle));\n  }\n\n// Draws vector (internal) #2\n  function _drawVector(canvas, ctx, params, path) {\n    var l, angle, length,\n        offsetX, offsetY,\n        x, y,\n        x3, y3,\n        x4, y4;\n\n    // Determine offset from dragging\n    if (params === path) {\n      offsetX = 0;\n      offsetY = 0;\n    } else {\n      offsetX = params.x;\n      offsetY = params.y;\n    }\n\n    l = 1;\n    x = x3 = x4 = path.x + offsetX;\n    y = y3 = y4 = path.y + offsetY;\n\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        x + _getVectorX(params, path.a1, path.l1),\n        y + _getVectorY(params, path.a1, path.l1),\n        x,\n        y\n    );\n\n    // The vector starts at the given (x, y) coordinates\n    if (path.x !== undefined && path.y !== undefined) {\n      ctx.moveTo(x, y);\n    }\n    while (true) {\n\n      angle = path['a' + l];\n      length = path['l' + l];\n\n      if (angle !== undefined && length !== undefined) {\n        // Convert the angle to radians with 0 degrees starting at north\n        // Keep track of last two coordinates\n        x3 = x4;\n        y3 = y4;\n        // Compute (x, y) coordinates from angle and length\n        x4 += _getVectorX(params, angle, length);\n        y4 += _getVectorY(params, angle, length);\n        ctx.lineTo(x4, y4);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n\n    }\n    _addEndArrow(\n        canvas, ctx,\n        params, path,\n        x3, y3,\n        x4, y4\n    );\n  }\n\n// Draws vector\n  $.fn.drawVector = function drawVector(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawVector);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawVector($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws a path consisting of one or more subpaths\n  $.fn.drawPath = function drawPath(args) {\n    var $canvases = this, e, ctx,\n        params,\n        l, lp;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawPath);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          l = 1;\n          while (true) {\n            lp = params['p' + l];\n            if (lp !== undefined) {\n              lp = new jCanvasObject(lp);\n              if (lp.type === 'line') {\n                _drawLine($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'quadratic') {\n                _drawQuadratic($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'bezier') {\n                _drawBezier($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'vector') {\n                _drawVector($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'arc') {\n                _drawArc($canvases[e], ctx, params, lp);\n              }\n              l += 1;\n            } else {\n              break;\n            }\n          }\n\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Text API */\n\n// Calculates font string and set it as the canvas font\n  function _setCanvasFont(canvas, ctx, params) {\n    // Otherwise, use the given font attributes\n    if (!isNaN(Number(params.fontSize))) {\n      // Give font size units if it doesn't have any\n      params.fontSize += 'px';\n    }\n    // Set font using given font properties\n    ctx.font = params.fontStyle + ' ' + params.fontSize + ' ' + params.fontFamily;\n  }\n\n// Measures canvas text\n  function _measureText(canvas, ctx, params, lines) {\n    var originalSize, curWidth, l,\n        propCache = caches.propCache;\n\n    // Used cached width/height if possible\n    if (propCache.text === params.text && propCache.fontStyle === params.fontStyle && propCache.fontSize === params.fontSize && propCache.fontFamily === params.fontFamily && propCache.maxWidth === params.maxWidth && propCache.lineHeight === params.lineHeight) {\n\n      params.width = propCache.width;\n      params.height = propCache.height;\n\n    } else {\n      // Calculate text dimensions only once\n\n      // Calculate width of first line (for comparison)\n      params.width = ctx.measureText(lines[0]).width;\n\n      // Get width of longest line\n      for (l = 1; l < lines.length; l += 1) {\n\n        curWidth = ctx.measureText(lines[l]).width;\n        // Ensure text's width is the width of its longest line\n        if (curWidth > params.width) {\n          params.width = curWidth;\n        }\n\n      }\n\n      // Save original font size\n      originalSize = canvas.style.fontSize;\n      // Temporarily set canvas font size to retrieve size in pixels\n      canvas.style.fontSize = params.fontSize;\n      // Save text width and height in parameters object\n      params.height = parseFloat($.css(canvas, 'fontSize')) * lines.length * params.lineHeight;\n      // Reset font size to original size\n      canvas.style.fontSize = originalSize;\n    }\n  }\n\n// Wraps a string of text within a defined width\n  function _wrapText(ctx, params) {\n    var allText = String(params.text),\n        // Maximum line width (optional)\n        maxWidth = params.maxWidth,\n        // Lines created by manual line breaks (\\n)\n        manualLines = allText.split('\\n'),\n        // All lines created manually and by wrapping\n        allLines = [],\n        // Other variables\n        lines, line, l,\n        text, words, w;\n\n    // Loop through manually-broken lines\n    for (l = 0; l < manualLines.length; l += 1) {\n\n      text = manualLines[l];\n      // Split line into list of words\n      words = text.split(' ');\n      lines = [];\n      line = '';\n\n      // If text is short enough initially\n      // Or, if the text consists of only one word\n      if (words.length === 1 || ctx.measureText(text).width < maxWidth) {\n\n        // No need to wrap text\n        lines = [text];\n\n      } else {\n\n        // Wrap lines\n        for (w = 0; w < words.length; w += 1) {\n\n          // Once line gets too wide, push word to next line\n          if (ctx.measureText(line + words[w]).width > maxWidth) {\n            // This check prevents empty lines from being created\n            if (line !== '') {\n              lines.push(line);\n            }\n            // Start new line and repeat process\n            line = '';\n          }\n          // Add words to line until the line is too wide\n          line += words[w];\n          // Do not add a space after the last word\n          if (w !== (words.length - 1)) {\n            line += ' ';\n          }\n        }\n        // The last word should always be pushed\n        lines.push(line);\n\n      }\n      // Remove extra space at the end of each line\n      allLines = allLines.concat(\n          lines\n              .join('\\n')\n              .replace(/((\\n))|($)/gi, '$2')\n              .split('\\n')\n      );\n\n    }\n\n    return allLines;\n  }\n\n// Draws text on canvas\n  $.fn.drawText = function drawText(args) {\n    var $canvases = this, e, ctx,\n        params, layer,\n        lines, line, l,\n        fontSize, constantCloseness = 500,\n        nchars, chars, ch, c,\n        x, y;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawText);\n        if (params.visible) {\n\n          // Set text-specific properties\n          ctx.textBaseline = params.baseline;\n          ctx.textAlign = params.align;\n\n          // Set canvas font using given properties\n          _setCanvasFont($canvases[e], ctx, params);\n\n          if (params.maxWidth !== null) {\n            // Wrap text using an internal function\n            lines = _wrapText(ctx, params);\n          } else {\n            // Convert string of text to list of lines\n            lines = params.text\n                .toString()\n                .split('\\n');\n          }\n\n          // Calculate text's width and height\n          _measureText($canvases[e], ctx, params, lines);\n\n          // If text is a layer\n          if (layer) {\n            // Copy calculated width/height to layer object\n            layer.width = params.width;\n            layer.height = params.height;\n          }\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Adjust text position to accomodate different horizontal alignments\n          x = params.x;\n          if (params.align === 'left') {\n            if (params.respectAlign) {\n              // Realign text to the left if chosen\n              params.x += params.width / 2;\n            } else {\n              // Center text block by default\n              x -= params.width / 2;\n            }\n          } else if (params.align === 'right') {\n            if (params.respectAlign) {\n              // Realign text to the right if chosen\n              params.x -= params.width / 2;\n            } else {\n              // Center text block by default\n              x += params.width / 2;\n            }\n          }\n\n          if (params.radius) {\n\n            fontSize = parseFloat(params.fontSize);\n\n            // Greater values move clockwise\n            if (params.letterSpacing === null) {\n              params.letterSpacing = fontSize / constantCloseness;\n            }\n\n            // Loop through each line of text\n            for (l = 0; l < lines.length; l += 1) {\n              ctx.save();\n              ctx.translate(params.x, params.y);\n              line = lines[l];\n              if (params.flipArcText) {\n                chars = line.split('');\n                chars.reverse();\n                line = chars.join('');\n              }\n              nchars = line.length;\n              ctx.rotate(-(PI * params.letterSpacing * (nchars - 1)) / 2);\n              // Loop through characters on each line\n              for (c = 0; c < nchars; c += 1) {\n                ch = line[c];\n                // If character is not the first character\n                if (c !== 0) {\n                  // Rotate character onto arc\n                  ctx.rotate(PI * params.letterSpacing);\n                }\n                ctx.save();\n                ctx.translate(0, -params.radius);\n                if (params.flipArcText) {\n                  ctx.scale(-1, -1);\n                }\n                ctx.fillText(ch, 0, 0);\n                // Prevent extra shadow created by stroke (but only when fill is present)\n                if (params.fillStyle !== 'transparent') {\n                  ctx.shadowColor = 'transparent';\n                }\n                if (params.strokeWidth !== 0) {\n                  // Only stroke if the stroke is not 0\n                  ctx.strokeText(ch, 0, 0);\n                }\n                ctx.restore();\n              }\n              params.radius -= fontSize;\n              params.letterSpacing += fontSize / (constantCloseness * 2 * PI);\n              ctx.restore();\n            }\n\n          } else {\n\n            // Draw each line of text separately\n            for (l = 0; l < lines.length; l += 1) {\n              line = lines[l];\n              // Add line offset to center point, but subtract some to center everything\n              y = params.y + (l * params.height / lines.length) - (((lines.length - 1) * params.height / lines.length) / 2);\n\n              ctx.shadowColor = params.shadowColor;\n\n              // Fill & stroke text\n              ctx.fillText(line, x, y);\n              // Prevent extra shadow created by stroke (but only when fill is present)\n              if (params.fillStyle !== 'transparent') {\n                ctx.shadowColor = 'transparent';\n              }\n              if (params.strokeWidth !== 0) {\n                // Only stroke if the stroke is not 0\n                ctx.strokeText(line, x, y);\n              }\n\n            }\n\n          }\n\n          // Adjust bounding box according to text baseline\n          y = 0;\n          if (params.baseline === 'top') {\n            y += params.height / 2;\n          } else if (params.baseline === 'bottom') {\n            y -= params.height / 2;\n          }\n\n          // Detect jCanvas events\n          if (params._event) {\n            ctx.beginPath();\n            ctx.rect(\n                params.x - (params.width / 2),\n                params.y - (params.height / 2) + y,\n                params.width,\n                params.height\n            );\n            _detectEvents($canvases[e], ctx, params);\n            // Close path and configure masking\n            ctx.closePath();\n          }\n          _restoreTransform(ctx, params);\n\n        }\n      }\n    }\n    // Cache jCanvas parameters object for efficiency\n    caches.propCache = params;\n    return $canvases;\n  };\n\n// Measures text width/height using the given parameters\n  $.fn.measureText = function measureText(args) {\n    var $canvases = this, ctx,\n        params, lines;\n\n    // Attempt to retrieve layer\n    params = $canvases.getLayer(args);\n    // If layer does not exist or if returned object is not a jCanvas layer\n    if (!params || (params && !params._layer)) {\n      params = new jCanvasObject(args);\n    }\n\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      // Set canvas font using given properties\n      _setCanvasFont($canvases[0], ctx, params);\n      // Calculate width and height of text\n      if (params.maxWidth !== null) {\n        lines = _wrapText(ctx, params);\n      } else {\n        lines = params.text.split('\\n');\n      }\n      _measureText($canvases[0], ctx, params, lines);\n\n\n    }\n\n    return params;\n  };\n\n  /* Image API */\n\n// Draws image on canvas\n  $.fn.drawImage = function drawImage(args) {\n    var $canvases = this, canvas, e, ctx, data,\n        params, layer,\n        img, imgCtx, source,\n        imageCache = caches.imageCache;\n\n    // Draw image function\n    function draw(canvas, ctx, data, params, layer) {\n\n      // If width and sWidth are not defined, use image width\n      if (params.width === null && params.sWidth === null) {\n        params.width = params.sWidth = img.width;\n      }\n      // If width and sHeight are not defined, use image height\n      if (params.height === null && params.sHeight === null) {\n        params.height = params.sHeight = img.height;\n      }\n\n      // Ensure image layer's width and height are accurate\n      if (layer) {\n        layer.width = params.width;\n        layer.height = params.height;\n      }\n\n      // Only crop image if all cropping properties are given\n      if (params.sWidth !== null && params.sHeight !== null && params.sx !== null && params.sy !== null) {\n\n        // If width is not defined, use the given sWidth\n        if (params.width === null) {\n          params.width = params.sWidth;\n        }\n        // If height is not defined, use the given sHeight\n        if (params.height === null) {\n          params.height = params.sHeight;\n        }\n\n        // Optionally crop from top-left corner of region\n        if (params.cropFromCenter) {\n          params.sx += params.sWidth / 2;\n          params.sy += params.sHeight / 2;\n        }\n\n        // Ensure cropped region does not escape image boundaries\n\n        // Top\n        if ((params.sy - (params.sHeight / 2)) < 0) {\n          params.sy = (params.sHeight / 2);\n        }\n        // Bottom\n        if ((params.sy + (params.sHeight / 2)) > img.height) {\n          params.sy = img.height - (params.sHeight / 2);\n        }\n        // Left\n        if ((params.sx - (params.sWidth / 2)) < 0) {\n          params.sx = (params.sWidth / 2);\n        }\n        // Right\n        if ((params.sx + (params.sWidth / 2)) > img.width) {\n          params.sx = img.width - (params.sWidth / 2);\n        }\n\n        _transformShape(canvas, ctx, params, params.width, params.height);\n        _setGlobalProps(canvas, ctx, params);\n\n        // Draw image\n        ctx.drawImage(\n            img,\n            params.sx - (params.sWidth / 2),\n            params.sy - (params.sHeight / 2),\n            params.sWidth,\n            params.sHeight,\n            params.x - (params.width / 2),\n            params.y - (params.height / 2),\n            params.width,\n            params.height\n        );\n\n      } else {\n        // Show entire image if no crop region is defined\n\n        _transformShape(canvas, ctx, params, params.width, params.height);\n        _setGlobalProps(canvas, ctx, params);\n\n        // Draw image on canvas\n        ctx.drawImage(\n            img,\n            params.x - (params.width / 2),\n            params.y - (params.height / 2),\n            params.width,\n            params.height\n        );\n\n      }\n\n      // Draw invisible rectangle to allow for events and masking\n      ctx.beginPath();\n      ctx.rect(\n          params.x - (params.width / 2),\n          params.y - (params.height / 2),\n          params.width,\n          params.height\n      );\n      // Check for jCanvas events\n      _detectEvents(canvas, ctx, params);\n      // Close path and configure masking\n      ctx.closePath();\n      _restoreTransform(ctx, params);\n      _enableMasking(ctx, data, params);\n    }\n    // On load function\n    function onload(canvas, ctx, data, params, layer) {\n      return function () {\n        var $canvas = $(canvas);\n        draw(canvas, ctx, data, params, layer);\n        if (params.layer) {\n          // Trigger 'load' event for layers\n          _triggerLayerEvent($canvas, data, layer, 'load');\n        } else if (params.load) {\n          // Run 'load' callback for non-layers\n          params.load.call($canvas[0], layer);\n        }\n        // Continue drawing successive layers after this image layer has loaded\n        if (params.layer) {\n          // Store list of previous masks for each layer\n          layer._masks = data.transforms.masks.slice(0);\n          if (params._next) {\n            // Draw successive layers\n            $canvas.drawLayers({\n              clear: false,\n              resetFire: true,\n              index: params._next\n            });\n          }\n        }\n      };\n    }\n    for (e = 0; e < $canvases.length; e += 1) {\n      canvas = $canvases[e];\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n        params = new jCanvasObject(args);\n        layer = _addLayer($canvases[e], params, args, drawImage);\n        if (params.visible) {\n\n          // Cache the given source\n          source = params.source;\n\n          imgCtx = source.getContext;\n          if (source.src || imgCtx) {\n            // Use image or canvas element if given\n            img = source;\n          } else if (source) {\n            if (imageCache[source] && imageCache[source].complete) {\n              // Get the image element from the cache if possible\n              img = imageCache[source];\n            } else {\n              // Otherwise, get the image from the given source URL\n              img = new Image();\n              // If source URL is not a data URL\n              if (!source.match(/^data:/i)) {\n                // Set crossOrigin for this image\n                img.crossOrigin = params.crossOrigin;\n              }\n              img.src = source;\n              // Save image in cache for improved performance\n              imageCache[source] = img;\n            }\n          }\n\n          if (img) {\n            if (img.complete || imgCtx) {\n              // Draw image if already loaded\n              onload(canvas, ctx, data, params, layer)();\n            } else {\n              // Otherwise, draw image when it loads\n              img.onload = onload(canvas, ctx, data, params, layer);\n              // Fix onload() bug in IE9\n              img.src = img.src;\n            }\n          }\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Creates a canvas pattern object\n  $.fn.createPattern = function createPattern(args) {\n    var $canvases = this, ctx,\n        params,\n        img, imgCtx,\n        pattern, source;\n\n    // Function to be called when pattern loads\n    function onload() {\n      // Create pattern\n      pattern = ctx.createPattern(img, params.repeat);\n      // Run callback function if defined\n      if (params.load) {\n        params.load.call($canvases[0], pattern);\n      }\n    }\n\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      params = new jCanvasObject(args);\n\n      // Cache the given source\n      source = params.source;\n\n      // Draw when image is loaded (if load() callback function is defined)\n\n      if (isFunction(source)) {\n        // Draw pattern using function if given\n\n        img = $('<canvas />')[0];\n        img.width = params.width;\n        img.height = params.height;\n        imgCtx = _getContext(img);\n        source.call(img, imgCtx);\n        onload();\n\n      } else {\n        // Otherwise, draw pattern using source image\n\n        imgCtx = source.getContext;\n        if (source.src || imgCtx) {\n          // Use image element if given\n          img = source;\n        } else {\n          // Use URL if given to get the image\n          img = new Image();\n          // If source URL is not a data URL\n          if (!source.match(/^data:/i)) {\n            // Set crossOrigin for this image\n            img.crossOrigin = params.crossOrigin;\n          }\n          img.src = source;\n        }\n\n        // Create pattern if already loaded\n        if (img.complete || imgCtx) {\n          onload();\n        } else {\n          img.onload = onload;\n          // Fix onload() bug in IE9\n          img.src = img.src;\n        }\n\n      }\n\n    } else {\n\n      pattern = null;\n\n    }\n    return pattern;\n  };\n\n// Creates a canvas gradient object\n  $.fn.createGradient = function createGradient(args) {\n    var $canvases = this, ctx,\n        params,\n        gradient,\n        stops = [], nstops,\n        start, end,\n        i, a, n, p;\n\n    params = new jCanvasObject(args);\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      // Gradient coordinates must be defined\n      params.x1 = params.x1 || 0;\n      params.y1 = params.y1 || 0;\n      params.x2 = params.x2 || 0;\n      params.y2 = params.y2 || 0;\n\n      if (params.r1 !== null && params.r2 !== null) {\n        // Create radial gradient if chosen\n        gradient = ctx.createRadialGradient(params.x1, params.y1, params.r1, params.x2, params.y2, params.r2);\n      } else {\n        // Otherwise, create a linear gradient by default\n        gradient = ctx.createLinearGradient(params.x1, params.y1, params.x2, params.y2);\n      }\n\n      // Count number of color stops\n      for (i = 1; params['c' + i] !== undefined; i += 1) {\n        if (params['s' + i] !== undefined) {\n          stops.push(params['s' + i]);\n        } else {\n          stops.push(null);\n        }\n      }\n      nstops = stops.length;\n\n      // Define start stop if not already defined\n      if (stops[0] === null) {\n        stops[0] = 0;\n      }\n      // Define end stop if not already defined\n      if (stops[nstops - 1] === null) {\n        stops[nstops - 1] = 1;\n      }\n\n      // Loop through color stops to fill in the blanks\n      for (i = 0; i < nstops; i += 1) {\n        // A progression, in this context, is defined as all of the color stops between and including two known color stops\n\n        if (stops[i] !== null) {\n          // Start a new progression if stop is a number\n\n          // Number of stops in current progression\n          n = 1;\n          // Current iteration in current progression\n          p = 0;\n          start = stops[i];\n\n          // Look ahead to find end stop\n          for (a = (i + 1); a < nstops; a += 1) {\n            if (stops[a] !== null) {\n              // If this future stop is a number, make it the end stop for this progression\n              end = stops[a];\n              break;\n            } else {\n              // Otherwise, keep looking ahead\n              n += 1;\n            }\n          }\n\n          // Ensure start stop is not greater than end stop\n          if (start > end) {\n            stops[a] = stops[i];\n          }\n\n        } else if (stops[i] === null) {\n          // Calculate stop if not initially given\n          p += 1;\n          stops[i] = start + (p * ((end - start) / n));\n        }\n        // Add color stop to gradient object\n        gradient.addColorStop(stops[i], params['c' + (i + 1)]);\n      }\n\n    } else {\n      gradient = null;\n    }\n    return gradient;\n  };\n\n// Manipulates pixels on the canvas\n  $.fn.setPixels = function setPixels(args) {\n    var $canvases = this,\n        canvas, e, ctx, canvasData,\n        params,\n        px,\n        imgData, pixelData, i, len;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      canvas = $canvases[e];\n      ctx = _getContext(canvas);\n      canvasData = _getCanvasData($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer(canvas, params, args, setPixels);\n        _transformShape($canvases[e], ctx, params, params.width, params.height);\n\n        // Use entire canvas of x, y, width, or height is not defined\n        if (params.width === null || params.height === null) {\n          params.width = canvas.width;\n          params.height = canvas.height;\n          params.x = params.width / 2;\n          params.y = params.height / 2;\n        }\n\n        if (params.width !== 0 && params.height !== 0) {\n          // Only set pixels if width and height are not zero\n\n          imgData = ctx.getImageData(\n              (params.x - (params.width / 2)) * canvasData.pixelRatio,\n              (params.y - (params.height / 2)) * canvasData.pixelRatio,\n              params.width * canvasData.pixelRatio,\n              params.height * canvasData.pixelRatio\n          );\n          pixelData = imgData.data;\n          len = pixelData.length;\n\n          // Loop through pixels with the \"each\" callback function\n          if (params.each) {\n            for (i = 0; i < len; i += 4) {\n              px = {\n                r: pixelData[i],\n                g: pixelData[i + 1],\n                b: pixelData[i + 2],\n                a: pixelData[i + 3]\n              };\n              params.each.call(canvas, px, params);\n              pixelData[i] = px.r;\n              pixelData[i + 1] = px.g;\n              pixelData[i + 2] = px.b;\n              pixelData[i + 3] = px.a;\n            }\n          }\n          // Put pixels on canvas\n          ctx.putImageData(\n              imgData,\n              (params.x - (params.width / 2)) * canvasData.pixelRatio,\n              (params.y - (params.height / 2)) * canvasData.pixelRatio\n          );\n          // Restore transformation\n          ctx.restore();\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves canvas image as data URL\n  $.fn.getCanvasImage = function getCanvasImage(type, quality) {\n    var $canvases = this, canvas,\n        dataURL = null;\n    if ($canvases.length !== 0) {\n      canvas = $canvases[0];\n      if (canvas.toDataURL) {\n        // JPEG quality defaults to 1\n        if (quality === undefined) {\n          quality = 1;\n        }\n        dataURL = canvas.toDataURL('image/' + type, quality);\n      }\n    }\n    return dataURL;\n  };\n\n// Scales canvas based on the device's pixel ratio\n  $.fn.detectPixelRatio = function detectPixelRatio(callback) {\n    var $canvases = this,\n        canvas, e, ctx,\n        devicePixelRatio, backingStoreRatio, ratio,\n        oldWidth, oldHeight,\n        data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      // Get canvas and its associated data\n      canvas = $canvases[e];\n      ctx = _getContext(canvas);\n      data = _getCanvasData($canvases[e]);\n\n      // If canvas has not already been scaled with this method\n      if (!data.scaled) {\n\n        // Determine device pixel ratios\n        devicePixelRatio = window.devicePixelRatio || 1;\n        backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n            ctx.mozBackingStorePixelRatio ||\n            ctx.msBackingStorePixelRatio ||\n            ctx.oBackingStorePixelRatio ||\n            ctx.backingStorePixelRatio || 1;\n\n        // Calculate general ratio based on the two given ratios\n        ratio = devicePixelRatio / backingStoreRatio;\n\n        if (ratio !== 1) {\n          // Scale canvas relative to ratio\n\n          // Get the current canvas dimensions for future use\n          oldWidth = canvas.width;\n          oldHeight = canvas.height;\n\n          // Resize canvas relative to the determined ratio\n          canvas.width = oldWidth * ratio;\n          canvas.height = oldHeight * ratio;\n\n          // Scale canvas back to original dimensions via CSS\n          canvas.style.width = oldWidth + 'px';\n          canvas.style.height = oldHeight + 'px';\n\n          // Scale context to counter the manual scaling of canvas\n          ctx.scale(ratio, ratio);\n\n        }\n\n        // Set pixel ratio on canvas data object\n        data.pixelRatio = ratio;\n        // Ensure that this method can only be called once for any given canvas\n        data.scaled = true;\n\n        // Call the given callback function with the ratio as its only argument\n        if (callback) {\n          callback.call(canvas, ratio);\n        }\n\n      }\n\n    }\n    return $canvases;\n  };\n\n// Clears the jCanvas cache\n  jCanvas.clearCache = function clearCache() {\n    var cacheName;\n    for (cacheName in caches) {\n      if (Object.prototype.hasOwnProperty.call(caches, cacheName)) {\n        caches[cacheName] = {};\n      }\n    }\n  };\n\n// Enable canvas feature detection with $.support\n  $.support.canvas = ($('<canvas />')[0].getContext !== undefined);\n\n// Export jCanvas functions\n  extendObject(jCanvas, {\n    defaults: defaults,\n    setGlobalProps: _setGlobalProps,\n    transformShape: _transformShape,\n    detectEvents: _detectEvents,\n    closePath: _closePath,\n    setCanvasFont: _setCanvasFont,\n    measureText: _measureText\n  });\n  $.jCanvas = jCanvas;\n  $.jCanvasObject = jCanvasObject;\n\n}));"]}