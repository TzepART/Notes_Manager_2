{"version":3,"sources":["script.js","sectors.js","notes.js","main.js","jcanvas.js"],"names":["cartesian2Polar","x","y","upX","CenterX","upY","CenterY","distance","Math","sqrt","radians","atan2","degr","PI","polarCoor","cartesian2Dec","radius","tan","pow","decCoor","X","Y","cartesian2DecForBorder","newDegr","hexInArray","h","m","slice","match","parseInt","hexArrayInRgbString","rgb","changeColorLayers","color","numLayers","arColor","tempColor","arRBA","i","difColorRed","difColorGreen","difColorBlue","red","green","blue","floor","console","log","createSectorNew","sector_id","beginAngle","endAngle","circle_id","arColors","difRadius","bigRadius","nameArc","nameSector","nameGroup","canvas","$","drawSlice","layer","mask","groups","fillStyle","start","end","strokeStyle","strokeWidth","restoreCanvas","name","dblclick","polar","eventX","eventY","link","attr","removeClass","addClass","text","click","drawArc","shadowBlur","shadowColor","mouseout","setLayer","drawLayer","createBorderSector","data","endCoord","drawVector","a1","l1","borderForSector","angle","sectorLeftId","sectorRightId","angleMin","angelMax","LabelCoord","leftCoord","rightCoord","draggable","radiusLabel","circlePath","circleRadius","circleCenterX","circleCenterY","xMin","yMin","xMax","yMax","sectorLeft","sectorRight","shadowLabelSize","dragstop","pol","getLayer","circleId","beginAngleL","colorL","endAngleR","colorR","newLeftSectorMinAngle","newRightSectorMinAngle","oldLeftSectorMinAngle","oldRightSectorMinAngle","coefficientLeft","coefficientRight","updateLabelPositionByChangingSector","removeLayerGroup","setHightMoveLayerToLayer","drag","mouseover","rayAndCircleByLabel","id","dec","colorRayAndCircleByLabel","drawLine","x1","y1","x2","y2","createNamePopUpLabel","heightPopUp","widthPopUp","drawRect","width","height","cornerRadius","drawText","fontSize","fontFamily","maxWidth","createLabel","colorLabel","label_radius","label_angle","label_id","updateCoordinateLabel","delRayNamePopUpAndCircleByLabel","Label","colorSelectLabel","delRayNamePopUpAndCircleAllLabels","setLinkLabelsByRadiusAndAngle","removeLinkLabelsByRadiusAndAngle","css","setMoveLayerToLayer","index","array","moveLayer","dragLayers","getLayers","forEach","setFillStyleToLayer","angleBorderMin","angleBorderMax","radiusBorderMin","radiusBorderMax","labels","getLayerGroup","deleteFillStyleToLayer","delNamePopUpByLabel","border","updateLabelPosition","label","sector_left","newAngle","sector_right","labelId","post","done","removeLayer","addTagForm","$collectionHolder","$newLinkLi","prototype","newForm","replace","$newFormLi","append","before","e","preventDefault","this","parent","remove","addTagFormDeleteLink","$tagFormLi","$removeFormA","on","getNoteContent","noteId","host","window","location","hostname","port","ajax","url","isLocalDev","type","success","document","getElementById","innerHTML","title","href","error","err","isLocalhost","Boolean","navigator","protocol","serviceWorker","register","then","registration","onupdatefound","controller","installingWorker","installing","onstatechange","state","Error","jQuery","global","factory","module","exports","w","jCanvasObject","args","propName","params","Object","hasOwnProperty","call","jCanvasDefaults","extendObject","baseDefaults","isString","operand","typeOf","isNumeric","isNaN","Number","parseFloat","_getContext","getContext","_coerceNumericProps","props","propType","propValue","undefined","String","_cloneTransforms","transforms","masks","_saveCanvas","ctx","save","savedTransforms","push","_restoreCanvas","length","baseTransforms","restore","pop","_setStyle","styleName","isFunction","_setGlobalProps","lineWidth","rounded","lineCap","lineJoin","strokeCap","strokeJoin","miterLimit","strokeDash","setLineDash","webkitLineDash","lineDashOffset","webkitLineDashOffset","mozDashOffset","strokeDashOffset","shadowOffsetX","shadowX","shadowOffsetY","shadowY","globalAlpha","opacity","globalCompositeOperation","compositing","imageSmoothing","imageSmoothingEnabled","_enableMasking","autosave","clip","_args","_restoreTransform","_transformed","_closePath","closed","closePath","shadowStroke","stroke","fill","_getCanvasData","_transformShape","_toRad","inDegrees","fromCenter","_centered","rotate","_rotateCanvas","scale","scaleX","scaleY","_scaleCanvas","translate","translateX","translateY","_translateCanvas","dataCache","caches","_canvas","_data","layers","names","eventHooks","intersecting","lastIntersected","cursor","dragging","event","events","animating","animated","pixelRatio","scaled","redrawOnMousemove","_addLayerEvents","$canvas","eventName","jCanvas","cursors","_addExplicitLayerEvent","bind","l","_triggerLayerEvent","_hovered","triggerLayerEvent","drawLayers","_addLayerEvent","_event","_enableDrag","dragHelperEvents","_updateLayerName","nameMap","_updateLayerGroups","group","groupName","g","groupMap","splice","_getIntersectingLayer","_masks","intersects","intangible","_drawLayer","nextLayerIndex","visible","_method","_next","_handleLayerDrag","eventType","dragGroups","newX","newY","bringToFront","_startX","_startY","_endX","_eventX","_endY","_eventY","updateDragX","updateDragY","dx","dy","restrictDragToAxis","centerX","centerY","r","k","tempX","tempY","px","py","qx","qy","rx","ry","Result","absSumMin","abs","absSumMax","originalRedrawOnMousemove","_setCursor","inArray","prefix","_resetCursor","_runEventCallback","callbacks","arg","_running","_layerCanFireEvent","disableEvents","tangibleEvents","_addLayer","method","_layer","fn","maps","drawings","measureText","_showProps","obj","cssProp","p","_hideProps","reset","propsObj","_parseEndValues","endValues","subPropName","subPropValue","isPlainObject","_removeSubPropAliases","indexOf","_colorToRgbArray","originalColor","elem","multiple","head","style","_animateColor","fx","n","now","pos","round","join","nodeName","prop","_supportColorProps","step","_getTouchEventName","touchEvents","_getMouseEventName","mouseEvents","_createEvent","eventCallback","eventCache","offsetX","offsetY","helperEventName","resetFire","touchEventName","_createEvents","eventNames","_detectEvents","isPointInPath","isPointInStroke","cos","sin","_getCoterminal","_getArcX","_getArcY","_drawArc","path","x3","y3","x4","y4","diff","ccw","_addStartArrow","arc","_addEndArrow","_addArrow","leftX","leftY","rightX","rightY","arrowRadius","arrowAngle","moveTo","lineTo","_arrowAngleConverted","startArrow","endArrow","_drawLine","lx","ly","_drawQuadratic","lcx","lcy","cx1","cy1","quadraticCurveTo","_drawBezier","lc","lcx1","lcy1","lcx2","lcy2","bezierCurveTo","_getVectorX","_getVectorY","_drawVector","_setCanvasFont","font","fontStyle","_measureText","lines","originalSize","curWidth","propCache","lineHeight","_wrapText","line","words","allText","manualLines","split","allLines","concat","defaults","Image","Array","getComputedStyle","extend","toString","toLowerCase","arraySlice","jQueryEventFix","fix","imageCache","future","align","baseline","concavity","count","cropFromCenter","crossOrigin","letterSpacing","r1","r2","repeat","respectAlign","sHeight","sides","source","spread","sWidth","sx","sy","plugin","self","$canvases","getEventHooks","setEventHooks","callback","matching","layerId","idType","groupId","getLayerIndex","substr","isEmptyObject","setLayers","setLayerGroup","removeLayers","addLayerToGroup","removeLayerFromGroup","styles","documentElement","pre","OLink","lastLayer","lastIndex","isImageLayer","clear","clearCanvas","_fired","drawImage","addLayer","animateLayer","complete","_animating","parts","hidden","_pos","arguments","duration","easing","draw","animate","animateLayerGroup","apply","delayLayer","delay","delayLayerGroup","stopLayer","clearQueue","stop","stopLayerGroup","mousedown","mouseup","mousemove","touchstart","touchend","touchmove","offset","originalEvent","touches","changedTouches","pageX","currentTarget","left","pageY","top","bezier","ellipse","function","image","polygon","quadratic","rectangle","vector","setTransform","clearRect","saveCanvas","rotateCanvas","scaleCanvas","translateCanvas","temp","beginPath","rect","drawEllipse","controlW","controlH","drawPolygon","theta","dtheta","hdtheta","apothem","drawQuadratic","drawBezier","drawPath","lp","nchars","chars","ch","c","constantCloseness","textBaseline","textAlign","flipArcText","reverse","fillText","strokeText","img","onload","load","imgCtx","src","createPattern","pattern","createGradient","gradient","nstops","a","stops","createRadialGradient","createLinearGradient","addColorStop","setPixels","canvasData","imgData","pixelData","len","getImageData","each","b","putImageData","getCanvasImage","quality","dataURL","toDataURL","detectPixelRatio","devicePixelRatio","backingStoreRatio","ratio","oldWidth","oldHeight","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","clearCache","cacheName","support","setGlobalProps","transformShape","detectEvents","setCanvasFont","$addTagLink","ready","html","find"],"mappings":";;;;;;;;;;;;;;;;;;AAqBA,QAAAA,iBAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAAG,QACAC,EAAAH,EAAAI,OAKA,OAJAC,UAAAC,KAAAC,KAAAN,EAAAA,EAAAE,EAAAA,GACAK,QAAAF,KAAAG,MAAAN,EAAAF,GACAS,KAAA,IAAAF,QAAAF,KAAAK,GAAA,GACAC,WAAAP,SAAAA,SAAAK,KAAAA,MACAE,UAUA,QAAAC,eAAAC,EAAAJ,GAYA,MAXAF,UAAAE,EAAA,KAAAJ,KAAAK,GAAA,KACAD,GAAA,GAAAA,GAAA,KACAK,IAAAT,KAAAS,IAAAP,SACAT,EAAAO,KAAAC,KAAAD,KAAAU,IAAAF,EAAA,IAAAR,KAAAU,IAAAD,IAAA,GAAA,IACAf,EAAAD,EAAAgB,MAEAA,IAAAT,KAAAS,KAAAP,SACAT,GAAAO,KAAAC,KAAAD,KAAAU,IAAAF,EAAA,IAAAR,KAAAU,IAAAD,IAAA,GAAA,IACAf,GAAAD,EAAAgB,KAEAE,SAAAC,EAAAnB,EAAAG,QAAAiB,EAAAnB,EAAAI,SACAa,QAUA,QAAAG,wBAAAN,EAAAJ,GACA,GAAAW,GAAAX,EAAA,EAeA,OAdAF,SAAAa,GAAAf,KAAAK,GAAA,KAEAU,GAAA,GAAAA,GAAA,KACAN,IAAAT,KAAAS,IAAAP,SACAT,EAAAO,KAAAC,KAAAO,EAAAA,GAAAC,IAAAA,IAAA,IACAf,EAAAD,EAAAgB,MAEAA,IAAAT,KAAAS,KAAAP,SACAT,EAAAO,KAAAC,KAAAO,EAAAA,GAAAC,IAAAA,IAAA,IACAf,EAAAD,EAAAgB,KAGAE,SAAAC,EAAAnB,EAAAoB,EAAAnB,GAEAiB,QAOA,QAAAK,YAAAC,GACA,GAAAC,GAAAD,EAAAE,MAAA,GAAAC,MAAA,QAIA,OAHAF,GAAA,GAAAG,SAAAH,EAAA,GAAA,IACAA,EAAA,GAAAG,SAAAH,EAAA,GAAA,IACAA,EAAA,GAAAG,SAAAH,EAAA,GAAA,IACAA,EAGA,QAAAI,qBAAAJ,GACA,GAAAK,GAAA,OAAAL,EAAA,GAAA,KAAAA,EAAA,GAAA,KAAAA,EAAA,GAAA,GACA,OAAAK,GAGA,QAAAC,mBAAAC,EAAAC,GACA,GAAAC,GAAAX,WAAAS,GACAG,EAAAD,EACAE,KACAC,EAAA,EACAC,GAAA,IAAAJ,EAAA,IAAAD,EACAM,EAAAL,EAAA,IAAAD,EAAA,GACAO,EAAAN,EAAA,IAAAD,EAAA,GACAQ,EAAAP,EAAA,GAAAI,EACAI,EAAAR,EAAA,GACAS,EAAAT,EAAA,EACA,KAAAO,EAAAA,GAAA,OAAAA,GAAAH,EACAH,EAAA,GAAA5B,KAAAqC,MAAAH,GACAN,EAAA,GAAA5B,KAAAqC,MAAAF,GACAP,EAAA,GAAA5B,KAAAqC,MAAAD,GACAP,EAAAC,GAAAR,oBAAAM,GACAO,GAAAH,EACAI,GAAAH,EACAH,GAGA,OADAQ,SAAAC,IAAAV,GACAA,EAOA,QAAAW,iBAAAC,EAAAC,EAAAC,EAAAC,EAAAlB,EAAAD,GACA,GAAAK,GAEAW,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAlB,EAAAA,EACAD,EAAAA,EAEAoB,EAAArB,kBAAAC,EAAAC,GACAoB,EAAAC,UAAArB,EACAlB,EAAAuC,UAEAC,EAAA,WAAAP,EACAQ,EAAA,eAAAR,EACAS,EAAA,UAAAT,EACAU,EAAAC,EAAA,SAEA,KAAAtB,EAAA,EAAAA,GAAAJ,EAAAI,IACAqB,EAAAE,WACAC,OAAA,EACAC,MAAA,EACAC,QAAAN,GACAO,UAAAZ,EAAAf,EAAA,GACArC,EAAAG,QAAAF,EAAAI,QACA4D,MAAAhB,EACAiB,IAAAhB,EACAnC,OAAAA,EACAoD,YAAA,OACAC,YAAA,IACAC,eACAR,OAAA,IAGA9C,GAAAsC,CAGAK,GAAAE,WACAC,OAAA,EACAC,MAAA,EACA9D,EAAAG,QAAAF,EAAAI,QACA4D,MAAAhB,EACAiB,IAAAhB,EACAoB,KAAAd,EACAO,QAAAN,GACAN,UAAAA,EACAH,UAAAA,EACAjC,OAAAuC,UACArB,UAAAA,EACAD,MAAAA,EACAuC,SAAA,SAAAV,GACA,GAAAW,GAAAzE,gBAAA8D,EAAAY,OAAAZ,EAAAa,QACAC,EAAAhB,EAAA,sBAAAiB,KAAA,OAAA,0BAAAf,EAAAV,UAAA,WAAAqB,EAAAlE,SAAAgD,UAAA,SAAAkB,EAAA7D,KACAgE,GAAAE,YAAA,eAAAC,SAAA,cACAH,EAAAI,KAAA,uCAEAC,MAAA,SAAAnB,GACAF,EAAA,UAAAsB,SACAC,WAAA,GACAC,YAAA,QACAhB,YAAA,QACAG,KAAAf,EACAQ,QAAAN,GACAW,YAAA,EACApE,EAAAG,QAAAF,EAAAI,QACAU,OAAAuC,UACAW,MAAAhB,EACAiB,IAAAhB,IACAmB,eACAR,OAAA,KAGAuB,SAAA,SAAAvB,GACAF,EAAA,UAAA0B,SAAA9B,GACA2B,WAAA,IACAI,eAIA5B,EAAAW,eACAR,OAAA,IAIA,QAAA0B,oBAAAC,GACA,GAAAC,GAAApE,uBAAAiC,UAAAkC,EAAAvC,WACAU,GAAA,UAAA+B,YACAvB,YAAA,QACAC,YAAA,EACApE,EAAAG,QAAAF,EAAAI,QACAsF,GAAAF,EAAAtE,EAAAyE,GAAAH,EAAArE,IAIA,QAAAyE,iBAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAArF,cAAAwC,UAAAwC,GACAM,EAAAtF,cAAAwC,UAAA2C,EAAA,GACAI,EAAAvF,cAAAwC,UAAA4C,EAAA,EACAvC,GAAA,UAAAsB,SACApB,OAAA,EACAyC,WAAA,EACAP,aAAAA,EACAC,cAAAA,EACA1B,KAAA,UAAAyB,EAAA,IAAAC,EACAhC,UAAA,SACAhE,EAAAmG,EAAAhF,EAAAlB,EAAAkG,EAAA/E,EACAL,OAAAwF,YACAC,YAAA,EACAC,aAAAnD,UACAoD,cAAAvG,QACAwG,cAAAtG,QACAuG,KAAAR,EAAAjF,EAAA0F,KAAAT,EAAAhF,EACA0F,KAAAT,EAAAlF,EAAA4F,KAAAV,EAAAjF,EACAoE,MAAAwB,WAAAjB,EAAAkB,YAAAjB,GACAb,YAAAA,YACAD,WAAAgC,gBACAC,SAAA,SAAAtD,GACA,GAAAuD,GAAArH,gBAAA8D,EAAA7D,EAAA6D,EAAA5D,GACA+G,EAAArD,EAAA,UAAA0D,SAAA,eAAAxD,EAAAkC,cACAkB,EAAAtD,EAAA,UAAA0D,SAAA,eAAAxD,EAAAmC,eAEAsB,EAAAN,EAAA7D,UACAlB,EAAA+E,EAAA/E,UAEAsF,EAAAP,EAAA/C,MACAuD,EAAAR,EAAAhF,MAEAyF,EAAAR,EAAA/C,IACAwD,EAAAT,EAAAjF,MAEA2F,EAAAX,EAAA/C,MACA2D,EAAAR,EAAAzG,KACAkH,EAAAb,EAAA/C,MACA6D,EAAAb,EAAAhD,MACA8D,GAAAX,EAAAzG,KAAA4G,IAAAP,EAAA9C,IAAA8C,EAAA/C,OACA+D,GAAAP,EAAAL,EAAAzG,OAAAsG,EAAA/C,IAAA+C,EAAAhD,MAEAgE,qCAAApE,EAAAkE,EAAAC,EAAAL,EAAAC,EAAAC,EAAAC,GAEAnE,EAAA,UAAAuE,iBAAA,UAAAnC,GACAhD,gBAAAgD,EAAAwB,EAAAH,EAAAzG,KAAA2G,EAAArF,EAAAuF,GAEA7D,EAAA,UAAAuE,iBAAA,UAAAlC,GACAjD,gBAAAiD,EAAAoB,EAAAzG,KAAA8G,EAAAH,EAAArF,EAAAyF,GAEAS,4BAEAC,KAAA,SAAAvE,GACA,GAAAuD,GAAArH,gBAAA8D,EAAA7D,EAAA6D,EAAA5D,EAEA0D,GAAA,UAAA+B,YACAvB,YAAA,QACAC,YAAA,EACApE,EAAAG,QAAAF,EAAAI,QACAsF,GAAAyB,EAAAzG,KAAAiF,GAAAwB,EAAA9G,YAGA+H,UAAA,SAAAxE,GACAF,EAAA,UAAA+B,YACAvB,YAAA,QACAC,YAAA,EACApE,EAAAG,QAAAF,EAAAI,QACAsF,GAAAG,EAAAF,GAAAtC,aAGA8B,SAAA,SAAAvB,KAKAU,SAAA,SAAAV,OAUA,QAAAyE,qBAAAzE,EAAA0E,GACA,GAAAnB,GAAArH,gBAAA8D,EAAA7D,EAAA6D,EAAA5D,GACAuI,EAAA1H,cAAAwC,IAAA8D,EAAAzG,KACAgD,GAAA,UAAAsB,SACApB,OAAA,EACAM,YAAAsE,yBACArE,YAAA,EACAE,KAAA,gBAAAiE,EACAxE,QAAA,iBACA/D,EAAAG,QAAAF,EAAAI,QACAU,OAAAqG,EAAA9G,WAEAqD,EAAA,UAAA+E,UACA7E,OAAA,EACAO,YAAA,EACAE,KAAA,cAAAiE,EACAxE,QAAA,eACAI,YAAAsE,yBACAE,GAAAxI,QAAAyI,GAAAvI,QACAwI,GAAAL,EAAArH,EAAA2H,GAAAN,EAAApH,IAIA,QAAA2H,sBAAAR,EAAAvI,EAAAC,EAAA8E,GACA,GAAAiE,GAAA,GACAC,EAAA,GAEAtF,GAAA,UAAAuF,UACArF,OAAA,EACAG,UAAA,QACAG,YAAA,OACAC,YAAA,EACAE,KAAA,iBAAAiE,EACAxE,QAAA,kBACA/D,EAAAA,EAAAiJ,EAAA,EAAAhJ,EAAAA,EAAA+I,EAAA,EAAA,GACAG,MAAAF,EACAG,OAAAJ,EACAK,aAAA,KAEA1F,EAAA,UAAA2F,UACAzF,OAAA,EACAS,KAAA,qBAAAiE,EACAxE,QAAA,sBACAC,UAAA,QACAI,YAAA,EACApE,EAAAA,EAAAiJ,EAAA,EAAAhJ,EAAAA,EAAA+I,EAAA,EAAA,GACAO,SAAA,OACAC,WAAA,sBACAC,SAAAR,EACAlE,KAAAA,IAKA,QAAA2E,aAAAlE,GACA,GAAAW,GAAArF,cAAA0E,EAAAzE,OAAAuC,UAAAkC,EAAA7E,KAEAgD,GAAA,UAAAsB,SACApB,OAAA,EACAyC,WAAA,EACAvC,QAAA,eACAO,KAAA,UAAAkB,EAAA+C,GACAvE,UAAA2F,WACA3J,EAAAmG,EAAAhF,EAAAlB,EAAAkG,EAAA/E,EACAL,OAAAwF,YACAf,MAAA+C,GAAA/C,EAAA+C,GAAAjE,KAAAkB,EAAAlB,KAAAgD,SAAA9B,EAAA8B,UACAsC,aAAApE,EAAAzE,OACA8I,YAAArE,EAAA7E,KACAmJ,SAAAtE,EAAA+C,GACApD,YAAAA,YACAD,WAAAgC,gBACAC,SAAA,SAAAtD,GACA,GAAAuD,GAAArH,gBAAA8D,EAAA7D,EAAA6D,EAAA5D,EACAa,eAAAsG,EAAA9G,SAAA8G,EAAAzG,KAEAkD,GAAA+F,aAAAxC,EAAA9G,SAAAgD,UACAO,EAAAgG,YAAAzC,EAAAzG,KAGAoJ,sBAAAlG,EAAA2B,KAAA8B,SAAAzD,EAAA2B,KAAA+C,GAAAnB,EAAA9G,SAAAgD,UAAA8D,EAAAzG,MACAqJ,gCAAAnG,EAAA2B,KAAA+C,KAEAH,KAAA,SAAAvE,GACAmG,gCAAAnG,EAAA2B,KAAA+C,IACAD,oBAAAzE,EAAAA,EAAA2B,KAAA+C,KAEAF,UAAA,SAAAxE,GACA,GAAAoG,GAAAtG,EAAA,UAAA0D,SAAAxD,EAAAS,KACA2F,GAAAjG,UAAAkG,iBACAC,oCACA7B,oBAAAzE,EAAAA,EAAA2B,KAAA+C,IACA6B,8BAAAvG,EAAA+F,aAAA/F,EAAAgG,YAAAhG,EAAAiG,UACAf,qBAAAlF,EAAA2B,KAAA+C,GAAA1E,EAAA7D,EAAA6D,EAAA5D,EAAA4D,EAAA2B,KAAAlB,OAEAc,SAAA,SAAAvB,GACA,GAAAoG,GAAAtG,EAAA,UAAA0D,SAAAxD,EAAAS,KACA2F,GAAAjG,UAAA2F,WACAK,gCAAAnG,EAAA2B,KAAA+C,IACA8B,iCAAAxG,EAAA+F,aAAA/F,EAAAgG,YAAAhG,EAAAiG,WAEAvF,SAAA,SAAAV,GACAF,EAAA,mBAAA2G,IAAA,UAAA,SAAA1F,KAAA,OAAA,2BAAAf,EAAA2B,KAAA8B,SAAA,IAAAzD,EAAA2B,KAAA+C,GAAA,QAKA,QAAAJ,4BAMA,QAAAoC,GAAA1G,EAAA2G,EAAAC,GACA9G,EAAA,UAAA+G,UAAA7G,EAAAS,KAAA,KALA,GAAAqG,GAAAhH,EAAA,UAAAiH,UAAA,SAAA/G,GACA,MAAAA,GAAAyC,aAAA,GAMAqE,GAAAE,QAAAN,GAGA,QAAAH,+BAAArJ,EAAA+E,EAAAgE,GAQA,QAAAgB,GAAAjH,EAAA2G,EAAAC,GACA5G,EAAA0E,KAAAuB,IACAjG,EAAAgG,YAAAkB,GAAAlH,EAAAgG,YAAAmB,GACAnH,EAAA+F,aAAAqB,GAAApH,EAAA+F,aAAAsB,KAEAnC,qBAAAlF,EAAAiG,SAAAjG,EAAA7D,EAAA6D,EAAA5D,EAAA4D,EAAA2B,KAAAlB,MACAT,EAAAG,UAAAkG,kBAbA,GAAAiB,GAAAxH,EAAA,UAAAyH,cAAA,eACAH,EAAAlK,EAAA,IACAmK,EAAAnK,EAAA,IACAgK,EAAAjF,EAAA,GACAkF,EAAAlF,EAAA,EAaAqF,GAAAN,QAAAC,GAGA,QAAAT,kCAAAtJ,EAAA+E,EAAAgE,GAQA,QAAAuB,GAAAxH,EAAA2G,EAAAC,GACA5G,EAAAiG,WAAAA,IACAjG,EAAAgG,YAAAkB,GAAAlH,EAAAgG,YAAAmB,GACAnH,EAAA+F,aAAAqB,GAAApH,EAAA+F,aAAAsB,KAEArH,EAAAG,UAAA2F,WACA2B,oBAAAzH,EAAAiG,WAbA,GAAAqB,GAAAxH,EAAA,UAAAyH,cAAA,eACAH,EAAAlK,EAAA,IACAmK,EAAAnK,EAAA,IACAgK,EAAAjF,EAAA,GACAkF,EAAAlF,EAAA,EAaAqF,GAAAN,QAAAQ,GAGA,QAAApD,qCAAAsD,EAAAxD,EAAAC,EAAAL,EAAAC,EAAAC,EAAAC,GAMA,QAAA0D,GAAAC,EAAAjB,EAAAC,GAEA,GAAAgB,EAAA5B,YAAA6B,EAAAzH,OAAAwH,EAAA5B,YAAA6B,EAAAxH,IAAA,CACA,GAAAyH,IAAAF,EAAA5B,YAAAhC,GAAAE,EAAAJ,EACAxB,EAAArF,cAAA2K,EAAA7B,aAAAtG,UAAAqI,EACAF,GAAAzL,EAAAmG,EAAAhF,EACAsK,EAAAxL,EAAAkG,EAAA/E,EACAyB,QAAAC,IAAA2I,EAAAnH,KAAAmH,EAAA5B,YAAA8B,EAAAD,EAAA/D,EAAAC,EAAAC,EAAAC,EAAAC,GACA0D,EAAA5B,YAAA8B,MACA,IAAAF,EAAA5B,YAAA+B,EAAA3H,OAAAwH,EAAA5B,YAAA+B,EAAA1H,IAAA,CACA,GAAAyH,IAAAF,EAAA5B,YAAA/B,GAAAE,EAAAJ,EACAzB,EAAArF,cAAA2K,EAAA7B,aAAAtG,UAAAqI,EACAF,GAAAzL,EAAAmG,EAAAhF,EACAsK,EAAAxL,EAAAkG,EAAA/E,EACAqK,EAAA5B,YAAA8B,GAnBA,GAAAD,GAAA/H,EAAA,UAAA0D,SAAA,eAAAkE,EAAAxF,cACA6F,EAAAjI,EAAA,UAAA0D,SAAA,eAAAkE,EAAAvF,eACAmF,EAAAxH,EAAA,UAAAyH,cAAA,cAEA,oBAAAD,IAkBAA,EAAAN,QAAAW,GAOA,QAAAzB,uBAAAzC,EAAAuE,EAAA9K,EAAA+E,GACAnC,EAAAmI,KACA,qCAEAxE,SAAAA,EACAuE,QAAAA,EACA9K,OAAAA,EACA+E,MAAAA,IACAiG,KACA,SAAAvG,GACA3C,QAAAC,IAAA0C,KAKA,QAAAwE,iCAAAzB,GACA5E,EAAA,UAAAqI,YAAA,gBAAAzD,GACA5E,EAAA,UAAAqI,YAAA,cAAAzD,GACA5E,EAAA,UAAAqI,YAAA,iBAAAzD,GACA5E,EAAA,UAAAqI,YAAA,qBAAAzD,GAGA,QAAA+C,qBAAA/C,GACA5E,EAAA,UAAAqI,YAAA,iBAAAzD,GACA5E,EAAA,UAAAqI,YAAA,qBAAAzD,GAGA,QAAA4B,qCACAxG,EAAA,UAAAuE,iBAAA,iBACAvE,EAAA,UAAAuE,iBAAA,eACAvE,EAAA,UAAAuE,iBAAA,kBACAvE,EAAA,UAAAuE,iBAAA,sBCxeA,QAAA+D,YAAAC,EAAAC,GAEA,GAAAC,GAAAF,EAAA1G,KAAA,aAGAgF,EAAA0B,EAAA1G,KAAA,SAIA6G,EAAAD,EAAAE,QAAA,YAAA9B,EAGA0B,GAAA1G,KAAA,QAAAgF,EAAA,EAGA,IAAA+B,GAAA5I,EAAA0I,EAGAE,GAAAC,OAAA,yFAEAL,EAAAM,OAAAF,GAGA5I,EAAA,eAAAqB,MAAA,SAAA0H,GAKA,MAJAA,GAAAC,iBAEAhJ,EAAAiJ,MAAAC,SAAAC,UAEA,IAOA,QAAAC,sBAAAC,GACA,GAAAC,GAAAtJ,EAAA,kCACAqJ,GAAAR,OAAAS,GAEAA,EAAAC,GAAA,QAAA,SAAAR,GAEAA,EAAAC,iBAGAK,EAAAF,WClFA,QAAAK,gBAAAC,GACA,GAAAC,GAAA,UAAAC,OAAAC,SAAAC,SAAA,IAAAF,OAAAC,SAAAE,IACA9J,GAAA+J,MACAC,IAAA,mBAAAC,YAAAP,EAAA,sBAAAA,EAAA,aAAAD,EAAA,IACAS,KAAA,MACAC,QAAA,SAAAtI,GACAuI,SAAAC,eAAA,mBAAAC,UAAAzI,EAAA0I,MACAH,SAAAC,eAAA,kBAAAC,UAAAzI,EAAAT,KACAgJ,SAAAC,eAAA,kBAAAG,KAAA,mBAAAP,YAAAP,EAAA,mBAAAA,EAAA,cAAA7H,EAAA+C,GAAA,KAEA6F,MAAA,SAAAC,QCSA,WACA,YAMA,IAAAC,GAAAC,QAAA,cAAAjB,OAAAC,SAAAC,UAEA,UAAAF,OAAAC,SAAAC,UAEAF,OAAAC,SAAAC,SAAA7L,MACA,0DAIA,kBAAA6M,aACA,WAAAlB,OAAAC,SAAAkB,UAAAH,IACAE,UAAAE,cAAAC,SAAA,qBACAC,KAAA,SAAAC,GAEAA,EAAAC,cAAA,WAKA,GAAAN,UAAAE,cAAAK,WAAA,CAGA,GAAAC,GAAAH,EAAAI,UAEAD,GAAAE,cAAA,WACA,OAAAF,EAAAG,OACA,IAAA,YAKA,KAEA,KAAA,YACA,KAAA,IAAAC,OAAA,yDAvBAZ,SAgCA,SAAA9B,GACA7J,QAAAuL,MAAA,4CAAA1B;;;;;ACjEA,SAAA2C,EAAAC,EAAAC,GACA,YAEA,iBAAAC,SAAA,gBAAAA,QAAAC,QACAD,OAAAC,QAAA,SAAAJ,EAAAK,GACA,MAAAH,GAAAF,EAAAK,IAGAH,EAAAF,EAAAC,IAIA,mBAAAhC,QAAAA,OAAA+B,UAAA,mBAAA/B,QAAAA,OAAAV,KAAA,SAAAjJ,EAAA2J,GACA,YAgEA,SAAAqC,GAAAC,GACA,GACAC,GADAC,EAAAlD,IAGA,KAAAiD,IAAAD,GAEAG,OAAA3D,UAAA4D,eAAAC,KAAAL,EAAAC,KACAC,EAAAD,GAAAD,EAAAC,GAGA,OAAAC,GAcA,QAAAI,KACAC,GAAAvD,KAAAsD,EAAAE,cA4FA,QAAAC,GAAAC,GACA,MAAA,WAAAC,GAAAD,GAIA,QAAAE,GAAAF,GACA,OAAAG,MAAAC,GAAAJ,MAAAG,MAAAE,GAAAL,IAIA,QAAAM,GAAAlN,GACA,MAAAA,IAAAA,EAAAmN,WAAAnN,EAAAmN,WAAA,MAAA,KAIA,QAAAC,GAAAC,GACA,GAAAlB,GAAAmB,EAAAC,CAEA,KAAApB,IAAAkB,GACAhB,OAAA3D,UAAA4D,eAAAC,KAAAc,EAAAlB,KACAoB,EAAAF,EAAAlB,GACAmB,EAAAT,GAAAU,GAEA,WAAAD,GAAAR,EAAAS,IAAA,SAAApB,IAEAkB,EAAAlB,GAAAc,GAAAM,IAKAC,UAAAH,EAAAhM,OACAgM,EAAAhM,KAAAoM,OAAAJ,EAAAhM,OAKA,QAAAqM,GAAAC,GAKA,MAHAA,GAAAlB,MAAAkB,GAEAA,EAAAC,MAAAD,EAAAC,MAAA5P,MAAA,GACA2P,EAIA,QAAAE,GAAAC,EAAAhM,GACA,GAAA6L,EACAG,GAAAC,OACAJ,EAAAD,EAAA5L,EAAA6L,YACA7L,EAAAkM,gBAAAC,KAAAN,GAIA,QAAAO,GAAAJ,EAAAhM,GACA,IAAAA,EAAAkM,gBAAAG,OAEArM,EAAA6L,WAAAD,EAAAU,KAGAN,EAAAO,UAEAvM,EAAA6L,WAAA7L,EAAAkM,gBAAAM,OAKA,QAAAC,GAAAvO,EAAA8N,EAAA1B,EAAAoC,GACApC,EAAAoC,KACAC,GAAArC,EAAAoC,IAEAV,EAAAU,GAAApC,EAAAoC,GAAAjC,KAAAvM,EAAAoM,GAGA0B,EAAAU,GAAApC,EAAAoC,IAMA,QAAAE,GAAA1O,EAAA8N,EAAA1B,GACAmC,EAAAvO,EAAA8N,EAAA1B,EAAA,aACAmC,EAAAvO,EAAA8N,EAAA1B,EAAA,eACA0B,EAAAa,UAAAvC,EAAA1L,YAEA0L,EAAAwC,QACAd,EAAAe,QAAAf,EAAAgB,SAAA,SAEAhB,EAAAe,QAAAzC,EAAA2C,UACAjB,EAAAgB,SAAA1C,EAAA4C,WACAlB,EAAAmB,WAAA7C,EAAA6C,YAGA7C,EAAA8C,aACA9C,EAAA8C,eAGApB,EAAAqB,aACArB,EAAAqB,YAAA/C,EAAA8C,YAEApB,EAAAsB,eAAAhD,EAAA8C,WACApB,EAAAuB,eAAAvB,EAAAwB,qBAAAxB,EAAAyB,cAAAnD,EAAAoD,iBAEA1B,EAAA2B,cAAArD,EAAAsD,QACA5B,EAAA6B,cAAAvD,EAAAwD,QACA9B,EAAAtM,WAAA4K,EAAA5K,WACAsM,EAAArM,YAAA2K,EAAA3K,YAEAqM,EAAA+B,YAAAzD,EAAA0D,QACAhC,EAAAiC,yBAAA3D,EAAA4D,YAEA5D,EAAA6D,iBACAnC,EAAAoC,sBAAA9D,EAAA6D,gBAKA,QAAAE,GAAArC,EAAAhM,EAAAsK,GACAA,EAAAhM,OAEAgM,EAAAgE,UAEAvC,EAAAC,EAAAhM,GAGAgM,EAAAuC,OAEAvO,EAAA6L,WAAAC,MAAAK,KAAA7B,EAAAkE,QAKA,QAAAC,GAAAzC,EAAA1B,GAEAA,EAAAoE,cAEA1C,EAAAO,UAKA,QAAAoC,GAAAzQ,EAAA8N,EAAA1B,GACA,GAAAtK,EAGAsK,GAAAsE,QACA5C,EAAA6C,YAGAvE,EAAAwE,cAAA,IAAAxE,EAAA1L,aAIAoN,EAAA+C,SACA/C,EAAAgD,OAEAhD,EAAArM,YAAA,cACAqM,EAAAtM,WAAA,EAEAsM,EAAA+C,WAKA/C,EAAAgD,OAEA,gBAAA1E,EAAA9L,YACAwN,EAAArM,YAAA,eAEA,IAAA2K,EAAA1L,aAEAoN,EAAA+C,UAMAzE,EAAAsE,QACA5C,EAAA6C,YAIAJ,EAAAzC,EAAA1B,GAGAA,EAAAhM,OAEA0B,EAAAiP,EAAA/Q,GACAmQ,EAAArC,EAAAhM,EAAAsK,IAMA,QAAA4E,GAAAhR,EAAA8N,EAAA1B,EAAA3G,EAAAC,GAGA0G,EAAA6E,OAAA7E,EAAA8E,UAAAhU,GAAA,IAAA,EAEAkP,EAAAoE,cAAA,EACA1C,EAAAC,OAGA3B,EAAA+E,YAAA/E,EAAAgF,WAAA5D,SAAA/H,IAEA+H,SAAA9H,IACAA,EAAAD,GAEA2G,EAAA9P,GAAAmJ,EAAA,EACA2G,EAAA7P,GAAAmJ,EAAA,EACA0G,EAAAgF,WAAA,GAGAhF,EAAAiF,QACAC,EAAAxD,EAAA1B,EAAA,MAGA,IAAAA,EAAAmF,OAAA,IAAAnF,EAAAoF,QAAA,IAAApF,EAAAqF,QACAC,EAAA5D,EAAA1B,EAAA,OAGAA,EAAAuF,WAAAvF,EAAAwF,YAAAxF,EAAAyF,aACAC,EAAAhE,EAAA1B,EAAA,MA+CA,QAAA2E,GAAA/Q,GACA,GAAA8B,GAAAiQ,EAAAC,GAAAD,SAkEA,OAjEAA,GAAAE,UAAAjS,GAAA+R,EAAAG,MAGApQ,EAAAiQ,EAAAG,OAKApQ,EAAA7B,EAAA6B,KAAA9B,EAAA,WACA8B,IAGAA,GAEA9B,OAAAA,EAEAmS,UAEAhS,OACAiS,SACA/R,WAEAgS,cAEAC,gBAEAC,gBAAA,KACAC,OAAAvS,EAAAD,GAAA4G,IAAA,UAEAlC,MACAvE,MAAA,KACAsS,UAAA,GAGAC,OACAvI,KAAA,KACA7N,EAAA,KACAC,EAAA,MAGAoW,UAEAhF,WAAAD,EAAAU,IACAJ,mBAEA4E,WAAA,EAEAC,SAAA,KAEAC,WAAA,EAEAC,QAAA,EAGAC,mBAAA,GAGA/S,EAAA6B,KAAA9B,EAAA,UAAA8B,IAIAiQ,EAAAE,QAAAjS,EACA+R,EAAAG,MAAApQ,GAGAA,EAIA,QAAAmR,GAAAC,EAAApR,EAAA3B,GACA,GAAAgT,EAEA,KAAAA,IAAAC,IAAAT,OACAtG,OAAA3D,UAAA4D,eAAAC,KAAA6G,GAAAT,OAAAQ,KAEAhT,EAAAgT,IAAAhT,EAAAkT,SAAAlT,EAAAkT,QAAAF,KAEAG,EAAAJ,EAAApR,EAAA3B,EAAAgT,EAIArR,GAAA6Q,OAAAjR,WACAwR,EAAAK,KAAA,mBAAA,WAEA,GAAAC,GAAArT,EAAA2B,EAAA4C,KAAAvE,KAQA,KANAA,IAEA2B,EAAA4C,QACA+O,EAAAP,EAAApR,EAAA3B,EAAA,eAGAqT,EAAA,EAAAA,EAAA1R,EAAAqQ,OAAAhE,OAAAqF,GAAA,EACArT,EAAA2B,EAAAqQ,OAAAqB,GAEArT,EAAAuT,UAEAR,EAAAS,kBAAA7R,EAAAqQ,OAAAqB,GAAA,WAIAN,GAAAU,eAGA9R,EAAA6Q,OAAAjR,UAAA,GAKA,QAAAmS,GAAAX,EAAApR,EAAA3B,EAAAgT,GAIAC,GAAAT,OAAAQ,GAAAD,EAAApR,GACA3B,EAAA2T,QAAA,EAMA,QAAAR,GAAAJ,EAAApR,EAAA3B,EAAAgT,GACAU,EAAAX,EAAApR,EAAA3B,EAAAgT,GACA,cAAAA,GAAA,aAAAA,GAAA,cAAAA,IACArR,EAAAkR,mBAAA,GAKA,QAAAe,GAAAb,EAAApR,EAAA3B,GACA,GAAA6T,GAAAb,EAAAxU,CAEA,IAAAwB,EAAAyC,WAAAzC,EAAAkT,QAAA,CAMA,IAHAW,GAAA,YAAA,YAAA,WAGArV,EAAA,EAAAA,EAAAqV,EAAA7F,OAAAxP,GAAA,EAEAwU,EAAAa,EAAArV,GAEAkV,EAAAX,EAAApR,EAAA3B,EAAAgT,EAGAhT,GAAA2T,QAAA,GAMA,QAAAG,GAAAf,EAAApR,EAAA3B,EAAAkN,GACA,GAAA6G,GAAApS,EAAA3B,MAAAiS,KAGA/E,GAOAG,SAAAH,EAAAzM,MAAA+L,EAAAxM,EAAAS,OAAAT,EAAAS,OAAAyM,EAAAzM,YACAsT,GAAA/T,EAAAS,MANAyM,EAAAlN,EAYAwM,EAAAU,EAAAzM,QACAsT,EAAA7G,EAAAzM,MAAAT,GAKA,QAAAgU,GAAAjB,EAAApR,EAAA3B,EAAAkN,GACA,GACA+G,GAAAC,EAAAC,EACAxN,EAAA0M,EAFAe,EAAAzS,EAAA3B,MAAAE,MAKA,IAAAgN,GAOA,GAAAG,SAAAH,EAAAhN,QAAA,OAAAF,EAAAE,OACA,IAAAiU,EAAA,EAAAA,EAAAnU,EAAAE,OAAA8N,OAAAmG,GAAA,EAGA,GAFAD,EAAAlU,EAAAE,OAAAiU,GACAF,EAAAG,EAAAF,GACA,CAEA,IAAAb,EAAA,EAAAA,EAAAY,EAAAjG,OAAAqF,GAAA,EACA,GAAAY,EAAAZ,KAAArT,EAAA,CAEA2G,EAAA0M,EAEAY,EAAAI,OAAAhB,EAAA,EACA,OAIA,IAAAY,EAAAjG,cACAoG,GAAAF,QAtBAhH,GAAAlN,CA+BA,IAAAqN,SAAAH,EAAAhN,QAAA,OAAAgN,EAAAhN,OAEA,IAAAiU,EAAA,EAAAA,EAAAjH,EAAAhN,OAAA8N,OAAAmG,GAAA,EAEAD,EAAAhH,EAAAhN,OAAAiU,GAEAF,EAAAG,EAAAF,GACAD,IAEAA,EAAAG,EAAAF,MACAD,EAAAxT,KAAAyT,GAEA7G,SAAA1G,IAEAA,EAAAsN,EAAAjG,QAGAiG,EAAAI,OAAA1N,EAAA,EAAA3G,GAgdA,QAAAsU,GAAA3S,GACA,GAAA3B,GAAAxB,EACAyB,EAAArC,CAMA,KAHAoC,EAAA,KAGAxB,EAAAmD,EAAAwQ,aAAAnE,OAAA,EAAAxP,GAAA,EAAAA,GAAA,EAMA,GAHAwB,EAAA2B,EAAAwQ,aAAA3T,GAGAwB,EAAAuU,OAAA,CAIA,IAAA3W,EAAAoC,EAAAuU,OAAAvG,OAAA,EAAApQ,GAAA,EAAAA,GAAA,EAGA,GAFAqC,EAAAD,EAAAuU,OAAA3W,IAEAqC,EAAAuU,WAAA,CAGAxU,EAAAwU,YAAA,CAEA,OAOA,GAAAxU,EAAAwU,aAAAxU,EAAAyU,WAEA,MAWA,MAJAzU,IAAAA,EAAAyU,aAEAzU,EAAA,MAEAA,EAIA,QAAA0U,GAAA3B,EAAApF,EAAA3N,EAAA2U,GACA3U,GAAAA,EAAA4U,SAAA5U,EAAA6U,UACAF,EACA3U,EAAA8U,MAAAH,EAEA3U,EAAA8U,MAAA,KAGA9U,EAAA6U,SACA7U,EAAA6U,QAAAzI,KAAA2G,EAAA/S,IAMA,QAAA+U,GAAAhC,EAAApR,EAAAqT,GACA,GAAAhD,GAAAhS,EAAAqT,EACA9O,EAAA0Q,EACAhB,EAAAC,EAAAC,EACAe,EAAAC,CAOA,IALA5Q,EAAA5C,EAAA4C,KACAvE,EAAAuE,EAAAvE,MACAiV,EAAAjV,GAAAA,EAAAiV,eACAjD,EAAArQ,EAAAqQ,OAEA,cAAAgD,GAAA,cAAAA,GA8BA,GA3BAzQ,EAAA+N,WAIA/N,EAAA+N,UAAA,EACAtS,EAAAsS,UAAA,EAGAtS,EAAAoV,eAEApD,EAAAqC,OAAArU,EAAA2G,MAAA,GAGA3G,EAAA2G,MAAAqL,EAAAlE,KAAA9N,IAIAA,EAAAqV,QAAArV,EAAA7D,EACA6D,EAAAsV,QAAAtV,EAAA5D,EACA4D,EAAAuV,MAAAvV,EAAAwV,QACAxV,EAAAyV,MAAAzV,EAAA0V,QAGApC,EAAAP,EAAApR,EAAA3B,EAAA,cAIAuE,EAAA+N,SAAA,CAqBA,GAlBA4C,EAAAlV,EAAAwV,SAAAxV,EAAAuV,MAAAvV,EAAAqV,SACAF,EAAAnV,EAAA0V,SAAA1V,EAAAyV,MAAAzV,EAAAsV,SACAtV,EAAA2V,cACAT,EAAAlV,EAAA2V,YAAAvJ,KAAA2G,EAAA,GAAA/S,EAAAkV,IAEAlV,EAAA4V,cACAT,EAAAnV,EAAA4V,YAAAxJ,KAAA2G,EAAA,GAAA/S,EAAAmV,IAEAnV,EAAA6V,GAAAX,EAAAlV,EAAA7D,EACA6D,EAAA8V,GAAAX,EAAAnV,EAAA5D,EAEA,MAAA4D,EAAA+V,qBACA/V,EAAA7D,EAAA+Y,GAEA,MAAAlV,EAAA+V,qBACA/V,EAAA5D,EAAA+Y,GAGAnV,EAAA2C,cAAA,EAAA,CACA,GAAAqT,GAAAhW,EAAA6C,cACAoT,EAAAjW,EAAA8C,cACAoT,EAAAlW,EAAA4C,aACAkC,EAAA9E,EAAA7D,EAAA6Z,EACAjR,EAAA/E,EAAA5D,EAAA6Z,EACAE,EAAApR,EAAAD,CAEA,IAAAA,EAAA,EACA,GAAAsR,IAAA1Z,GAAAC,KAAAD,GAAAU,IAAA8Y,EAAA,IAAA,EAAAxZ,GAAAU,IAAA,EAAA,SAEA,IAAAgZ,GAAA1Z,GAAAC,KAAAD,GAAAU,IAAA8Y,EAAA,IAAA,EAAAxZ,GAAAU,IAAA,EAAA,IAEA,IAAAiZ,GAAAD,EAAAD,EAEAG,EAAAtW,EAAA+C,KACAwT,EAAAvW,EAAAgD,KACAwT,EAAAxW,EAAAiD,KACAwT,EAAAzW,EAAAkD,KACAwT,EAAAxB,EACAyB,EAAAxB,EACAyB,GAAAla,GAAAU,IAAAkZ,EAAA,GAAA5Z,GAAAU,IAAAmZ,EAAA,KAAAC,EAAAG,EAAAF,EAAAC,IACAha,GAAAU,IAAAoZ,EAAA,GAAA9Z,GAAAU,IAAAqZ,EAAA,KAAAH,EAAAK,EAAAJ,EAAAG,IACAha,GAAAU,IAAAsZ,EAAA,GAAAha,GAAAU,IAAAuZ,EAAA,KAAAL,EAAAG,EAAAF,EAAAC,EAEA,IAAAI,GAAA,EAAA,CACA,GAAAC,GAAAna,GAAAoa,IAAA9W,EAAA+C,KAAAmS,GAAAxY,GAAAoa,IAAA9W,EAAAgD,KAAAmS,GACA4B,EAAAra,GAAAoa,IAAA9W,EAAAiD,KAAAiS,GAAAxY,GAAAoa,IAAA9W,EAAAkD,KAAAiS,EACA0B,GAAAE,GACAX,EAAApW,EAAA+C,KAAAiT,EACAK,EAAArW,EAAAgD,KAAAiT,IAEAG,EAAApW,EAAAiD,KAAA+S,EACAK,EAAArW,EAAAkD,KAAA+S,GAIA,GAAAf,GAAAkB,EAAAJ,EACAb,EAAAkB,EAAAJ,CAEAjW,GAAA7D,EAAA+Y,EACAlV,EAAA5D,EAAA+Y,EAQA,IAHA7B,EAAAP,EAAApR,EAAA3B,EAAA,QAGAmU,EAAA,EAAAA,EAAAc,EAAAjH,OAAAmG,GAAA,EAIA,GAFAD,EAAAe,EAAAd,GACAF,EAAAtS,EAAA3B,MAAAE,OAAAgU,GACAlU,EAAAE,QAAA+T,EAEA,IAAAZ,EAAA,EAAAA,EAAAY,EAAAjG,OAAAqF,GAAA,EACAY,EAAAZ,KAAArT,IACA,MAAAA,EAAA+V,oBAAA,MAAA9B,EAAAZ,GAAA0C,qBACA9B,EAAAZ,GAAAlX,GAAA6D,EAAA6V,IAEA,MAAA7V,EAAA+V,oBAAA,MAAA9B,EAAAZ,GAAA0C,qBACA9B,EAAAZ,GAAAjX,GAAA4D,EAAA8V,UAWA,YAAAd,GAAA,aAAAA,IAGAzQ,EAAA+N,WACAtS,EAAAsS,UAAA,EACA/N,EAAA+N,UAAA,EACA3Q,EAAAkR,kBAAAlR,EAAAqV,0BAEA1D,EAAAP,EAAApR,EAAA3B,EAAA,aAIA2B,EAAA4C,SAuBA,QAAA0S,GAAAlE,EAAA/S,EAAAgV,GACA,GAAA3C,EACArS,GAAAkT,UAEAb,EAAArS,EAAAkT,QAAA8B,IAGAlV,EAAAoX,QAAA7E,EAAA5L,GAAAyM,gBACAb,EAAA5L,GAAA0Q,OAAA9E,GAGAA,GAEAU,EAAAtM,KACA4L,OAAAA,IAMA,QAAA+E,GAAArE,EAAApR,GACAoR,EAAAtM,KACA4L,OAAA1Q,EAAA0Q,SAKA,QAAAgF,GAAAtE,EAAA/S,EAAAgV,EAAAsC,EAAAC,GAEAD,EAAAtC,IAAAhV,EAAAwX,WAAAxX,EAAAwX,SAAAxC,KAEAhV,EAAAwX,SAAAxC,IAAA,EAEAsC,EAAAtC,GAAA5I,KAAA2G,EAAA,GAAA/S,EAAAuX,GAEAvX,EAAAwX,SAAAxC,IAAA,GAKA,QAAAyC,GAAAzX,EAAAgV,GAGA,QAAAhV,EAAA0X,eACA1X,EAAAyU,YAAA3U,EAAAoX,QAAAlC,EAAA2C,UAIA,QAAArE,GAAAP,EAAApR,EAAA3B,EAAAgV,EAAAuC,GAEAE,EAAAzX,EAAAgV,KAGA,aAAAA,GAEAiC,EAAAlE,EAAA/S,EAAAgV,GAIAqC,EAAAtE,EAAA/S,EAAAgV,EAAAhV,EAAAuX,GAEAF,EAAAtE,EAAA/S,EAAAgV,EAAArT,EAAAuQ,WAAAqF,GAEAF,EAAAtE,EAAA/S,EAAAgV,EAAA/B,GAAAf,WAAAqF,IAsMA,QAAAK,GAAA/X,EAAAoM,EAAAF,EAAA8L,GACA,GAAA9E,GAAApR,EACAqQ,EAAAhS,EAAAiM,EAAA6L,OAAA/L,EAAAE,CAmGA,OAhGAA,GAAAkE,MAAApE,GAGAE,EAAAxJ,WAAAwJ,EAAAgJ,cACAhJ,EAAAjM,OAAA,EACAiM,EAAAxJ,WAAA,GAIAwJ,EAAA4I,UACAgD,EACA5L,EAAA4I,QAAAgD,EACA5L,EAAA4L,OACA5L,EAAA4I,QAAA/U,EAAAiY,GAAA9L,EAAA4L,QACA5L,EAAAjC,OACAiC,EAAA4I,QAAA/U,EAAAiY,GAAAC,GAAAC,SAAAhM,EAAAjC,SAKAiC,EAAAjM,QAAAiM,EAAA6L,QAGA/E,EAAAjT,EAAAD,GAEA8B,EAAAiP,EAAA/Q,GACAmS,EAAArQ,EAAAqQ,QAGA,OAAAhS,EAAAS,MAAA+L,EAAAxM,EAAAS,OAAA4M,SAAA1L,EAAA3B,MAAAiS,MAAAjS,EAAAS,SAGAwM,EAAAhB,GAGAjM,EAAA,GAAA8L,GAAAG,GACAjM,EAAAH,OAAAA,EAEAG,EAAAA,OAAA,EACAA,EAAA8X,QAAA,EACA9X,EAAAwX,YAEA,OAAAxX,EAAA2B,KAEA3B,EAAA2B,KAAA2K,MAAAtM,EAAA2B,MAGA3B,EAAA2B,QAGA,OAAA3B,EAAAE,OAEAF,EAAAE,OAAAF,EAAAE,OAAArC,MAAA,GAGAmC,EAAAE,UAIA4T,EAAAf,EAAApR,EAAA3B,GACAgU,EAAAjB,EAAApR,EAAA3B,GAGA8S,EAAAC,EAAApR,EAAA3B,GAGA4T,EAAAb,EAAApR,EAAA3B,GAGAiM,EAAA0H,OAAA3T,EAAA2T,OAGA3T,EAAA6U,UAAA/U,EAAAiY,GAAAtS,UACAsN,EAAAmF,YAAAlY,GAIA,OAAAA,EAAA2G,QACA3G,EAAA2G,MAAAqL,EAAAhE,QAIAgE,EAAAqC,OAAArU,EAAA2G,MAAA,EAAA3G,GAGAiM,EAAAkE,MAAAnQ,EAGAsT,EAAAP,EAAApR,EAAA3B,EAAA,SAIAiM,EAAAjM,OACAiN,EAAAhB,GAGAjM,EAiCA,QAAAmY,GAAAC,GACA,GAAAC,GAAAC,CACA,KAAAA,EAAA,EAAAA,EAAA7R,GAAAyG,MAAAc,OAAAsK,GAAA,EACAD,EAAA5R,GAAAyG,MAAAoL,GACAF,EAAAC,GAAAD,EAAA,IAAAC,GAGA,QAAAE,GAAAH,EAAAI,GACA,GAAAH,GAAAC,CACA,KAAAA,EAAA,EAAAA,EAAA7R,GAAAyG,MAAAc,OAAAsK,GAAA,EACAD,EAAA5R,GAAAyG,MAAAoL,GAEAjL,SAAA+K,EAAAC,KACAD,EAAA,IAAAC,GAAAD,EAAAC,GACA5R,GAAAgS,SAAAJ,IAAA,EACAG,SACAJ,GAAAC,IAOA,QAAAK,GAAA7Y,EAAAG,EAAA2Y,GACA,GAAA3M,GAAAoB,EACAwL,EAAAC,CAEA,KAAA7M,IAAA2M,GACA,GAAAzM,OAAA3D,UAAA4D,eAAAC,KAAAuM,EAAA3M,KACAoB,EAAAuL,EAAA3M,GAEAsC,GAAAlB,KAEAuL,EAAA3M,GAAAoB,EAAAhB,KAAAvM,EAAAG,EAAAgM,IAGA,WAAAU,GAAAU,IAAA0L,GAAA1L,IAAA,CAEA,IAAAwL,IAAAxL,GACAlB,OAAA3D,UAAA4D,eAAAC,KAAAgB,EAAAwL,KACAC,EAAAzL,EAAAwL,GAEAvL,SAAArN,EAAAgM,KACAhM,EAAAgM,EAAA,IAAA4M,GAAA5Y,EAAAgM,GAAA4M,GAEAD,EAAA3M,EAAA,IAAA4M,GAAAC,UAKAF,GAAA3M,GAIA,MAAA2M,GAIA,QAAAI,GAAA/Y,GACA,GAAAgM,EACA,KAAAA,IAAAhM,GACAkM,OAAA3D,UAAA4D,eAAAC,KAAApM,EAAAgM,IACAA,EAAAgN,QAAA,iBACAhZ,GAAAgM,GAOA,QAAAiN,GAAA9a,GACA,GAAA+a,GAAAC,EACAlb,KACAmb,EAAA,CA8BA,OA3BA,gBAAAjb,EACAA,EAAA,mBACAA,EAAAL,MAAA,6BAEAqb,EAAAjP,GAAAmP,KACAH,EAAAC,EAAAG,MAAAnb,MACAgb,EAAAG,MAAAnb,MAAAA,EACAA,EAAA2B,EAAA2G,IAAA0S,EAAA,SACAA,EAAAG,MAAAnb,MAAA+a,GAGA/a,EAAAL,MAAA,YACAG,EAAAE,EAAAL,MAAA,mBAEAK,EAAAL,MAAA,SACAsb,EAAA,MAEAnb,EAAA,IAAAmb,EACAnb,EAAA,IAAAmb,EACAnb,EAAA,IAAAmb,EAEA/L,SAAApP,EAAA,GACAA,EAAA,GAAA6O,GAAA7O,EAAA,IAEAA,EAAA,GAAA,GAGAA,EAIA,QAAAsb,GAAAC,GACA,GACAhb,GADAib,EAAA,CAeA,KAZA,UAAA/M,GAAA8M,EAAApZ,SACAoZ,EAAApZ,MAAA6Y,EAAAO,EAAApZ,OACAoZ,EAAAnZ,IAAA4Y,EAAAO,EAAAnZ,MAEAmZ,EAAAE,OAGA,IAAAF,EAAApZ,MAAA,IAAA,IAAAoZ,EAAAnZ,IAAA,KACAoZ,EAAA,GAIAjb,EAAA,EAAAA,EAAAib,EAAAjb,GAAA,EACAgb,EAAAE,IAAAlb,GAAAgb,EAAApZ,MAAA5B,IAAAgb,EAAAnZ,IAAA7B,GAAAgb,EAAApZ,MAAA5B,IAAAgb,EAAAG,IAEAnb,EAAA,IACAgb,EAAAE,IAAAlb,GAAAob,GAAAJ,EAAAE,IAAAlb,IAGA,KAAAgb,EAAApZ,MAAA,IAAA,IAAAoZ,EAAAnZ,IAAA,GAEAmZ,EAAAE,IAAA,QAAAF,EAAAE,IAAAG,KAAA,KAAA,KAGAL,EAAAE,IAAA7b,MAAA,EAAA,GACA2b,EAAAE,IAAA,OAAAF,EAAAE,IAAAG,KAAA,KAAA,KAGAL,EAAAL,KAAAW,SACAN,EAAAL,KAAAG,MAAAE,EAAAO,MAAAP,EAAAE,IAEAF,EAAAL,KAAAK,EAAAO,MAAAP,EAAAE,IA0SA,QAAAM,GAAA9M,GACA,GAAAoL,EACA,KAAAA,EAAA,EAAAA,EAAApL,EAAAc,OAAAsK,GAAA,EACAxY,EAAA0Z,GAAAS,KAAA/M,EAAAoL,IAAAiB,EAmCA,QAAAW,GAAAlH,GAKA,MAHAgF,IAAAmC,YAAAnH,KACAA,EAAAgF,GAAAmC,YAAAnH,IAEAA,EAGA,QAAAoH,GAAApH,GAIA,MAHAgF,IAAAqC,YAAArH,KACAA,EAAAgF,GAAAqC,YAAArH,IAEAA,EAIA,QAAAsH,GAAAtH,GAEAC,GAAAT,OAAAQ,GAAA,SAAAD,EAAApR,GAUA,QAAA4Y,GAAAhI,GAEAiI,EAAAre,EAAAoW,EAAAkI,QACAD,EAAApe,EAAAmW,EAAAmI,QACAF,EAAAxQ,KAAA2Q,EACAH,EAAAjI,MAAAA,GAIA,cAAAA,EAAAvI,MAAArI,EAAAkR,mBAAAlR,EAAA4C,KAAA+N,WACAS,EAAAU,YACAmH,WAAA,IAIArI,EAAAzJ,iBAxBA,GAAA6R,GAAAE,EAAAL,CAGAA,GAAA7Y,EAAA4Q,MAGAoI,EAAA,cAAA3H,GAAA,aAAAA,EAAA,YAAAA,EACA6H,EAAAX,EAAAS,GAqBAhZ,EAAA6Q,OAAAmI,KAEAE,IAAAF,EACA5H,EAAAK,KAAAuH,EAAA,YAAAE,EAAA,WAAAN,GAEAxH,EAAAK,KAAAuH,EAAA,WAAAJ,GAGA5Y,EAAA6Q,OAAAmI,IAAA,IAIA,QAAAG,GAAAC,GACA,GAAAtB,EACA,KAAAA,EAAA,EAAAA,EAAAsB,EAAA/M,OAAAyL,GAAA,EACAa,EAAAS,EAAAtB,IAsBA,QAAAuB,GAAAnb,EAAA8N,EAAA1B,GACA,GAAAjM,GAAA2B,EAAA6Y,EAAAhG,EACAhH,EAAArR,EAAAC,EAAA6F,CAGAjC,GAAAiM,EAAAkE,MAEAnQ,IAEA2B,EAAAiP,EAAA/Q,GACA2a,EAAA7Y,EAAA4Q,MACA,OAAAiI,EAAAre,GAAA,OAAAqe,EAAApe,IAEAD,EAAAqe,EAAAre,EAAAwF,EAAAgR,WACAvW,EAAAoe,EAAApe,EAAAuF,EAAAgR,WAEA6B,EAAA7G,EAAAsN,cAAA9e,EAAAC,IAAAuR,EAAAuN,iBAAAvN,EAAAuN,gBAAA/e,EAAAC,IAEAoR,EAAA7L,EAAA6L,WAGAxN,EAAAY,OAAA4Z,EAAAre,EACA6D,EAAAa,OAAA2Z,EAAApe,EACA4D,EAAAuS,MAAAiI,EAAAjI,MAKAtQ,EAAAN,EAAA6L,WAAA0D,OACA/U,EAAA6D,EAAAY,OACAxE,EAAA4D,EAAAa,OAEA,IAAAoB,GAEAjC,EAAAwV,QAAArZ,EAAAgf,IAAAlZ,GAAA7F,EAAAgf,IAAAnZ,GACAjC,EAAA0V,QAAAtZ,EAAA+e,IAAAlZ,GAAA9F,EAAAif,IAAAnZ,KAGAjC,EAAAwV,QAAArZ,EACA6D,EAAA0V,QAAAtZ,GAIA4D,EAAAwV,SAAAhI,EAAA6D,OACArR,EAAA0V,SAAAlI,EAAA8D,OAGAkD,GAEA7S,EAAAwQ,aAAArE,KAAA9N,GAEAA,EAAAwU,WAAA9J,QAAA8J,IA4LA,QAAArD,GAAAxD,EAAA1B,EAAAuB,GAGAvB,EAAA6E,OAAA7E,EAAA8E,UAAAhU,GAAA,IAAA,EAGA4Q,EAAA6D,UAAAvF,EAAA9P,EAAA8P,EAAA7P,GACAuR,EAAAuD,OAAAjF,EAAAiF,OAAAjF,EAAA6E,QACAnD,EAAA6D,WAAAvF,EAAA9P,GAAA8P,EAAA7P,GAGAoR,IAEAA,EAAA0D,QAAAjF,EAAAiF,OAAAjF,EAAA6E,QAKA,QAAAS,GAAA5D,EAAA1B,EAAAuB,GAGA,IAAAvB,EAAAmF,QACAnF,EAAAoF,OAAApF,EAAAqF,OAAArF,EAAAmF,OAIAzD,EAAA6D,UAAAvF,EAAA9P,EAAA8P,EAAA7P,GACAuR,EAAAyD,MAAAnF,EAAAoF,OAAApF,EAAAqF,QACA3D,EAAA6D,WAAAvF,EAAA9P,GAAA8P,EAAA7P,GAGAoR,IAEAA,EAAA6D,QAAApF,EAAAoF,OACA7D,EAAA8D,QAAArF,EAAAqF,QAKA,QAAAK,GAAAhE,EAAA1B,EAAAuB,GAGAvB,EAAAuF,YACAvF,EAAAwF,WAAAxF,EAAAyF,WAAAzF,EAAAuF,WAIA7D,EAAA6D,UAAAvF,EAAAwF,WAAAxF,EAAAyF,YAGAlE,IAEAA,EAAAiE,YAAAxF,EAAAwF,WACAjE,EAAAkE,YAAAzF,EAAAyF,YAuKA,QAAA2J,GAAApZ,GACA,KAAAA,EAAA,GACAA,GAAA,EAAAlF,EAEA,OAAAkF,GAIA,QAAAqZ,GAAArP,EAAAhK,GACA,MAAAgK,GAAA9P,EAAA8P,EAAA/O,OAAAie,GAAAlZ,GAGA,QAAAsZ,GAAAtP,EAAAhK,GACA,MAAAgK,GAAA7P,EAAA6P,EAAA/O,OAAAke,GAAAnZ,GAIA,QAAAuZ,GAAA3b,EAAA8N,EAAA1B,EAAAwP,GACA,GAAA3W,GAAAC,EAAAC,EAAAC,EACAyW,EAAAC,EAAAC,EAAAC,EACApB,EAAAC,EACAoB,CAGA7P,KAAAwP,GACAhB,EAAA,EACAC,EAAA,IAEAD,EAAAxO,EAAA9P,EACAue,EAAAzO,EAAA7P,GAIAqf,EAAA1K,WAAA,MAAA0K,EAAApb,MACAob,EAAApb,IAAA,EAAAtD,IAIA0e,EAAArb,OAAA6L,EAAA6E,OACA2K,EAAApb,KAAA4L,EAAA6E,OAEA2K,EAAArb,OAAArD,GAAA,EACA0e,EAAApb,KAAAtD,GAAA,EAGA+e,EAAA/e,GAAA,IACA0e,EAAAM,MACAD,OAIAhX,EAAAwW,EAAAG,EAAAA,EAAArb,MAAA0b,GACA/W,EAAAwW,EAAAE,EAAAA,EAAArb,MAAA0b,GACA9W,EAAAsW,EAAAG,EAAAA,EAAArb,OACA6E,EAAAsW,EAAAE,EAAAA,EAAArb,OAEA4b,EACAnc,EAAA8N,EACA1B,EAAAwP,EACA3W,EAAAC,EACAC,EAAAC,GAIA0I,EAAAsO,IAAAR,EAAAtf,EAAAse,EAAAgB,EAAArf,EAAAse,EAAAe,EAAAve,OAAAue,EAAArb,MAAAqb,EAAApb,IAAAob,EAAAM,KAGAL,EAAAJ,EAAAG,EAAAA,EAAApb,IAAAyb,GACAH,EAAAJ,EAAAE,EAAAA,EAAApb,IAAAyb,GACAF,EAAAN,EAAAG,EAAAA,EAAApb,KACAwb,EAAAN,EAAAE,EAAAA,EAAApb,KAEA6b,GACArc,EAAA8N,EACA1B,EAAAwP,EACAG,EAAAC,EACAH,EAAAC,GA2MA,QAAAQ,GAAAtc,EAAA8N,EAAA1B,EAAAwP,EAAA3W,EAAAC,EAAAC,EAAAC,GACA,GAAAmX,GAAAC,EACAC,EAAAC,EACA9B,EAAAC,EACAzY,CAGAwZ,GAAAe,cAAAvQ,EAAAsE,SAGAtO,EAAApF,GAAAoI,EAAAF,EAAAC,EAAAF,GAEA7C,GAAAlF,GAEA0d,EAAAxO,EAAA1L,YAAA4a,GAAAlZ,GACAyY,EAAAzO,EAAA1L,YAAA6a,GAAAnZ,GAGAma,EAAApX,EAAAyW,EAAAe,YAAArB,GAAAlZ,EAAAwZ,EAAAgB,WAAA,GACAJ,EAAApX,EAAAwW,EAAAe,YAAApB,GAAAnZ,EAAAwZ,EAAAgB,WAAA,GAEAH,EAAAtX,EAAAyW,EAAAe,YAAArB,GAAAlZ,EAAAwZ,EAAAgB,WAAA,GACAF,EAAAtX,EAAAwW,EAAAe,YAAApB,GAAAnZ,EAAAwZ,EAAAgB,WAAA,GAGA9O,EAAA+O,OAAAN,EAAA3B,EAAA4B,EAAA3B,GACA/M,EAAAgP,OAAA3X,EAAAyV,EAAAxV,EAAAyV,GAEA/M,EAAAgP,OAAAL,EAAA7B,EAAA8B,EAAA7B,GAGA/M,EAAA+O,OAAA1X,EAAAyV,EAAAxV,EAAAyV,GACA/M,EAAAgP,OAAA3X,EAAAyV,EAAAxV,EAAAyV,GAEA/M,EAAA+O,OAAA1X,EAAAC,IAMA,QAAA+W,GAAAnc,EAAA8N,EAAA1B,EAAAwP,EAAA3W,EAAAC,EAAAC,EAAAC,GACAwW,EAAAmB,uBACAnB,EAAAgB,YAAAxQ,EAAA6E,OACA2K,EAAAmB,sBAAA,GAEAnB,EAAAoB,YACAV,EAAAtc,EAAA8N,EAAA1B,EAAAwP,EAAA3W,EAAAC,EAAAC,EAAAC,GAKA,QAAAiX,IAAArc,EAAA8N,EAAA1B,EAAAwP,EAAA3W,EAAAC,EAAAC,EAAAC,GACAwW,EAAAmB,uBACAnB,EAAAgB,YAAAxQ,EAAA6E,OACA2K,EAAAmB,sBAAA,GAEAnB,EAAAqB,UACAX,EAAAtc,EAAA8N,EAAA1B,EAAAwP,EAAA3W,EAAAC,EAAAC,EAAAC,GAKA,QAAA8X,IAAAld,EAAA8N,EAAA1B,EAAAwP,GACA,GAAApI,GACA2J,EAAAC,CAaA,KAZA5J,EAAA,EACA2I,EACAnc,EAAA8N,EACA1B,EAAAwP,EACAA,EAAAzW,GAAAiH,EAAA9P,EACAsf,EAAAxW,GAAAgH,EAAA7P,EACAqf,EAAA3W,GAAAmH,EAAA9P,EACAsf,EAAA1W,GAAAkH,EAAA7P,GAEAiR,SAAAoO,EAAA3W,IAAAuI,SAAAoO,EAAA1W,IACA4I,EAAA+O,OAAAjB,EAAA3W,GAAAmH,EAAA9P,EAAAsf,EAAA1W,GAAAkH,EAAA7P,KAEA,CAKA,GAHA4gB,EAAAvB,EAAA,IAAApI,GACA4J,EAAAxB,EAAA,IAAApI,GAEAhG,SAAA2P,GAAA3P,SAAA4P,EAMA,KAJAtP,GAAAgP,OAAAK,EAAA/Q,EAAA9P,EAAA8gB,EAAAhR,EAAA7P,GACAiX,GAAA,EAMAA,GAAA,EAEA6I,GACArc,EAAA8N,EACA1B,EACAwP,EACAA,EAAA,KAAApI,EAAA,IAAApH,EAAA9P,EACAsf,EAAA,KAAApI,EAAA,IAAApH,EAAA7P,EACAqf,EAAA,IAAApI,GAAApH,EAAA9P,EACAsf,EAAA,IAAApI,GAAApH,EAAA7P,GAoCA,QAAA8gB,IAAArd,EAAA8N,EAAA1B,EAAAwP,GACA,GAAApI,GACA2J,EAAAC,EACAE,EAAAC,CAkBA,KAhBA/J,EAAA,EAEA2I,EACAnc,EACA8N,EACA1B,EACAwP,EACAA,EAAA4B,IAAApR,EAAA9P,EACAsf,EAAA6B,IAAArR,EAAA7P,EACAqf,EAAA3W,GAAAmH,EAAA9P,EACAsf,EAAA1W,GAAAkH,EAAA7P,GAGAiR,SAAAoO,EAAA3W,IAAAuI,SAAAoO,EAAA1W,IACA4I,EAAA+O,OAAAjB,EAAA3W,GAAAmH,EAAA9P,EAAAsf,EAAA1W,GAAAkH,EAAA7P,KAEA,CAOA,GALA4gB,EAAAvB,EAAA,IAAApI,GACA4J,EAAAxB,EAAA,IAAApI,GACA8J,EAAA1B,EAAA,MAAApI,EAAA,IACA+J,EAAA3B,EAAA,MAAApI,EAAA,IAEAhG,SAAA2P,GAAA3P,SAAA4P,GAAA5P,SAAA8P,GAAA9P,SAAA+P,EAMA,KAJAzP,GAAA4P,iBAAAJ,EAAAlR,EAAA9P,EAAAihB,EAAAnR,EAAA7P,EAAA4gB,EAAA/Q,EAAA9P,EAAA8gB,EAAAhR,EAAA7P,GACAiX,GAAA,EAMAA,GAAA,EACA6I,GACArc,EACA8N,EACA1B,EACAwP,EACAA,EAAA,MAAApI,EAAA,IAAApH,EAAA9P,EACAsf,EAAA,MAAApI,EAAA,IAAApH,EAAA7P,EACAqf,EAAA,IAAApI,GAAApH,EAAA9P,EACAsf,EAAA,IAAApI,GAAApH,EAAA7P,GAmCA,QAAAohB,IAAA3d,EAAA8N,EAAA1B,EAAAwP,GACA,GAAApI,GAAAoK,EACAT,EAAAC,EACAS,EAAAC,EACAC,EAAAC,CAmBA,KAjBAxK,EAAA,EACAoK,EAAA,EAEAzB,EACAnc,EACA8N,EACA1B,EACAwP,EACAA,EAAA4B,IAAApR,EAAA9P,EACAsf,EAAA6B,IAAArR,EAAA7P,EACAqf,EAAA3W,GAAAmH,EAAA9P,EACAsf,EAAA1W,GAAAkH,EAAA7P,GAGAiR,SAAAoO,EAAA3W,IAAAuI,SAAAoO,EAAA1W,IACA4I,EAAA+O,OAAAjB,EAAA3W,GAAAmH,EAAA9P,EAAAsf,EAAA1W,GAAAkH,EAAA7P,KAEA,CASA,GAPA4gB,EAAAvB,EAAA,IAAApI,GACA4J,EAAAxB,EAAA,IAAApI,GACAqK,EAAAjC,EAAA,KAAAgC,GACAE,EAAAlC,EAAA,KAAAgC,GACAG,EAAAnC,EAAA,MAAAgC,EAAA,IACAI,EAAApC,EAAA,MAAAgC,EAAA,IAEApQ,SAAA2P,GAAA3P,SAAA4P,GAAA5P,SAAAqQ,GAAArQ,SAAAsQ,GAAAtQ,SAAAuQ,GAAAvQ,SAAAwQ,EAOA,KALAlQ,GAAAmQ,cAAAJ,EAAAzR,EAAA9P,EAAAwhB,EAAA1R,EAAA7P,EAAAwhB,EAAA3R,EAAA9P,EAAA0hB,EAAA5R,EAAA7P,EAAA4gB,EAAA/Q,EAAA9P,EAAA8gB,EAAAhR,EAAA7P,GACAiX,GAAA,EACAoK,GAAA,EAMApK,GAAA,EACAoK,GAAA,EACAvB,GACArc,EACA8N,EACA1B,EACAwP,EACAA,EAAA,MAAAgC,EAAA,IAAAxR,EAAA9P,EACAsf,EAAA,MAAAgC,EAAA,IAAAxR,EAAA7P,EACAqf,EAAA,IAAApI,GAAApH,EAAA9P,EACAsf,EAAA,IAAApI,GAAApH,EAAA7P,GAmCA,QAAA2hB,IAAA9R,EAAAhK,EAAA+L,GAGA,MAFA/L,IAAAgK,EAAA6E,OACA7O,GAAAlF,GAAA,EACAiR,EAAAmN,GAAAlZ,GAGA,QAAA+b,IAAA/R,EAAAhK,EAAA+L,GAGA,MAFA/L,IAAAgK,EAAA6E,OACA7O,GAAAlF,GAAA,EACAiR,EAAAoN,GAAAnZ,GAIA,QAAAgc,IAAApe,EAAA8N,EAAA1B,EAAAwP,GACA,GAAApI,GAAApR,EAAA+L,EACAyM,EAAAC,EACAve,EAAAC,EACAsf,EAAAC,EACAC,EAAAC,CA4BA,KAzBA5P,IAAAwP,GACAhB,EAAA,EACAC,EAAA,IAEAD,EAAAxO,EAAA9P,EACAue,EAAAzO,EAAA7P,GAGAiX,EAAA,EACAlX,EAAAuf,EAAAE,EAAAH,EAAAtf,EAAAse,EACAre,EAAAuf,EAAAE,EAAAJ,EAAArf,EAAAse,EAEAsB,EACAnc,EAAA8N,EACA1B,EAAAwP,EACAtf,EAAA4hB,GAAA9R,EAAAwP,EAAA3Z,GAAA2Z,EAAA1Z,IACA3F,EAAA4hB,GAAA/R,EAAAwP,EAAA3Z,GAAA2Z,EAAA1Z,IACA5F,EACAC,GAIAiR,SAAAoO,EAAAtf,GAAAkR,SAAAoO,EAAArf,GACAuR,EAAA+O,OAAAvgB,EAAAC,KAEA,CAKA,GAHA6F,EAAAwZ,EAAA,IAAApI,GACArF,EAAAyN,EAAA,IAAApI,GAEAhG,SAAApL,GAAAoL,SAAAW,EAYA,KATA0N,GAAAE,EACAD,EAAAE,EAEAD,GAAAmC,GAAA9R,EAAAhK,EAAA+L,GACA6N,GAAAmC,GAAA/R,EAAAhK,EAAA+L,GACAL,EAAAgP,OAAAf,EAAAC,GACAxI,GAAA,EAOA6I,GACArc,EAAA8N,EACA1B,EAAAwP,EACAC,EAAAC,EACAC,EAAAC,GAyFA,QAAAqC,IAAAre,EAAA8N,EAAA1B,GAEAW,MAAAC,GAAAZ,EAAAvG,aAEAuG,EAAAvG,UAAA,MAGAiI,EAAAwQ,KAAAlS,EAAAmS,UAAA,IAAAnS,EAAAvG,SAAA,IAAAuG,EAAAtG,WAIA,QAAA0Y,IAAAxe,EAAA8N,EAAA1B,EAAAqS,GACA,GAAAC,GAAAC,EAAAnL,EACAoL,EAAA5M,GAAA4M,SAGA,IAAAA,EAAAvd,OAAA+K,EAAA/K,MAAAud,EAAAL,YAAAnS,EAAAmS,WAAAK,EAAA/Y,WAAAuG,EAAAvG,UAAA+Y,EAAA9Y,aAAAsG,EAAAtG,YAAA8Y,EAAA7Y,WAAAqG,EAAArG,UAAA6Y,EAAAC,aAAAzS,EAAAyS,WAEAzS,EAAA3G,MAAAmZ,EAAAnZ,MACA2G,EAAA1G,OAAAkZ,EAAAlZ,WAEA,CAOA,IAHA0G,EAAA3G,MAAAqI,EAAAuK,YAAAoG,EAAA,IAAAhZ,MAGA+N,EAAA,EAAAA,EAAAiL,EAAAtQ,OAAAqF,GAAA,EAEAmL,EAAA7Q,EAAAuK,YAAAoG,EAAAjL,IAAA/N,MAEAkZ,EAAAvS,EAAA3G,QACA2G,EAAA3G,MAAAkZ,EAMAD,GAAA1e,EAAAyZ,MAAA5T,SAEA7F,EAAAyZ,MAAA5T,SAAAuG,EAAAvG,SAEAuG,EAAA1G,OAAAuH,GAAAhN,EAAA2G,IAAA5G,EAAA,aAAAye,EAAAtQ,OAAA/B,EAAAyS,WAEA7e,EAAAyZ,MAAA5T,SAAA6Y,GAKA,QAAAI,IAAAhR,EAAA1B,GACA,GAQAqS,GAAAM,EAAAvL,EACAnS,EAAA2d,EAAAhT,EATAiT,EAAAxR,OAAArB,EAAA/K,MAEA0E,EAAAqG,EAAArG,SAEAmZ,EAAAD,EAAAE,MAAA,MAEAC,IAMA,KAAA5L,EAAA,EAAAA,EAAA0L,EAAA/Q,OAAAqF,GAAA,EAAA,CAUA,GARAnS,EAAA6d,EAAA1L,GAEAwL,EAAA3d,EAAA8d,MAAA,KACAV,KACAM,EAAA,GAIA,IAAAC,EAAA7Q,QAAAL,EAAAuK,YAAAhX,GAAAoE,MAAAM,EAGA0Y,GAAApd,OAEA,CAGA,IAAA2K,EAAA,EAAAA,EAAAgT,EAAA7Q,OAAAnC,GAAA,EAGA8B,EAAAuK,YAAA0G,EAAAC,EAAAhT,IAAAvG,MAAAM,IAEA,KAAAgZ,GACAN,EAAAxQ,KAAA8Q,GAGAA,EAAA,IAGAA,GAAAC,EAAAhT,GAEAA,IAAAgT,EAAA7Q,OAAA,IACA4Q,GAAA,IAIAN,GAAAxQ,KAAA8Q,GAIAK,EAAAA,EAAAC,OACAZ,EACAzE,KAAA,MACApR,QAAA,eAAA,MACAuW,MAAA,OAKA,MAAAC,GAjkHA,GASAE,IATAjV,GAAAT,EAAAS,SACAkV,GAAA3V,EAAA2V,MACAC,GAAA5V,EAAA4V,MACAC,GAAA7V,EAAA6V,iBACA5iB,GAAA+M,EAAA/M,KACAmQ,GAAApD,EAAAoD,OACAC,GAAArD,EAAAqD,WAKAR,GAAAxM,EAAAyf,OACArI,GAAApX,EAAAoX,QACAxK,GAAA,SAAAD,GACA,MAAAP,QAAA3D,UAAAiX,SAAApT,KAAAK,GACA5O,MAAA,MAAA4hB,eAEAnR,GAAAxO,EAAAwO,WACAwK,GAAAhZ,EAAAgZ,cAEA/b,GAAAL,GAAAK,GACA6c,GAAAld,GAAAkd,MACA9C,GAAApa,GAAAoa,IACAsE,GAAA1e,GAAA0e,IACAD,GAAAze,GAAAye,IACAte,GAAAH,GAAAG,MAEA6iB,GAAAL,GAAA9W,UAAA1K,MAEA8hB,GAAA7f,EAAAyS,MAAAqN,IAEA5H,MAEAnG,IACAD,aACA6M,aACAoB,eAGA5R,IACAiD,OAAA,EACAG,OAAA,EACAC,OAAA,EACAG,WAAA,EACAC,WAAA,EAEAjE,UAGAhH,MACAkR,IACA,YACA,YACA,UACA,YACA,WACA,aACA,YACA,YAkBA1E,IAEAT,UAEAN,cAEA4N,UAOAzT,GAAAE,cACAwT,MAAA,SACAtD,WAAA,GACAD,YAAA,EACAvM,UAAA,EACA+P,SAAA,SACA5K,cAAA,EACA2G,KAAA,EACAxL,QAAA,EACAV,YAAA,cACAoQ,UAAA,EACAza,aAAA,EACA0a,MAAA,EACAC,gBAAA,EACAC,YAAA,KACAlN,QAAA,KACAwE,eAAA,EACAjV,WAAA,EACAwS,WAAA,KACA/U,OAAA,KACAyB,KAAA,KACAkU,GAAA,KACAC,GAAA,KACAzV,IAAA,IACAO,OAAA,KACAC,OAAA,KACAV,UAAA,cACAie,UAAA,SACA1Y,SAAA,OACAC,WAAA,aACAqL,YAAA,EACAzL,OAAA,KACAuK,gBAAA,EACAiB,WAAA,EACA0D,YAAA,EACA9N,MAAA,KACA0Z,cAAA,KACA3B,WAAA,EACA1e,OAAA,EACAC,MAAA,EACA2F,SAAA,KACAkJ,WAAA,GACArO,KAAA,KACAkP,QAAA,EACA2Q,GAAA,KACAC,GAAA,KACArjB,OAAA,EACAsjB,OAAA,SACAC,cAAA,EACA1K,mBAAA,KACA7E,OAAA,EACAzC,SAAA,EACA2C,MAAA,EACAC,OAAA,EACAC,OAAA,EACAjQ,WAAA,EACAC,YAAA,cACAmP,cAAA,EACAlB,QAAA,EACAE,QAAA,EACAiR,QAAA,KACAC,MAAA,EACAC,OAAA,GACAC,OAAA,EACAzgB,MAAA,EACAwO,UAAA,OACAG,WAAA,KACAM,iBAAA,EACAR,WAAA,QACAvO,YAAA,cACAC,YAAA,EACAugB,OAAA,KACAC,GAAA,KACAC,GAAA,KACA9f,KAAA,GACAsQ,UAAA,EACAC,WAAA,EACAC,WAAA,EACA1H,KAAA,KACA4K,SAAA,EACAtP,MAAA,KACAnJ,EAAA,EACAC,EAAA,GAEA+iB,GAAA,GAAA9S,GACAP,EAAAvD,UAAA4W,GA0OAlM,GAAAsM,OAAA,SAAA0B,GAiCA,MA9BAA,GAAAxgB,OAEAwgB,EAAA/T,OACAZ,GAAA6S,GAAA8B,EAAA/T,OAGApN,EAAAiY,GAAAkJ,EAAAxgB,MAAA,QAAAygB,GAAAnV,GACA,GAAAlM,GAAAgJ,EAAA8E,EACA1B,EADAkV,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAhJ,EAAAshB,EAAAtY,GACA8E,EAAAZ,EAAAlN,GACA8N,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAA/X,EAAAoM,EAAAF,EAAAmV,GAEA3S,EAAA1O,EAAA8N,EAAA1B,GACAgV,EAAAlJ,GAAA3L,KAAAvM,EAAA8N,EAAA1B,GAIA,OAAAkV,IAGAF,EAAAjX,OACAgO,GAAAC,SAAAgJ,EAAAjX,MAAAiX,EAAAxgB,OAGAX,EAAAiY,GAAAkJ,EAAAxgB,OAsPAX,EAAAiY,GAAAqJ,cAAA,WACA,GAAAvhB,GAAA8B,EAAAwf,EAAApY,KACAmJ,IAOA,OALA,KAAAiP,EAAAnT,SACAnO,EAAAshB,EAAA,GACAxf,EAAAiP,EAAA/Q,GACAqS,EAAAvQ,EAAAuQ,YAEAA,GAIApS,EAAAiY,GAAAsJ,cAAA,SAAAnP,GACA,GAAArJ,GACAlH,EADAwf,EAAApY,IAEA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAlH,EAAAiP,EAAAuQ,EAAAtY,IACAyD,GAAA3K,EAAAuQ,WAAAA,EAEA,OAAAiP,IAIArhB,EAAAiY,GAAAhR,UAAA,SAAAua,GACA,GAAAzhB,GAAA8B,EACAqQ,EAAAhS,EAAAqT,EADA8N,EAAApY,KAEAwY,IAEA,IAAA,IAAAJ,EAAAnT,OAQA,GANAnO,EAAAshB,EAAA,GACAxf,EAAAiP,EAAA/Q,GAEAmS,EAAArQ,EAAAqQ,OAGA1D,GAAAgT,GAGA,IAAAjO,EAAA,EAAAA,EAAArB,EAAAhE,OAAAqF,GAAA,EACArT,EAAAgS,EAAAqB,GACAiO,EAAAlV,KAAAvM,EAAAG,IAEAuhB,EAAAzT,KAAA9N,OAOAuhB,GAAAvP,CAKA,OAAAuP,IAIAzhB,EAAAiY,GAAAvU,SAAA,SAAAge,GACA,GAAA3hB,GACA8B,EAAAqQ,EAAAhS,EAAAqT,EACAoO,EAFAN,EAAApY,IAIA,IAAA,IAAAoY,EAAAnT,OAOA,GALAnO,EAAAshB,EAAA,GACAxf,EAAAiP,EAAA/Q,GACAmS,EAAArQ,EAAAqQ,OACAyP,EAAA/U,GAAA8U,GAEAA,GAAAA,EAAAxhB,MAGAA,EAAAwhB,MAEA,IAAA,WAAAC,EAKAD,EAAA,IACAA,EAAAxP,EAAAhE,OAAAwT,GAGAxhB,EAAAgS,EAAAwP,OAEA,IAAA,WAAAC,GAGA,IAAApO,EAAA,EAAAA,EAAArB,EAAAhE,OAAAqF,GAAA,EAEA,GAAA7G,EAAAwF,EAAAqB,GAAA5S,OAAAuR,EAAAqB,GAAA5S,KAAA3C,MAAA0jB,GAAA,CACAxhB,EAAAgS,EAAAqB,EACA,YAOArT,GAAA2B,EAAA3B,MAAAiS,MAAAuP,EAKA,OAAAxhB,IAIAF,EAAAiY,GAAAxQ,cAAA,SAAAma,GACA,GAAA7hB,GAAA8B,EACAzB,EAAAgU,EAAAD,EADAkN,EAAApY,KAEA0Y,EAAA/U,GAAAgV,EAEA,IAAA,IAAAP,EAAAnT,OAIA,GAFAnO,EAAAshB,EAAA,GAEA,UAAAM,EAGAxN,EAAAyN,MAEA,IAAA,WAAAD,EAAA,CAGA9f,EAAAiP,EAAA/Q,GACAK,EAAAyB,EAAA3B,MAAAE,MAEA,KAAAgU,IAAAhU,GAEA,GAAAgU,EAAApW,MAAA4jB,GAAA,CACAzN,EAAA/T,EAAAgU,EAEA,YAOAvS,GAAAiP,EAAA/Q,GACAoU,EAAAtS,EAAA3B,MAAAE,OAAAwhB,EAIA,OAAAzN,IAIAnU,EAAAiY,GAAA4J,cAAA,SAAAH,GACA,GAAAL,GAAApY,KACAiJ,EAAAmP,EAAApa,YACA/G,EAAAmhB,EAAA3d,SAAAge,EAEA,OAAAtK,IAAAlX,EAAAgS,IAIAlS,EAAAiY,GAAAvW,SAAA,SAAAggB,EAAAtU,GACA,GAAA6F,GAAAlK,EACAlH,EAAA3B,EACAgM,EAAAoB,EAAAD,EAFAgU,EAAApY,IAIA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAKA,GAJAkK,EAAAjT,EAAAqhB,EAAAtY,IACAlH,EAAAiP,EAAAuQ,EAAAtY,IAEA7I,EAAAF,EAAAqhB,EAAAtY,IAAArF,SAAAge,GACA,CAGA1N,EAAAf,EAAApR,EAAA3B,EAAAkN,GACA8G,EAAAjB,EAAApR,EAAA3B,EAAAkN,GAEAD,EAAAC,EAGA,KAAAlB,IAAAkB,GACAhB,OAAA3D,UAAA4D,eAAAC,KAAAc,EAAAlB,KACAoB,EAAAF,EAAAlB,GACAmB,EAAAT,GAAAU,GACA,WAAAD,GAAA2L,GAAA1L,IAEApN,EAAAgM,GAAAM,MAAAc,GACAH,EAAAjN,EAAAgM,KACA,UAAAmB,EAEAnN,EAAAgM,GAAAoB,EAAAvP,MAAA,GACA,WAAAsP,EACA,IAAAC,EAAA4L,QAAA,MAEAhZ,EAAAgM,IAAAc,GAAAM,EAAAwU,OAAA,IACA,IAAAxU,EAAA4L,QAAA,MAEAhZ,EAAAgM,IAAAc,GAAAM,EAAAwU,OAAA,KACAhV,MAAAQ,IAAAT,EAAAS,IAAA,SAAApB,EAEAhM,EAAAgM,GAAAc,GAAAM,GAGApN,EAAAgM,GAAAoB,EAIApN,EAAAgM,GAAAoB,EAMA0F,GAAAC,EAAApR,EAAA3B,GACA4T,EAAAb,EAAApR,EAAA3B,GAGAF,EAAA+hB,cAAA3U,MAAA,GACAoG,EAAAP,EAAApR,EAAA3B,EAAA,SAAAkN,GAKA,MAAAiU,IAIArhB,EAAAiY,GAAA+J,UAAA,SAAA5U,EAAAoU,GACA,GAAAvO,GAAAlK,EACAmJ,EAAAqB,EADA8N,EAAApY,IAEA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAKA,IAJAkK,EAAAjT,EAAAqhB,EAAAtY,IAEAmJ,EAAAe,EAAAhM,UAAAua,GAEAjO,EAAA,EAAAA,EAAArB,EAAAhE,OAAAqF,GAAA,EAEAN,EAAAvR,SAAAwQ,EAAAqB,GAAAnG,EAGA,OAAAiU,IAIArhB,EAAAiY,GAAAgK,cAAA,SAAAL,EAAAxU,GACA,GAAA6F,GAAAlK,EACAoL,EAAAZ,EADA8N,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAMA,GAJAkK,EAAAjT,EAAAqhB,EAAAtY,IAEAoL,EAAAlB,EAAAxL,cAAAma,GAKA,IAAArO,EAAA,EAAAA,EAAAY,EAAAjG,OAAAqF,GAAA,EAEAN,EAAAvR,SAAAyS,EAAAZ,GAAAnG,EAKA,OAAAiU,IAIArhB,EAAAiY,GAAAlR,UAAA,SAAA2a,EAAA7a,GACA,GAAAoM,GAAAlK,EACAlH,EAAAqQ,EAAAhS,EADAmhB,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACAlH,EAAAiP,EAAAuQ,EAAAtY,IAGAmJ,EAAArQ,EAAAqQ,OACAhS,EAAA+S,EAAAvP,SAAAge,GACAxhB,IAGAA,EAAA2G,MAAAuQ,GAAAlX,EAAAgS,GAGAA,EAAAqC,OAAArU,EAAA2G,MAAA,GAEAqL,EAAAqC,OAAA1N,EAAA,EAAA3G,GAGA2G,EAAA,IACAA,EAAAqL,EAAAhE,OAAArH,GAGA3G,EAAA2G,MAAAA,EAEA2M,EAAAP,EAAApR,EAAA3B,EAAA,QAIA,OAAAmhB,IAIArhB,EAAAiY,GAAA5P,YAAA,SAAAqZ,GACA,GAAAzO,GAAAlK,EAAAlH,EACAqQ,EAAAhS,EADAmhB,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACAlH,EAAAiP,EAAAuQ,EAAAtY,IAGAmJ,EAAAe,EAAAhM,YACA/G,EAAA+S,EAAAvP,SAAAge,GAEAxhB,IAGAA,EAAA2G,MAAAuQ,GAAAlX,EAAAgS,GAEAA,EAAAqC,OAAArU,EAAA2G,MAAA,SACA3G,GAAA8X,OAGAhE,EAAAf,EAAApR,EAAA3B,GACAS,KAAA,OAGAuT,EAAAjB,EAAApR,EAAA3B,GACAE,OAAA,OAIAoT,EAAAP,EAAApR,EAAA3B,EAAA,UAIA,OAAAmhB,IAIArhB,EAAAiY,GAAAiK,aAAA,SAAAV,GACA,GAAAvO,GAAAlK,EACAlH,EAAAqQ,EAAAhS,EAAAqT,EADA8N,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAAA,CAKA,IAJAkK,EAAAjT,EAAAqhB,EAAAtY,IACAlH,EAAAiP,EAAAuQ,EAAAtY,IACAmJ,EAAAe,EAAAhM,UAAAua,GAEAjO,EAAA,EAAAA,EAAArB,EAAAhE,OAAAqF,GAAA,EACArT,EAAAgS,EAAAqB,GACAN,EAAA5K,YAAAnI,GAEAqT,GAAA,CAGA1R,GAAA3B,MAAAiS,SACAtQ,EAAA3B,MAAAE,UAEA,MAAAihB,IAIArhB,EAAAiY,GAAA1T,iBAAA,SAAAqd,GACA,GAAA3O,GAAAlK,EAAAoL,EAAAZ,EAAA8N,EAAApY,IAEA,IAAAsE,SAAAqU,EACA,IAAA7Y,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAKA,GAJAkK,EAAAjT,EAAAqhB,EAAAtY,IAEAoL,EAAAlB,EAAAxL,cAAAma,GAQA,IAHAzN,EAAAA,EAAApW,MAAA,GAGAwV,EAAA,EAAAA,EAAAY,EAAAjG,OAAAqF,GAAA,EACAN,EAAA5K,YAAA8L,EAAAZ,GAMA,OAAA8N,IAIArhB,EAAAiY,GAAAkK,gBAAA,SAAAT,EAAAtN,GACA,GAAAnB,GAAAlK,EACA7I,EADAmhB,EAAApY,KACA7I,GAAAgU,EAEA,KAAArL,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACA7I,EAAA+S,EAAAvP,SAAAge,GAGAxhB,EAAAE,SAEAA,EAAAF,EAAAE,OAAArC,MAAA,GAEAqZ,GAAAhD,EAAAlU,EAAAE,cAEAA,EAAA4N,KAAAoG,IAIAnB,EAAAvR,SAAAxB,GACAE,OAAAA,GAIA,OAAAihB,IAIArhB,EAAAiY,GAAAmK,qBAAA,SAAAV,EAAAtN,GACA,GAAAnB,GAAAlK,EACA7I,EACA2G,EAFAwa,EAAApY,KACA7I,IAGA,KAAA2I,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACA7I,EAAA+S,EAAAvP,SAAAge,GAEAxhB,EAAAE,SAGAyG,EAAAuQ,GAAAhD,EAAAlU,EAAAE,QAGAyG,SAGAzG,EAAAF,EAAAE,OAAArC,MAAA,GAGAqC,EAAAmU,OAAA1N,EAAA,GAGAoM,EAAAvR,SAAAxB,GACAE,OAAAA,KAQA,OAAAihB,IA8NA1a,GAAAyM,SAAA,OAAA,WAAA,UAAA,YAKAzM,GAAA0Q,OAAA,WACA,GAAAgL,GAAA7C,GAAApV,GAAAkY,gBAAA,IACAC,GAAA3C,GACAtT,KAAA+V,GACAtI,KAAA,IACA/b,MAAA,sBAAA,KAAAqkB,EAAAG,QAAA,GAAA,MACA,EACA,OAAA,IAAAD,EAAA,OAyEAviB,EAAAiY,GAAAvE,kBAAA,SAAAxT,EAAAgV,GACA,GAAAjC,GAAAlK,EACAlH,EADAwf,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACAlH,EAAAiP,EAAAuQ,EAAAtY,IACA7I,EAAA+S,EAAAvP,SAAAxD,GACAA,GACAsT,EAAAP,EAAApR,EAAA3B,EAAAgV,EAGA,OAAAmM,IAIArhB,EAAAiY,GAAAtW,UAAA,SAAA+f,GACA,GAAA3Y,GAAA8E,EACAoF,EAAA/S,EADAmhB,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IACA3N,EAAA+S,EAAAvP,SAAAge,GACA9M,EAAA3B,EAAApF,EAAA3N,GAGA,OAAAmhB,IAIArhB,EAAAiY,GAAAtE,WAAA,SAAA1H,GACA,GAAAgH,GAAAlK,EAAA8E,EAIAqE,EAAAhS,EAAAuiB,EAAAlP,EAAA1M,EAAA6b,EACA7gB,EAAA6Y,EAAAxF,EAAAyN,EALAtB,EAAApY,KAEAkD,EAAAF,KAWA,KALApF,EAAAsF,EAAAtF,MACAA,IACAA,EAAA,GAGAkC,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAGA,GAFAkK,EAAAjT,EAAAqhB,EAAAtY,IACA8E,EAAAZ,EAAAoU,EAAAtY,IACA,CAaA,IAXAlH,EAAAiP,EAAAuQ,EAAAtY,IAGAoD,EAAAyW,SAAA,GACA3P,EAAA4P,cAIA3Q,EAAArQ,EAAAqQ,OAGAqB,EAAA1M,EAAA0M,EAAArB,EAAAhE,OAAAqF,GAAA,EAgBA,GAfArT,EAAAgS,EAAAqB,GAGArT,EAAA2G,MAAA0M,EAGApH,EAAA2O,YACA5a,EAAA4iB,QAAA,GAGAlO,EAAA3B,EAAApF,EAAA3N,EAAAqT,EAAA,GAEArT,EAAAuU,OAAA5S,EAAA6L,WAAAC,MAAA5P,MAAA,GAGAmC,EAAA6U,UAAA/U,EAAAiY,GAAA8K,WAAA7iB,EAAA4U,QAAA,CACA6N,GAAA,CACA,OAMA,GAAAA,EAEA,KAIAD,GAAAnP,EAGArT,EAAAsU,EAAA3S,GAEA6Y,EAAA7Y,EAAA4Q,MACAyC,EAAAwF,EAAAxQ,KAGArI,EAAA4C,KAAAvE,OAEA+U,EAAAhC,EAAApR,EAAAqT,GAIAuN,EAAA5gB,EAAAyQ,gBACA,OAAAmQ,GAAAviB,IAAAuiB,IAAAA,EAAAhP,UAAAgP,EAAAK,QAAAjhB,EAAA4C,KAAA+N,WAEA3Q,EAAAyQ,gBAAA,KACAmQ,EAAAK,QAAA,EACAL,EAAAhP,UAAA,EACAD,EAAAP,EAAApR,EAAA4gB,EAAA,YACAnL,EAAArE,EAAApR,IAIA3B,IAGAA,EAAAgV,KACAA,EAAAoF,EAAApF,IAIAhV,EAAA2T,QAAA3T,EAAAwU,aAEA7S,EAAAyQ,gBAAApS,GAGAA,EAAAwE,WAAAxE,EAAAuB,UAAAvB,EAAAkT,WAAAvR,EAAA4C,KAAA+N,WAEAtS,EAAAuT,UAAAvT,EAAA4iB,SAGA5iB,EAAA4iB,QAAA,EACA5iB,EAAAuT,UAAA,EACAD,EAAAP,EAAApR,EAAA3B,EAAA,eAOAA,EAAA4iB,SAGA5iB,EAAA4iB,QAAA,EACApI,EAAAxQ,KAAA,KAEAsJ,EAAAP,EAAApR,EAAA3B,EAAAgV,KAKAhV,EAAAyC,WAAAzC,EAAA0X,eAAA,cAAA1C,GAAA,eAAAA,IAGArT,EAAA4C,KAAAvE,MAAAA,EACA2B,EAAAqV,0BAAArV,EAAAkR,kBACAlR,EAAAkR,mBAAA,KASA,OAAA7S,GAAA2B,EAAA4C,KAAA+N,UAEA8E,EAAArE,EAAApR,GAIA6gB,IAAAxQ,EAAAhE,SAGArM,EAAAwQ,aAAAnE,OAAA,EAEArM,EAAA6L,WAAAD,EAAAU,IACAtM,EAAAkM,gBAAAG,OAAA,GAMA,MAAAmT,IA6GArhB,EAAAiY,GAAA+K,SAAA,SAAA/W,GACA,GAAAlD,GAAA8E,EACA1B,EADAkV,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACAE,EAAAjM,OAAA,EACA4X,EAAAuJ,EAAAtY,GAAAoD,EAAAF,GAIA,OAAAoV,IAMA1a,GAAAyG,OACA,QACA,SACA,UACA,cAEAzG,GAAAgS,YAsJA3Y,EAAAiY,GAAAgL,aAAA,WA+CA,QAAAC,GAAAjQ,EAAApR,EAAA3B,GAEA,MAAA,YAEAmY,EAAAnY,GACA+Y,EAAA/Y,GAGA2B,EAAA8Q,WAAA9Q,EAAA+Q,WAAA1S,GAEA+S,EAAAU,aAIAzT,EAAAijB,YAAA,EACAthB,EAAA8Q,WAAA,EACA9Q,EAAA+Q,SAAA,KAGA3G,EAAA,IAEAA,EAAA,GAAAK,KAAA2G,EAAA,GAAA/S,GAGAsT,EAAAP,EAAApR,EAAA3B,EAAA,eAOA,QAAAia,GAAAlH,EAAApR,EAAA3B,GAEA,MAAA,UAAA0Z,EAAAF,GACA,GAAA0J,GAAAlX,EAAA4M,EACAuK,GAAA,CAGA,OAAA3J,EAAAO,KAAA,KACAoJ,GAAA,EAEA3J,EAAAO,KAAAP,EAAAO,KAAAtR,QAAA,IAAA,IACAzI,EAAAwZ,EAAAO,MAAA/Z,EAAA,IAAAwZ,EAAAO,OAIAP,EAAAO,KAAAf,QAAA,YACAkK,EAAA1J,EAAAO,KAAAiF,MAAA,KACAhT,EAAAkX,EAAA,GACAtK,EAAAsK,EAAA,GACAljB,EAAAgM,KACAhM,EAAAgM,GAAA4M,GAAAY,EAAAE,MAKA1Z,EAAAojB,OAAA5J,EAAAG,MAEA3Z,EAAAojB,KAAA5J,EAAAG,IAGA3Z,EAAAijB,YAAAthB,EAAA8Q,YACAzS,EAAAijB,YAAA,EACAthB,EAAA8Q,WAAA,EACA9Q,EAAA+Q,SAAA1S,GAIA2B,EAAA8Q,WAAA9Q,EAAA+Q,WAAA1S,GAEA+S,EAAAU,cAMA1H,EAAA,IAEAA,EAAA,GAAAK,KAAA2G,EAAA,GAAA2G,EAAAF,EAAAxZ,GAGAsT,EAAAP,EAAApR,EAAA3B,EAAA,UAAAwZ,GAGA2J,IAEA3J,EAAAO,KAAA,IAAAP,EAAAO,OApIA,GAAAhH,GAAAlK,EAAA8E,EAEAhM,EAAA3B,EAAAkN,EAFAiU,EAAApY,KACAgD,EAAA2T,GAAAtT,KAAAiX,UAAA,EA0IA,KA7HA,WAAA3W,GAAAX,EAAA,KAGAA,EAAAsI,OAAA,EAAA,EAAAtI,EAAA,GAAAuX,UAAA,MACAvX,EAAAsI,OAAA,EAAA,EAAAtI,EAAA,GAAAwX,QAAA,MACAxX,EAAAsI,OAAA,EAAA,EAAAtI,EAAA,GAAAiX,UAAA,MACAjX,EAAAsI,OAAA,EAAA,EAAAtI,EAAA,GAAAkO,MAAA,QAIA5M,SAAAtB,EAAA,IAEAA,EAAAsI,OAAA,EAAA,EAAA,MACAtI,EAAAsI,OAAA,EAAA,EAAA,MACAtI,EAAAsI,OAAA,EAAA,EAAA,OACA/F,GAAAvC,EAAA,MAEAA,EAAAsI,OAAA,EAAA,EAAA,MACAtI,EAAAsI,OAAA,EAAA,EAAA,OAEAhH,SAAAtB,EAAA,IAEAA,EAAA,GAAA,KACAA,EAAAsI,OAAA,EAAA,EAAA,OACA/F,GAAAvC,EAAA,KAEAA,EAAAsI,OAAA,EAAA,EAAA,OAmGAxL,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEAhM,EAAAiP,EAAAuQ,EAAAtY,IAGA7I,EAAA+S,EAAAvP,SAAAuI,EAAA,IAGA/L,GAAAA,EAAA6U,UAAA/U,EAAAiY,GAAAyL,OAGAtW,EAAAZ,MAAAP,EAAA,IAEAmB,EAAAwL,EAAAyI,EAAAtY,GAAA7I,EAAAkN,GAGAqL,EAAArL,GAAA,GACAqL,EAAAvY,GAGAA,EAAAsZ,MAAA7S,GAAAgS,SAGA3Y,EAAAE,GAAAyjB,QAAAvW,GACAoW,SAAAvX,EAAA,GACAwX,OAAAzjB,EAAAyjB,OAAAxX,EAAA,IAAAA,EAAA,GAAA,KAEAiX,SAAAA,EAAAjQ,EAAApR,EAAA3B,GAEAia,KAAAA,EAAAlH,EAAApR,EAAA3B,KAEAsT,EAAAP,EAAApR,EAAA3B,EAAA,iBAKA,OAAAmhB,IAIArhB,EAAAiY,GAAA2L,kBAAA,SAAAhC,GACA,GAAA3O,GAAAlK,EAEAoL,EAAAZ,EAFA8N,EAAApY,KACAgD,EAAA2T,GAAAtT,KAAAiX,UAAA,EAEA,KAAAxa,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAGA,GAFAkK,EAAAjT,EAAAqhB,EAAAtY,IACAoL,EAAAlB,EAAAxL,cAAAma,GAIA,IAAArO,EAAA,EAAAA,EAAAY,EAAAjG,OAAAqF,GAAA,EAGAtH,EAAA,GAAAkI,EAAAZ,GACAN,EAAAgQ,aAAAY,MAAA5Q,EAAAhH,EAMA,OAAAoV,IAIArhB,EAAAiY,GAAA6L,WAAA,SAAApC,EAAA8B,GACA,GAAAvQ,GAAAlK,EACAlH,EAAA3B,EADAmhB,EAAApY,IAIA,KAFAua,EAAAA,GAAA,EAEAza,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACAlH,EAAAiP,EAAAuQ,EAAAtY,IACA7I,EAAA+S,EAAAvP,SAAAge,GAEAxhB,IAEAF,EAAAE,GAAA6jB,MAAAP,GACAhQ,EAAAP,EAAApR,EAAA3B,EAAA,SAGA,OAAAmhB,IAIArhB,EAAAiY,GAAA+L,gBAAA,SAAApC,EAAA4B,GACA,GAAAvQ,GAAAlK,EACAoL,EAAAjU,EAAAqT,EADA8N,EAAApY,IAIA,KAFAua,EAAAA,GAAA,EAEAza,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAKA,GAJAkK,EAAAjT,EAAAqhB,EAAAtY,IAEAoL,EAAAlB,EAAAxL,cAAAma,GAIA,IAAArO,EAAA,EAAAA,EAAAY,EAAAjG,OAAAqF,GAAA,EAEArT,EAAAiU,EAAAZ,GACAN,EAAA6Q,WAAA5jB,EAAAsjB,EAKA,OAAAnC,IAIArhB,EAAAiY,GAAAgM,UAAA,SAAAvC,EAAAwC,GACA,GAAAjR,GAAAlK,EACAlH,EAAA3B,EADAmhB,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAkK,EAAAjT,EAAAqhB,EAAAtY,IACAlH,EAAAiP,EAAAuQ,EAAAtY,IACA7I,EAAA+S,EAAAvP,SAAAge,GAEAxhB,IAEAF,EAAAE,GAAAikB,KAAAD,GACA1Q,EAAAP,EAAApR,EAAA3B,EAAA,QAGA,OAAAmhB,IAIArhB,EAAAiY,GAAAmM,eAAA,SAAAxC,EAAAsC,GACA,GAAAjR,GAAAlK,EACAoL,EAAAjU,EAAAqT,EADA8N,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAKA,GAJAkK,EAAAjT,EAAAqhB,EAAAtY,IAEAoL,EAAAlB,EAAAxL,cAAAma,GAIA,IAAArO,EAAA,EAAAA,EAAAY,EAAAjG,OAAAqF,GAAA,EAEArT,EAAAiU,EAAAZ,GACAN,EAAAgR,UAAA/jB,EAAAgkB,EAKA,OAAA7C,IAYAnH,GACA,QACA,kBACA,cACA,iBACA,mBACA,oBACA,kBACA,YACA,eACA,cACA,gBAMAhC,GAAAmC,aACAgK,UAAA,aACAC,QAAA,WACAC,UAAA,aAGArM,GAAAqC,aACAiK,WAAA,YACAC,SAAA,UACAC,UAAA,aAsEA1J,GACA,QACA,WACA,YACA,UACA,YACA,YACA,WACA,aACA,YACA,WACA,cACA,cACA,YACA,gBA4DAhb,EAAAyS,MAAAqN,IAAA,SAAArN,GACA,GAAAkS,GAAAC,EAAAC,CAMA,IAJApS,EAAAoN,GAAAvT,KAAAtM,EAAAyS,MAAAA,GACAmS,EAAAnS,EAAAmS,cAQA,GAHAC,EAAAD,EAAAE,eAGAvX,SAAAkF,EAAAsS,OAAAxX,SAAAkF,EAAAkI,QACA,IACAgK,EAAA3kB,EAAAyS,EAAAuS,eAAAL,SACAA,IACAlS,EAAAkI,QAAAlI,EAAAsS,MAAAJ,EAAAM,KACAxS,EAAAmI,QAAAnI,EAAAyS,MAAAP,EAAAQ,KAEA,MAAA1a,QAGA,IAAAoa,EACA,IAEAF,EAAA3kB,EAAAyS,EAAAuS,eAAAL,SACAA,IACAlS,EAAAkI,QAAAkK,EAAA,GAAAE,MAAAJ,EAAAM,KACAxS,EAAAmI,QAAAiK,EAAA,GAAAK,MAAAP,EAAAQ,KAEA,MAAA1a,IAMA,MAAAgI,IAMAyF,GAAAC,UACAgE,IAAA,UACAiJ,OAAA,aACAC,QAAA,cACAC,WAAA,OACAC,MAAA,YACAzG,KAAA,WACAnD,KAAA,WACA6J,QAAA,cACAznB,MAAA,YACA0nB,UAAA,gBACAC,UAAA,WACAtkB,KAAA,WACAukB,OAAA,aACA7X,KAAA,aACAM,QAAA,gBACAgD,OAAA,eACAE,MAAA,cACAI,UAAA,mBAIA1R,EAAAiY,GAAAyL,KAAA,QAAAA,IAAAzX,GACA,GAAAlD,GAAA8E,EAAAwT,EAAApY,KACAkD,EAAA,GAAAH,GAAAC,EAGA,IAAAiM,GAAAC,SAAAhM,EAAAjC,OAAA,aAAAiC,EAAAjC,KAEAmX,EAAAnJ,GAAAC,SAAAhM,EAAAjC,OAAA+B,OAIA,KAAAlD,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAyX,IACAvX,EAAA2I,SAEA3I,EAAA8L,IAEA9L,EAAA8L,GAAA3L,KAAA+U,EAAAtY,GAAA8E,EAAA1B,GASA,OAAAkV,IAIArhB,EAAAiY,GAAA4K,YAAA,QAAAA,IAAA5W,GACA,GAAAlD,GAAA8E,EAAAwT,EAAApY,KACAkD,EAAA,GAAAH,GAAAC,EAEA,KAAAlD,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA,OAAA1B,EAAA3G,OAAA,OAAA2G,EAAA1G,QAIAoI,EAAAC,OACAD,EAAA+X,aAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA/X,EAAAgY,UAAA,EAAA,EAAAxE,EAAAtY,GAAAvD,MAAA6b,EAAAtY,GAAAtD,QACAoI,EAAAO,YAMA0J,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA4W,IACA9R,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,EAAAA,EAAA3G,MAAA2G,EAAA1G,QACAoI,EAAAgY,UAAA1Z,EAAA9P,EAAA8P,EAAA3G,MAAA,EAAA2G,EAAA7P,EAAA6P,EAAA1G,OAAA,EAAA0G,EAAA3G,MAAA2G,EAAA1G,QAEA6K,EAAAzC,EAAA1B,IAMA,OAAAkV,IAMArhB,EAAAiY,GAAA6N,WAAA,QAAAA,IAAA7Z,GACA,GAAAlD,GAAA8E,EACA1B,EAAAtK,EAAAnD,EADA2iB,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAEA,GADA8E,EAAAZ,EAAAoU,EAAAtY,IASA,IANAlH,EAAAiP,EAAAuQ,EAAAtY,IAEAoD,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA6Z,IAGApnB,EAAA,EAAAA,EAAAyN,EAAAiU,MAAA1hB,GAAA,EACAkP,EAAAC,EAAAhM,EAKA,OAAAwf,IAIArhB,EAAAiY,GAAAvX,cAAA,QAAAA,IAAAuL,GACA,GAAAlD,GAAA8E,EACA1B,EAAAtK,EAAAnD,EADA2iB,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAEA,GADA8E,EAAAZ,EAAAoU,EAAAtY,IASA,IANAlH,EAAAiP,EAAAuQ,EAAAtY,IAEAoD,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAvL,IAGAhC,EAAA,EAAAA,EAAAyN,EAAAiU,MAAA1hB,GAAA,EACAuP,EAAAJ,EAAAhM,EAKA,OAAAwf,IA8DArhB,EAAAiY,GAAA8N,aAAA,QAAAA,IAAA9Z,GACA,GAAAlD,GAAA8E,EACA1B,EAAAtK,EADAwf,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEAhM,EAAAiP,EAAAuQ,EAAAtY,IAEAoD,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA8Z,IAGA5Z,EAAAgE,UAEAvC,EAAAC,EAAAhM,GAEAwP,EAAAxD,EAAA1B,EAAAtK,EAAA6L,YAIA,OAAA2T,IAIArhB,EAAAiY,GAAA+N,YAAA,QAAAA,IAAA/Z,GACA,GAAAlD,GAAA8E,EACA1B,EAAAtK,EADAwf,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEAhM,EAAAiP,EAAAuQ,EAAAtY,IAEAoD,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA+Z,IAGA7Z,EAAAgE,UAEAvC,EAAAC,EAAAhM,GAEA4P,EAAA5D,EAAA1B,EAAAtK,EAAA6L,YAIA,OAAA2T,IAIArhB,EAAAiY,GAAAgO,gBAAA,QAAAA,IAAAha,GACA,GAAAlD,GAAA8E,EACA1B,EAAAtK,EADAwf,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEAhM,EAAAiP,EAAAuQ,EAAAtY,IAEAoD,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAga,IAGA9Z,EAAAgE,UAEAvC,EAAAC,EAAAhM,GAEAgQ,EAAAhE,EAAA1B,EAAAtK,EAAA6L,YAIA,OAAA2T,IAMArhB,EAAAiY,GAAA1S,SAAA,QAAAA,IAAA0G,GACA,GAAAlD,GAAA8E,EACA1B,EACAnH,EAAAC,EACAC,EAAAC,EACAiR,EAAA8P,EAJA7E,EAAApY,IAMA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA1G,IACA4G,EAAA2I,UAEA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,EAAAA,EAAA3G,MAAA2G,EAAA1G,QACAgJ,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAEA0B,EAAAsY,YACAha,EAAA3G,OAAA2G,EAAA1G,SACAT,EAAAmH,EAAA9P,EAAA8P,EAAA3G,MAAA,EACAP,EAAAkH,EAAA7P,EAAA6P,EAAA1G,OAAA,EACA2Q,EAAAY,GAAA7K,EAAAzG,cAEA0Q,GAGAlR,EAAAiH,EAAA9P,EAAA8P,EAAA3G,MAAA,EACAL,EAAAgH,EAAA7P,EAAA6P,EAAA1G,OAAA,EAGA0G,EAAA3G,MAAA,IACA0gB,EAAAlhB,EACAA,EAAAE,EACAA,EAAAghB,GAGA/Z,EAAA1G,OAAA,IACAygB,EAAAjhB,EACAA,EAAAE,EACAA,EAAA+gB,GAIAhhB,EAAAF,EAAA,EAAAoR,EAAA,IACAA,GAAAlR,EAAAF,GAAA,GAEAG,EAAAF,EAAA,EAAAmR,EAAA,IACAA,GAAAjR,EAAAF,GAAA,GAIA4I,EAAA+O,OAAA5X,EAAAoR,EAAAnR,GACA4I,EAAAgP,OAAA3X,EAAAkR,EAAAnR,GACA4I,EAAAsO,IAAAjX,EAAAkR,EAAAnR,EAAAmR,EAAAA,EAAA,EAAAnZ,GAAA,EAAA,EAAAA,IAAA,GACA4Q,EAAAgP,OAAA3X,EAAAC,EAAAiR,GACAvI,EAAAsO,IAAAjX,EAAAkR,EAAAjR,EAAAiR,EAAAA,EAAA,EAAAnZ,GAAA,GAAA,GACA4Q,EAAAgP,OAAA7X,EAAAoR,EAAAjR,GACA0I,EAAAsO,IAAAnX,EAAAoR,EAAAjR,EAAAiR,EAAAA,EAAAnZ,GAAA,EAAAA,IAAA,GACA4Q,EAAAgP,OAAA7X,EAAAC,EAAAmR,GACAvI,EAAAsO,IAAAnX,EAAAoR,EAAAnR,EAAAmR,EAAAA,EAAAnZ,GAAA,EAAAA,GAAA,GAAA,GAEAkP,EAAAsE,QAAA,GAKA5C,EAAAuY,KAAAphB,EAAAC,EAAAkH,EAAA3G,MAAA2G,EAAA1G,SAKAyV,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAqE,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,IAIA,OAAAkV,IAqFArhB,EAAAiY,GAAA3W,QAAA,QAAAA,IAAA2K,GACA,GAAAlD,GAAA8E,EACA1B,EADAkV,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA3K,IACA6K,EAAA2I,UAEA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,EAAA,EAAAA,EAAA/O,QACAqR,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAEA0B,EAAAsY,YACAzK,EAAA2F,EAAAtY,GAAA8E,EAAA1B,EAAAA,GAEA+O,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAqE,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,IAMA,OAAAkV,IAIArhB,EAAAiY,GAAAoO,YAAA,QAAAA,IAAApa,GACA,GAAAlD,GAAA8E,EACA1B,EACAma,EACAC,EAHAlF,EAAApY,IAKA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAoa,IACAla,EAAA2I,UAEA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,EAAAA,EAAA3G,MAAA2G,EAAA1G,QACAgJ,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAGAma,EAAAna,EAAA3G,OAAA,EAAA,GACA+gB,EAAApa,EAAA1G,OAGAoI,EAAAsY,YACAtY,EAAA+O,OAAAzQ,EAAA9P,EAAA8P,EAAA7P,EAAAiqB,EAAA,GAEA1Y,EAAAmQ,cAAA7R,EAAA9P,EAAAiqB,EAAA,EAAAna,EAAA7P,EAAAiqB,EAAA,EAAApa,EAAA9P,EAAAiqB,EAAA,EAAAna,EAAA7P,EAAAiqB,EAAA,EAAApa,EAAA9P,EAAA8P,EAAA7P,EAAAiqB,EAAA,GAEA1Y,EAAAmQ,cAAA7R,EAAA9P,EAAAiqB,EAAA,EAAAna,EAAA7P,EAAAiqB,EAAA,EAAApa,EAAA9P,EAAAiqB,EAAA,EAAAna,EAAA7P,EAAAiqB,EAAA,EAAApa,EAAA9P,EAAA8P,EAAA7P,EAAAiqB,EAAA,GAEArL,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAA,EAAAsE,QAAA,EACAD,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,IAKA,OAAAkV,IAIArhB,EAAAiY,GAAAuO,YAAA,QAAAA,IAAAva,GACA,GAAAlD,GAAA8E,EACA1B,EACAsa,EAAAC,EAAAC,EACAC,EACAvqB,EAAAC,EAAAoC,EAJA2iB,EAAApY,IAMA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAEA,GADA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAua,IACAra,EAAA2I,SAAA,CAgBA,IAdA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,EAAA,EAAAA,EAAA/O,QACAqR,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAGAua,EAAA,EAAAzpB,GAAAkP,EAAA0U,MAEA8F,EAAAD,EAAA,EAEAD,EAAAE,EAAA1pB,GAAA,EAEA2pB,EAAAza,EAAA/O,OAAAie,GAAAsL,GAGA9Y,EAAAsY,YACAznB,EAAA,EAAAA,EAAAyN,EAAA0U,MAAAniB,GAAA,EAGArC,EAAA8P,EAAA9P,EAAA8P,EAAA/O,OAAAie,GAAAoL,GACAnqB,EAAA6P,EAAA7P,EAAA6P,EAAA/O,OAAAke,GAAAmL,GAGA5Y,EAAAgP,OAAAxgB,EAAAC,GAGA6P,EAAAgU,YAEA9jB,EAAA8P,EAAA9P,GAAAuqB,GAAAA,EAAAza,EAAAgU,WAAA9E,GAAAoL,EAAAE,GACArqB,EAAA6P,EAAA7P,GAAAsqB,GAAAA,EAAAza,EAAAgU,WAAA7E,GAAAmL,EAAAE,GACA9Y,EAAAgP,OAAAxgB,EAAAC,IAIAmqB,GAAAC,CAIAxL,GAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAA,EAAAsE,QAAA,EACAD,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,GAKA,MAAAkV,IAIArhB,EAAAiY,GAAAhY,UAAA,QAAAA,IAAAgM,GACA,GAAAlD,GAAA8E,EACA1B,EACAhK,EAAA4T,EAAAC,EAFAqL,EAAApY,IAIA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAhM,IACAkM,EAAA2I,UAEA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,EAAA,EAAAA,EAAA/O,QACAqR,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAKAA,EAAA7L,OAAA6L,EAAA6E,OACA7E,EAAA5L,KAAA4L,EAAA6E,OAEA7E,EAAA7L,OAAArD,GAAA,EACAkP,EAAA5L,KAAAtD,GAAA,EAGAkP,EAAA7L,MAAAib,EAAApP,EAAA7L,OACA6L,EAAA5L,IAAAgb,EAAApP,EAAA5L,KAEA4L,EAAA5L,IAAA4L,EAAA7L,QACA6L,EAAA5L,KAAA,EAAAtD,IAIAkF,GAAAgK,EAAA7L,MAAA6L,EAAA5L,KAAA,EAGAwV,EAAA5J,EAAA/O,OAAA+O,EAAA4U,OAAA1F,GAAAlZ,GACA6T,EAAA7J,EAAA/O,OAAA+O,EAAA4U,OAAAzF,GAAAnZ,GAGAgK,EAAA9P,GAAA0Z,EACA5J,EAAA7P,GAAA0Z,EAGAnI,EAAAsY,YACAtY,EAAAsO,IAAAhQ,EAAA9P,EAAA8P,EAAA7P,EAAA6P,EAAA/O,OAAA+O,EAAA7L,MAAA6L,EAAA5L,IAAA4L,EAAA8P,KACApO,EAAAgP,OAAA1Q,EAAA9P,EAAA8P,EAAA7P,GAEA4e,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAA,EAAAsE,QAAA,EACAD,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,IAMA,OAAAkV,IA+GArhB,EAAAiY,GAAAlT,SAAA,QAAAA,IAAAkH,GACA,GAAAlD,GAAA8E,EACA1B,EADAkV,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAlH,IACAoH,EAAA2I,UAEA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,GACAsC,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAGA0B,EAAAsY,YACAlJ,GAAAoE,EAAAtY,GAAA8E,EAAA1B,EAAAA,GAEA+O,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAqE,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,IAMA,OAAAkV,IAuDArhB,EAAAiY,GAAA4O,cAAA,QAAAA,IAAA5a,GACA,GAAAlD,GAAA8E,EACA1B,EADAkV,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA4a,IACA1a,EAAA2I,UAEA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,GACAsC,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAGA0B,EAAAsY,YACA/I,GAAAiE,EAAAtY,GAAA8E,EAAA1B,EAAAA,GAEA+O,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAqE,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,IAKA,OAAAkV,IA6DArhB,EAAAiY,GAAA6O,WAAA,QAAAA,IAAA7a,GACA,GAAAlD,GAAA8E,EACA1B,EADAkV,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA6a,IACA3a,EAAA2I,UAEA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,GACAsC,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAGA0B,EAAAsY,YACAzI,GAAA2D,EAAAtY,GAAA8E,EAAA1B,EAAAA,GAEA+O,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAqE,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,IAKA,OAAAkV,IAgFArhB,EAAAiY,GAAAlW,WAAA,QAAAA,IAAAkK,GACA,GAAAlD,GAAA8E,EACA1B,EADAkV,EAAApY,IAGA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAlK,IACAoK,EAAA2I,UAEA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,GACAsC,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAGA0B,EAAAsY,YACAhI,GAAAkD,EAAAtY,GAAA8E,EAAA1B,EAAAA,GAEA+O,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAqE,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,IAKA,OAAAkV,IAIArhB,EAAAiY,GAAA8O,SAAA,QAAAA,IAAA9a,GACA,GAAAlD,GAAA8E,EACA1B,EACAoH,EAAAyT,EAFA3F,EAAApY,IAIA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAEA,GADA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA8a,IACA5a,EAAA2I,SAAA,CAOA,IALA/D,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,GACAsC,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAEA0B,EAAAsY,YACA5S,EAAA,IACA,CAEA,GADAyT,EAAA7a,EAAA,IAAAoH,GACAhG,SAAAyZ,EAeA,KAdAA,GAAA,GAAAhb,GAAAgb,GACA,SAAAA,EAAA9c,KACA+S,GAAAoE,EAAAtY,GAAA8E,EAAA1B,EAAA6a,GACA,cAAAA,EAAA9c,KACAkT,GAAAiE,EAAAtY,GAAA8E,EAAA1B,EAAA6a,GACA,WAAAA,EAAA9c,KACAwT,GAAA2D,EAAAtY,GAAA8E,EAAA1B,EAAA6a,GACA,WAAAA,EAAA9c,KACAiU,GAAAkD,EAAAtY,GAAA8E,EAAA1B,EAAA6a,GACA,QAAAA,EAAA9c,MACAwR,EAAA2F,EAAAtY,GAAA8E,EAAA1B,EAAA6a,GAEAzT,GAAA,EAOA2H,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEAqE,EAAA6Q,EAAAtY,GAAA8E,EAAA1B,GAMA,MAAAkV,IA2HArhB,EAAAiY,GAAAtS,SAAA,QAAAA,IAAAsG,GACA,GAAAlD,GAAA8E,EACA1B,EAAAjM,EACAse,EAAAM,EAAAvL,EACA3N,EACAqhB,EAAAC,EAAAC,EAAAC,EACA/qB,EAAAC,EALA+kB,EAAApY,KAGAoe,EAAA,GAIA,KAAAte,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAEA,GADA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAAtG,IACAwG,EAAA2I,SAAA,CAoDA,GAjDAjH,EAAAyZ,aAAAnb,EAAA+T,SACArS,EAAA0Z,UAAApb,EAAA8T,MAGA7B,GAAAiD,EAAAtY,GAAA8E,EAAA1B,GAIAqS,EAFA,OAAArS,EAAArG,SAEA+Y,GAAAhR,EAAA1B,GAGAA,EAAA/K,KACAse,WACAR,MAAA,MAIAX,GAAA8C,EAAAtY,GAAA8E,EAAA1B,EAAAqS,GAGAte,IAEAA,EAAAsF,MAAA2G,EAAA3G,MACAtF,EAAAuF,OAAA0G,EAAA1G,QAGAsL,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,EAAAA,EAAA3G,MAAA2G,EAAA1G,QACAgJ,EAAA4S,EAAAtY,GAAA8E,EAAA1B,GAGA9P,EAAA8P,EAAA9P,EACA,SAAA8P,EAAA8T,MACA9T,EAAAwU,aAEAxU,EAAA9P,GAAA8P,EAAA3G,MAAA,EAGAnJ,GAAA8P,EAAA3G,MAAA,EAEA,UAAA2G,EAAA8T,QACA9T,EAAAwU,aAEAxU,EAAA9P,GAAA8P,EAAA3G,MAAA,EAGAnJ,GAAA8P,EAAA3G,MAAA,GAIA2G,EAAA/O,OAUA,IARAwI,EAAAoH,GAAAb,EAAAvG,UAGA,OAAAuG,EAAAoU,gBACApU,EAAAoU,cAAA3a,EAAAyhB,GAIA9T,EAAA,EAAAA,EAAAiL,EAAAtQ,OAAAqF,GAAA,EAAA,CAYA,IAXA1F,EAAAC,OACAD,EAAA6D,UAAAvF,EAAA9P,EAAA8P,EAAA7P,GACAwiB,EAAAN,EAAAjL,GACApH,EAAAqb,cACAN,EAAApI,EAAAI,MAAA,IACAgI,EAAAO,UACA3I,EAAAoI,EAAAnN,KAAA,KAEAkN,EAAAnI,EAAA5Q,OACAL,EAAAuD,SAAAnU,GAAAkP,EAAAoU,eAAA0G,EAAA,IAAA,GAEAG,EAAA,EAAAA,EAAAH,EAAAG,GAAA,EACAD,EAAArI,EAAAsI,GAEA,IAAAA,GAEAvZ,EAAAuD,OAAAnU,GAAAkP,EAAAoU,eAEA1S,EAAAC,OACAD,EAAA6D,UAAA,GAAAvF,EAAA/O,QACA+O,EAAAqb,aACA3Z,EAAAyD,aAEAzD,EAAA6Z,SAAAP,EAAA,EAAA,GAEA,gBAAAhb,EAAA9L,YACAwN,EAAArM,YAAA,eAEA,IAAA2K,EAAA1L,aAEAoN,EAAA8Z,WAAAR,EAAA,EAAA,GAEAtZ,EAAAO,SAEAjC,GAAA/O,QAAAwI,EACAuG,EAAAoU,eAAA3a,GAAA,EAAAyhB,EAAApqB,IACA4Q,EAAAO,cAMA,KAAAmF,EAAA,EAAAA,EAAAiL,EAAAtQ,OAAAqF,GAAA,EACAuL,EAAAN,EAAAjL,GAEAjX,EAAA6P,EAAA7P,EAAAiX,EAAApH,EAAA1G,OAAA+Y,EAAAtQ,QAAAsQ,EAAAtQ,OAAA,GAAA/B,EAAA1G,OAAA+Y,EAAAtQ,OAAA,EAEAL,EAAArM,YAAA2K,EAAA3K,YAGAqM,EAAA6Z,SAAA5I,EAAAziB,EAAAC,GAEA,gBAAA6P,EAAA9L,YACAwN,EAAArM,YAAA,eAEA,IAAA2K,EAAA1L,aAEAoN,EAAA8Z,WAAA7I,EAAAziB,EAAAC,EAQAA,GAAA,EACA,QAAA6P,EAAA+T,SACA5jB,GAAA6P,EAAA1G,OAAA,EACA,WAAA0G,EAAA+T,WACA5jB,GAAA6P,EAAA1G,OAAA,GAIA0G,EAAA0H,SACAhG,EAAAsY,YACAtY,EAAAuY,KACAja,EAAA9P,EAAA8P,EAAA3G,MAAA,EACA2G,EAAA7P,EAAA6P,EAAA1G,OAAA,EAAAnJ,EACA6P,EAAA3G,MACA2G,EAAA1G,QAEAyV,EAAAmG,EAAAtY,GAAA8E,EAAA1B,GAEA0B,EAAA6C,aAEAJ,EAAAzC,EAAA1B,GAOA,MADA4F,IAAA4M,UAAAxS,EACAkV,GAIArhB,EAAAiY,GAAAG,YAAA,SAAAnM,GACA,GAAA4B,GACA1B,EAAAqS,EADA6C,EAAApY,IA0BA,OAtBAkD,GAAAkV,EAAA3d,SAAAuI,KAEAE,GAAAA,IAAAA,EAAA6L,UACA7L,EAAA,GAAAH,GAAAC,IAGA4B,EAAAZ,EAAAoU,EAAA,IACAxT,IAGAuQ,GAAAiD,EAAA,GAAAxT,EAAA1B,GAGAqS,EADA,OAAArS,EAAArG,SACA+Y,GAAAhR,EAAA1B,GAEAA,EAAA/K,KAAA8d,MAAA,MAEAX,GAAA8C,EAAA,GAAAxT,EAAA1B,EAAAqS,IAKArS,GAMAnM,EAAAiY,GAAA8K,UAAA,QAAAA,IAAA9W,GAOA,QAAAyX,GAAA3jB,EAAA8N,EAAAhM,EAAAsK,EAAAjM,GAGA,OAAAiM,EAAA3G,OAAA,OAAA2G,EAAA6U,SACA7U,EAAA3G,MAAA2G,EAAA6U,OAAA4G,EAAApiB,OAGA,OAAA2G,EAAA1G,QAAA,OAAA0G,EAAAyU,UACAzU,EAAA1G,OAAA0G,EAAAyU,QAAAgH,EAAAniB,QAIAvF,IACAA,EAAAsF,MAAA2G,EAAA3G,MACAtF,EAAAuF,OAAA0G,EAAA1G,QAIA,OAAA0G,EAAA6U,QAAA,OAAA7U,EAAAyU,SAAA,OAAAzU,EAAA8U,IAAA,OAAA9U,EAAA+U,IAGA,OAAA/U,EAAA3G,QACA2G,EAAA3G,MAAA2G,EAAA6U,QAGA,OAAA7U,EAAA1G,SACA0G,EAAA1G,OAAA0G,EAAAyU,SAIAzU,EAAAkU,iBACAlU,EAAA8U,IAAA9U,EAAA6U,OAAA,EACA7U,EAAA+U,IAAA/U,EAAAyU,QAAA,GAMAzU,EAAA+U,GAAA/U,EAAAyU,QAAA,EAAA,IACAzU,EAAA+U,GAAA/U,EAAAyU,QAAA,GAGAzU,EAAA+U,GAAA/U,EAAAyU,QAAA,EAAAgH,EAAAniB,SACA0G,EAAA+U,GAAA0G,EAAAniB,OAAA0G,EAAAyU,QAAA,GAGAzU,EAAA8U,GAAA9U,EAAA6U,OAAA,EAAA,IACA7U,EAAA8U,GAAA9U,EAAA6U,OAAA,GAGA7U,EAAA8U,GAAA9U,EAAA6U,OAAA,EAAA4G,EAAApiB,QACA2G,EAAA8U,GAAA2G,EAAApiB,MAAA2G,EAAA6U,OAAA,GAGAjQ,EAAAhR,EAAA8N,EAAA1B,EAAAA,EAAA3G,MAAA2G,EAAA1G,QACAgJ,EAAA1O,EAAA8N,EAAA1B,GAGA0B,EAAAkV,UACA6E,EACAzb,EAAA8U,GAAA9U,EAAA6U,OAAA,EACA7U,EAAA+U,GAAA/U,EAAAyU,QAAA,EACAzU,EAAA6U,OACA7U,EAAAyU,QACAzU,EAAA9P,EAAA8P,EAAA3G,MAAA,EACA2G,EAAA7P,EAAA6P,EAAA1G,OAAA,EACA0G,EAAA3G,MACA2G,EAAA1G,UAMAsL,EAAAhR,EAAA8N,EAAA1B,EAAAA,EAAA3G,MAAA2G,EAAA1G,QACAgJ,EAAA1O,EAAA8N,EAAA1B,GAGA0B,EAAAkV,UACA6E,EACAzb,EAAA9P,EAAA8P,EAAA3G,MAAA,EACA2G,EAAA7P,EAAA6P,EAAA1G,OAAA,EACA0G,EAAA3G,MACA2G,EAAA1G,SAMAoI,EAAAsY,YACAtY,EAAAuY,KACAja,EAAA9P,EAAA8P,EAAA3G,MAAA,EACA2G,EAAA7P,EAAA6P,EAAA1G,OAAA,EACA0G,EAAA3G,MACA2G,EAAA1G,QAGAyV,EAAAnb,EAAA8N,EAAA1B,GAEA0B,EAAA6C,YACAJ,EAAAzC,EAAA1B,GACA+D,EAAArC,EAAAhM,EAAAsK,GAGA,QAAA0b,GAAA9nB,EAAA8N,EAAAhM,EAAAsK,EAAAjM,GACA,MAAA,YACA,GAAA+S,GAAAjT,EAAAD,EACA2jB,GAAA3jB,EAAA8N,EAAAhM,EAAAsK,EAAAjM,GACAiM,EAAAjM,MAEAsT,EAAAP,EAAApR,EAAA3B,EAAA,QACAiM,EAAA2b,MAEA3b,EAAA2b,KAAAxb,KAAA2G,EAAA,GAAA/S,GAGAiM,EAAAjM,QAEAA,EAAAuU,OAAA5S,EAAA6L,WAAAC,MAAA5P,MAAA,GACAoO,EAAA6I,OAEA/B,EAAAU;AACAiP,OAAA,EACA9H,WAAA,EACAjU,MAAAsF,EAAA6I,UAjIA,GAAAjV,GAAAgJ,EAAA8E,EAAAhM,EACAsK,EAAAjM,EACA0nB,EAAAG,EAAAjH,EAFAO,EAAApY,KAGA8W,EAAAhO,GAAAgO,UAoIA,KAAAhX,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EACAhJ,EAAAshB,EAAAtY,GACA8E,EAAAZ,EAAAoU,EAAAtY,IACA8E,IAEAhM,EAAAiP,EAAAuQ,EAAAtY,IACAoD,EAAA,GAAAH,GAAAC,GACA/L,EAAA4X,EAAAuJ,EAAAtY,GAAAoD,EAAAF,EAAA8W,IACA5W,EAAA2I,UAGAgM,EAAA3U,EAAA2U,OAEAiH,EAAAjH,EAAA5T,WACA4T,EAAAkH,KAAAD,EAEAH,EAAA9G,EACAA,IACAf,EAAAe,IAAAf,EAAAe,GAAAoC,SAEA0E,EAAA7H,EAAAe,IAGA8G,EAAA,GAAAtI,IAEAwB,EAAA9iB,MAAA,aAEA4pB,EAAAtH,YAAAnU,EAAAmU,aAEAsH,EAAAI,IAAAlH,EAEAf,EAAAe,GAAA8G,IAIAA,IACAA,EAAA1E,UAAA6E,EAEAF,EAAA9nB,EAAA8N,EAAAhM,EAAAsK,EAAAjM,MAGA0nB,EAAAC,OAAAA,EAAA9nB,EAAA8N,EAAAhM,EAAAsK,EAAAjM,GAEA0nB,EAAAI,IAAAJ,EAAAI,OAOA,OAAA3G,IAIArhB,EAAAiY,GAAAgQ,cAAA,SAAAhc,GAOA,QAAA4b,KAEAK,EAAAra,EAAAoa,cAAAL,EAAAzb,EAAAuU,QAEAvU,EAAA2b,MACA3b,EAAA2b,KAAAxb,KAAA+U,EAAA,GAAA6G,GAXA,GAAAra,GACA1B,EACAyb,EAAAG,EACAG,EAAApH,EAHAO,EAAApY,IAqEA,OAtDA4E,GAAAZ,EAAAoU,EAAA,IACAxT,GAEA1B,EAAA,GAAAH,GAAAC,GAGA6U,EAAA3U,EAAA2U,OAIAtS,GAAAsS,IAGA8G,EAAA5nB,EAAA,cAAA,GACA4nB,EAAApiB,MAAA2G,EAAA3G,MACAoiB,EAAAniB,OAAA0G,EAAA1G,OACAsiB,EAAA9a,EAAA2a,GACA9G,EAAAxU,KAAAsb,EAAAG,GACAF,MAKAE,EAAAjH,EAAA5T,WACA4T,EAAAkH,KAAAD,EAEAH,EAAA9G,GAGA8G,EAAA,GAAAtI,IAEAwB,EAAA9iB,MAAA,aAEA4pB,EAAAtH,YAAAnU,EAAAmU,aAEAsH,EAAAI,IAAAlH,GAIA8G,EAAA1E,UAAA6E,EACAF,KAEAD,EAAAC,OAAAA,EAEAD,EAAAI,IAAAJ,EAAAI,OAOAE,EAAA,KAGAA,GAIAloB,EAAAiY,GAAAkQ,eAAA,SAAAlc,GACA,GAAA4B,GACA1B,EACAic,EACAC,EACA/nB,EAAAC,EACA7B,EAAA4pB,EAAA3O,EAAAnB,EALA6I,EAAApY,KAGAsf,IAMA,IAFApc,EAAA,GAAAH,GAAAC,GACA4B,EAAAZ,EAAAoU,EAAA,IACA,CAiBA,IAdAlV,EAAAnH,GAAAmH,EAAAnH,IAAA,EACAmH,EAAAlH,GAAAkH,EAAAlH,IAAA,EACAkH,EAAAjH,GAAAiH,EAAAjH,IAAA,EACAiH,EAAAhH,GAAAgH,EAAAhH,IAAA,EAIAijB,EAFA,OAAAjc,EAAAqU,IAAA,OAAArU,EAAAsU,GAEA5S,EAAA2a,qBAAArc,EAAAnH,GAAAmH,EAAAlH,GAAAkH,EAAAqU,GAAArU,EAAAjH,GAAAiH,EAAAhH,GAAAgH,EAAAsU,IAGA5S,EAAA4a,qBAAAtc,EAAAnH,GAAAmH,EAAAlH,GAAAkH,EAAAjH,GAAAiH,EAAAhH,IAIAzG,EAAA,EAAA6O,SAAApB,EAAA,IAAAzN,GAAAA,GAAA,EACA6O,SAAApB,EAAA,IAAAzN,GACA6pB,EAAAva,KAAA7B,EAAA,IAAAzN,IAEA6pB,EAAAva,KAAA,KAeA,KAZAqa,EAAAE,EAAAra,OAGA,OAAAqa,EAAA,KACAA,EAAA,GAAA,GAGA,OAAAA,EAAAF,EAAA,KACAE,EAAAF,EAAA,GAAA,GAIA3pB,EAAA,EAAAA,EAAA2pB,EAAA3pB,GAAA,EAAA,CAGA,GAAA,OAAA6pB,EAAA7pB,GAAA,CAUA,IANAib,EAAA,EAEAnB,EAAA,EACAlY,EAAAioB,EAAA7pB,GAGA4pB,EAAA5pB,EAAA,EAAA4pB,EAAAD,EAAAC,GAAA,EAAA,CACA,GAAA,OAAAC,EAAAD,GAAA,CAEA/nB,EAAAgoB,EAAAD,EACA,OAGA3O,GAAA,EAKArZ,EAAAC,IACAgoB,EAAAD,GAAAC,EAAA7pB,QAGA,QAAA6pB,EAAA7pB,KAEA8Z,GAAA,EACA+P,EAAA7pB,GAAA4B,EAAAkY,IAAAjY,EAAAD,GAAAqZ,GAGAyO,GAAAM,aAAAH,EAAA7pB,GAAAyN,EAAA,KAAAzN,EAAA,UAIA0pB,GAAA,IAEA,OAAAA,IAIApoB,EAAAiY,GAAA0Q,UAAA,QAAAA,IAAA1c,GACA,GACAlM,GAAAgJ,EAAA8E,EAAA+a,EACAzc,EACAqK,EACAqS,EAAAC,EAAApqB,EAAAqqB,EAJA1H,EAAApY,IAMA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAIA,GAHAhJ,EAAAshB,EAAAtY,GACA8E,EAAAZ,EAAAlN,GACA6oB,EAAA9X,EAAAuQ,EAAAtY,IACA8E,IAEA1B,EAAA,GAAAH,GAAAC,GACA6L,EAAA/X,EAAAoM,EAAAF,EAAA0c,IACA5X,EAAAsQ,EAAAtY,GAAA8E,EAAA1B,EAAAA,EAAA3G,MAAA2G,EAAA1G,QAGA,OAAA0G,EAAA3G,OAAA,OAAA2G,EAAA1G,SACA0G,EAAA3G,MAAAzF,EAAAyF,MACA2G,EAAA1G,OAAA1F,EAAA0F,OACA0G,EAAA9P,EAAA8P,EAAA3G,MAAA,EACA2G,EAAA7P,EAAA6P,EAAA1G,OAAA,GAGA,IAAA0G,EAAA3G,OAAA,IAAA2G,EAAA1G,QAAA,CAaA,GAVAojB,EAAAhb,EAAAmb,cACA7c,EAAA9P,EAAA8P,EAAA3G,MAAA,GAAAojB,EAAA/V,YACA1G,EAAA7P,EAAA6P,EAAA1G,OAAA,GAAAmjB,EAAA/V,WACA1G,EAAA3G,MAAAojB,EAAA/V,WACA1G,EAAA1G,OAAAmjB,EAAA/V,YAEAiW,EAAAD,EAAAhnB,KACAknB,EAAAD,EAAA5a,OAGA/B,EAAA8c,KACA,IAAAvqB,EAAA,EAAAA,EAAAqqB,EAAArqB,GAAA,EACA8X,GACAJ,EAAA0S,EAAApqB,GACA2V,EAAAyU,EAAApqB,EAAA,GACAwqB,EAAAJ,EAAApqB,EAAA,GACA4pB,EAAAQ,EAAApqB,EAAA,IAEAyN,EAAA8c,KAAA3c,KAAAvM,EAAAyW,EAAArK,GACA2c,EAAApqB,GAAA8X,EAAAJ,EACA0S,EAAApqB,EAAA,GAAA8X,EAAAnC,EACAyU,EAAApqB,EAAA,GAAA8X,EAAA0S,EACAJ,EAAApqB,EAAA,GAAA8X,EAAA8R,CAIAza,GAAAsb,aACAN,GACA1c,EAAA9P,EAAA8P,EAAA3G,MAAA,GAAAojB,EAAA/V,YACA1G,EAAA7P,EAAA6P,EAAA1G,OAAA,GAAAmjB,EAAA/V,YAGAhF,EAAAO,UAMA,MAAAiT,IAIArhB,EAAAiY,GAAAmR,eAAA,SAAAlf,EAAAmf,GACA,GAAAtpB,GAAAshB,EAAApY,KACAqgB,EAAA,IAWA,OAVA,KAAAjI,EAAAnT,SACAnO,EAAAshB,EAAA,GACAthB,EAAAwpB,YAEAhc,SAAA8b,IACAA,EAAA,GAEAC,EAAAvpB,EAAAwpB,UAAA,SAAArf,EAAAmf,KAGAC,GAIAtpB,EAAAiY,GAAAuR,iBAAA,SAAAhI,GACA,GACAzhB,GAAAgJ,EAAA8E,EACA4b,EAAAC,EAAAC,EACAC,EAAAC,EACAhoB,EAJAwf,EAAApY,IAMA,KAAAF,EAAA,EAAAA,EAAAsY,EAAAnT,OAAAnF,GAAA,EAEAhJ,EAAAshB,EAAAtY,GACA8E,EAAAZ,EAAAlN,GACA8B,EAAAiP,EAAAuQ,EAAAtY,IAGAlH,EAAAiR,SAGA2W,EAAA9f,EAAA8f,kBAAA,EACAC,EAAA7b,EAAAic,8BACAjc,EAAAkc,2BACAlc,EAAAmc,0BACAnc,EAAAoc,yBACApc,EAAAqc,wBAAA,EAGAP,EAAAF,EAAAC,EAEA,IAAAC,IAIAC,EAAA7pB,EAAAyF,MACAqkB,EAAA9pB,EAAA0F,OAGA1F,EAAAyF,MAAAokB,EAAAD,EACA5pB,EAAA0F,OAAAokB,EAAAF,EAGA5pB,EAAAyZ,MAAAhU,MAAAokB,EAAA,KACA7pB,EAAAyZ,MAAA/T,OAAAokB,EAAA,KAGAhc,EAAAyD,MAAAqY,EAAAA,IAKA9nB,EAAAgR,WAAA8W,EAEA9nB,EAAAiR,QAAA,EAGA0O,GACAA,EAAAlV,KAAAvM,EAAA4pB,GAMA,OAAAtI,IAIAlO,GAAAgX,WAAA,WACA,GAAAC,EACA,KAAAA,IAAArY,IACA3F,OAAA3D,UAAA4D,eAAAC,KAAAyF,GAAAqY,KACArY,GAAAqY,QAMApqB,EAAAqqB,QAAAtqB,OAAAwN,SAAAvN,EAAA,cAAA,GAAAkN,WAGAV,GAAA2G,IACAkM,SAAAA,GACAiL,eAAA7b,EACA8b,eAAAxZ,EACAyZ,aAAAtP,EACAxK,UAAAF,EACAia,cAAArM,GACAhG,YAAAmG,KAEAve,EAAAmT,QAAAA,GACAnT,EAAAgM,cAAAA,GJxzIA,IAAAxP,SAAA,IACAE,QAAA,GACA,MAAAiD,WAAA,GACA,IAAAmF,0BAAA,UACAkB,WAAA,OACApD,YAAA,GACA2D,iBAAA,MACAhD,gBAAA,GACA/B,YAAA,QCFAkpB,YAAA1qB,EAAA,wEACAwI,WAAAxI,EAAA,eAAA6I,OAAA6hB,YAEAhf,QAAAtB,UAAAugB,MAAA,WAEA,GAAApiB,GAAAvI,EAAA,cAEA,oBAAAuI,GAAAqiB,SAEAriB,EAAAM,OAAAL,YAUAD,EAAA1G,KAAA,QAAA0G,EAAAsiB,KAAA,UAAA3c,QAEAwc,YAAAnhB,GAAA,QAAA,SAAAR,GAEAA,EAAAC,iBAGAV,WAAAC,EAAAC","file":"main.min.js","sourcesContent":["var CenterX = 300;\nvar CenterY = 300;\nconst bigRadius = 250;\nvar colorRayAndCircleByLabel = '#48D1CC';\nvar colorLabel = '#36c';\nvar radiusLabel = 15;\nvar colorSelectLabel = \"Red\";\nvar shadowLabelSize = 10;\nvar shadowColor = \"white\";\n\n/*\n * General functions\n * */\n\n/**\n * From dec in polar\n *\n * @param {float} x\n * @param {float} y\n * @returns {object}\n */\nfunction cartesian2Polar(x, y) {\n  var upX = (x-CenterX);\n  var upY = (y-CenterY);\n  distance = Math.sqrt(upX * upX + upY * upY);\n  radians = Math.atan2(upY, upX);\n  degr = radians*180/Math.PI+90;\n  polarCoor = {distance: distance, degr: degr};\n  return polarCoor;\n}\n\n/**\n * From polar in dec\n *\n * @param {float} radius\n * @param {float} degr\n * @returns {object}\n */\nfunction cartesian2Dec(radius, degr) {\n  radians = (degr-90)*(Math.PI/180);\n  if(degr >= 0 && degr <= 180){\n    tan  = Math.tan(radians);\n    x = Math.sqrt((Math.pow(radius,2))/(Math.pow(tan,2)+1));\n    y = x*tan;\n  }else{\n    tan  = Math.tan(-radians);\n    x = -Math.sqrt((Math.pow(radius,2))/(Math.pow(tan,2)+1));\n    y = -x*tan;\n  }\n  decCoor = {X: x+CenterX, Y: y+CenterY};\n  return decCoor;\n}\n\n/**\n * From polar in dec\n *\n * @param {float} radius\n * @param {float} degr\n * @returns {object}\n */\nfunction cartesian2DecForBorder(radius, degr) {\n  var newDegr = (degr-90);\n  radians = newDegr*(Math.PI/180);\n\n  if(newDegr >= 0 && newDegr <= 180){\n    tan  = Math.tan(radians);\n    x = Math.sqrt((radius*radius)/(tan*tan+1));\n    y = x*tan;\n  }else{\n    tan  = Math.tan(-radians);\n    x = Math.sqrt((radius*radius)/(tan*tan+1));\n    y = x*tan;\n  }\n\n  decCoor = {X: x, Y: y};\n\n  return decCoor;\n}\n\n/**\n *function for convert HEX -> rgba\n * */\n\nfunction hexInArray(h){\n  var m = h.slice(1).match(/.{2}/g);\n  m[0]=parseInt(m[0], 16);\n  m[1]=parseInt(m[1], 16);\n  m[2]=parseInt(m[2], 16);\n  return m;\n};\n\nfunction hexArrayInRgbString(m) {\n  var rgb = 'rgb('+m[0]+', '+m[1]+', '+m[2]+')';\n  return rgb;\n}\n\nfunction changeColorLayers(color,numLayers) {\n  var arColor = hexInArray(color);\n  var tempColor = arColor;\n  var arRBA = [];\n  var i = 0;\n  var difColorRed = (256-arColor[0])/numLayers;\n  var difColorGreen = (arColor[1])/(numLayers-1);\n  var difColorBlue = (arColor[2])/(numLayers-1);\n  var red = arColor[0] + difColorRed;\n  var green = arColor[1];\n  var blue = arColor[2];\n  for(red; red <= 256.01; red = red + difColorRed){\n    tempColor[0] = Math.floor(red);\n    tempColor[1] = Math.floor(green);\n    tempColor[2] = Math.floor(blue);\n    arRBA[i] = hexArrayInRgbString(tempColor);\n    green = green - difColorGreen;\n    blue = blue - difColorBlue;\n    i++;\n  }\n  console.log(arRBA);\n  return arRBA;\n}\n\n/*\n * Block functions for sectors\n * */\n\nfunction createSectorNew(sector_id, beginAngle, endAngle, circle_id, numLayers, color) {\n  var i;\n\n  var sector_id = sector_id;\n  var beginAngle = beginAngle;\n  var endAngle = endAngle;\n  var circle_id = circle_id;\n  var numLayers = numLayers;\n  var color = color;\n\n  var arColors = changeColorLayers(color,numLayers);\n  var difRadius = bigRadius/numLayers;\n  var radius = bigRadius;\n\n  var nameArc = 'mainArc_'+sector_id;\n  var nameSector = 'main_sector_'+sector_id;\n  var nameGroup = 'sector_'+sector_id;\n  var canvas = $('canvas');\n\n  for(i=1;i<=numLayers;i++){\n    canvas.drawSlice({\n      layer: true,\n      mask: true,\n      groups: [nameGroup],\n      fillStyle: arColors[i-1],\n      x: CenterX, y: CenterY,\n      start: beginAngle,\n      end: endAngle,\n      radius: radius,\n      strokeStyle: '#f60',\n      strokeWidth: 3,\n    }).restoreCanvas({\n      layer: true\n    });\n\n    radius = radius - difRadius;\n  }\n\n  canvas.drawSlice({\n    layer: true,\n    mask: true,\n    x: CenterX, y: CenterY,\n    start: beginAngle,\n    end: endAngle,\n    name: nameSector,\n    groups: [nameGroup],\n    circle_id: circle_id,\n    sector_id: sector_id,\n    radius: bigRadius,\n    numLayers : numLayers,\n    color : color,\n    dblclick: function(layer) {\n      var polar = cartesian2Polar(layer.eventX, layer.eventY);\n      var link = $('#create_label_link').attr('href','/app_dev.php/notes/new/'+layer.circle_id+'?radius='+polar.distance/bigRadius+'&degr='+polar.degr);\n      link.removeClass( \"btn-primary\" ).addClass( \"btn-danger\" );\n      link.text('    ');\n    },\n    click: function(layer) {\n      $('canvas').drawArc({\n        shadowBlur: 40,\n        shadowColor: 'white',\n        strokeStyle: 'white',\n        name: nameArc,\n        groups: [nameGroup],\n        strokeWidth: 3,\n        x: CenterX, y: CenterY,\n        radius: bigRadius,\n        start: beginAngle,\n        end: endAngle,\n      }).restoreCanvas({\n        layer: true\n      });\n    },\n    mouseout: function(layer) {\n      $('canvas').setLayer(nameArc, {\n        shadowBlur: 0\n      }).drawLayer();\n    }\n  });\n\n  canvas.restoreCanvas({\n    layer: true\n  });\n}\n\nfunction createBorderSector(data) {\n  var endCoord = cartesian2DecForBorder(bigRadius, data.beginAngle);\n  $('canvas').drawVector({\n    strokeStyle: 'white',\n    strokeWidth: 4,\n    x: CenterX, y: CenterY,\n    a1: endCoord.X, l1: endCoord.Y\n  });\n}\n\nfunction borderForSector(angle, sectorLeftId, sectorRightId, angleMin, angelMax) {\n  var LabelCoord = cartesian2Dec(bigRadius, angle);\n  var leftCoord = cartesian2Dec(bigRadius, angleMin+5);\n  var rightCoord = cartesian2Dec(bigRadius, angelMax-5);\n  $('canvas').drawArc({\n    layer: true,\n    draggable: true,\n    sectorLeftId: sectorLeftId,\n    sectorRightId: sectorRightId,\n    name: 'border_'+sectorLeftId+'_'+sectorRightId,\n    fillStyle: 'yellow',\n    x: LabelCoord.X, y: LabelCoord.Y,\n    radius: radiusLabel,\n    circlePath: true,\n    circleRadius: bigRadius,\n    circleCenterX: CenterX,\n    circleCenterY: CenterY,\n    xMin: leftCoord.X, yMin: leftCoord.Y,\n    xMax: rightCoord.X, yMax: rightCoord.Y,\n    data: {'sectorLeft': sectorLeftId , 'sectorRight': sectorRightId},\n    shadowColor: shadowColor,\n    shadowBlur: shadowLabelSize,\n    dragstop: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n      var sectorLeft = $('canvas').getLayer( 'main_sector_'+layer.sectorLeftId);\n      var sectorRight = $('canvas').getLayer('main_sector_'+layer.sectorRightId);\n\n      var circleId = sectorLeft.circle_id;\n      var numLayers = sectorLeft.numLayers;\n\n      var beginAngleL = sectorLeft.start;\n      var colorL = sectorLeft.color;\n\n      var endAngleR = sectorRight.end;\n      var colorR = sectorRight.color;\n\n      var newLeftSectorMinAngle = sectorLeft.start;\n      var newRightSectorMinAngle = pol.degr;\n      var oldLeftSectorMinAngle = sectorLeft.start;\n      var oldRightSectorMinAngle = sectorRight.start;\n      var coefficientLeft = (pol.degr - beginAngleL)/(sectorLeft.end - sectorLeft.start);\n      var coefficientRight = (endAngleR - pol.degr)/(sectorRight.end - sectorRight.start);\n\n      updateLabelPositionByChangingSector(layer,coefficientLeft,coefficientRight,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle);\n\n      $('canvas').removeLayerGroup('sector_'+sectorLeftId);\n      createSectorNew(sectorLeftId,beginAngleL,pol.degr, circleId, numLayers, colorL);\n\n      $('canvas').removeLayerGroup('sector_'+sectorRightId);\n      createSectorNew(sectorRightId,pol.degr,endAngleR, circleId, numLayers, colorR);\n\n      setHightMoveLayerToLayer();\n    },\n    drag: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n\n      $('canvas').drawVector({\n        strokeStyle: 'white',\n        strokeWidth: 4,\n        x: CenterX, y: CenterY,\n        a1: pol.degr, l1: pol.distance\n      });\n    },\n    mouseover: function(layer) {\n      $('canvas').drawVector({\n        strokeStyle: 'white',\n        strokeWidth: 4,\n        x: CenterX, y: CenterY,\n        a1: angle, l1: bigRadius\n      });\n    },\n    mouseout: function(layer) {\n      // var Label = $('canvas').getLayer(layer.name);\n      // Label.fillStyle = colorLabel;\n      // delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    dblclick: function(layer) {\n      // $('#pop_label_link').css('display','block').attr('href','/app_dev.php/notes/list/'+layer.data.circleId+'/'+layer.data.id+'/');\n    },\n  });\n}\n\n/*\n* Block functions for labels\n* */\n\nfunction rayAndCircleByLabel(layer,id) {\n  var pol = cartesian2Polar(layer.x, layer.y);\n  var dec = cartesian2Dec(bigRadius*2,pol.degr);\n  $('canvas').drawArc({\n    layer: true,\n    strokeStyle: colorRayAndCircleByLabel,\n    strokeWidth: 3,\n    name: 'circleByLabel'+id,\n    groups: ['circleByLabel'],\n    x: CenterX, y: CenterY,\n    radius: pol.distance,\n  });\n  $('canvas').drawLine({\n    layer: true,\n    strokeWidth: 3,\n    name: 'lineByLabel'+id,\n    groups: ['lineByLabel'],\n    strokeStyle: colorRayAndCircleByLabel,\n    x1: CenterX, y1: CenterY,\n    x2: dec.X, y2: dec.Y,\n  });\n}\n\nfunction createNamePopUpLabel(id,x,y,text) {\n  var heightPopUp = 30;\n  var widthPopUp = 150;\n\n  $('canvas').drawRect({\n    layer: true,\n    fillStyle: 'white',\n    strokeStyle: '#c33',\n    strokeWidth: 2,\n    name: 'nameLabelPopup'+id,\n    groups: ['nameLabelPopup'],\n    x: x + widthPopUp/2, y: y - heightPopUp/2 - 10,\n    width: widthPopUp,\n    height: heightPopUp,\n    cornerRadius: 10\n  });\n  $('canvas').drawText({\n    layer: true,\n    name: 'nameLabelPopupText'+id,\n    groups: ['nameLabelPopupText'],\n    fillStyle: 'black',\n    strokeWidth: 2,\n    x: x + widthPopUp/2, y: y - heightPopUp/2 - 10,\n    fontSize: '10pt',\n    fontFamily: 'Verdana, sans-serif',\n    maxWidth: widthPopUp,\n    text: text\n  })\n}\n\n\nfunction createLabel(data) {\n  var LabelCoord = cartesian2Dec(data.radius*bigRadius, data.degr);\n  // console.log(data.radius);\n  $('canvas').drawArc({\n    layer: true,\n    draggable: true,\n    groups: ['note_labels'],\n    name: 'myLabel'+data.id,\n    fillStyle: colorLabel,\n    x: LabelCoord.X, y: LabelCoord.Y,\n    radius: radiusLabel,\n    data: {'id' : data.id, 'name': data.name , 'circleId': data.circleId},\n    label_radius: data.radius,\n    label_angle: data.degr,\n    label_id: data.id,\n    shadowColor: shadowColor,\n    shadowBlur: shadowLabelSize,\n    dragstop: function(layer) {\n      var pol = cartesian2Polar(layer.x, layer.y);\n      var dec = cartesian2Dec(pol.distance,pol.degr);\n\n      layer.label_radius = pol.distance/bigRadius;\n      layer.label_angle = pol.degr;\n      // console.log(layer.label_radius,layer.label_angle);\n\n      updateCoordinateLabel(layer.data.circleId,layer.data.id,pol.distance/bigRadius,pol.degr);\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n    },\n    drag: function(layer) {\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n      rayAndCircleByLabel(layer,layer.data.id);\n    },\n    mouseover: function(layer) {\n      var Label = $('canvas').getLayer(layer.name);\n      Label.fillStyle = colorSelectLabel;\n      delRayNamePopUpAndCircleAllLabels();\n      rayAndCircleByLabel(layer,layer.data.id);\n      setLinkLabelsByRadiusAndAngle(layer.label_radius,layer.label_angle, layer.label_id);\n      createNamePopUpLabel(layer.data.id,layer.x,layer.y,layer.data.name);\n    },\n    mouseout: function(layer) {\n      var Label = $('canvas').getLayer(layer.name);\n      Label.fillStyle = colorLabel;\n      delRayNamePopUpAndCircleByLabel(layer.data.id);\n      removeLinkLabelsByRadiusAndAngle(layer.label_radius,layer.label_angle, layer.label_id);\n    },\n    dblclick: function(layer) {\n      $('#pop_label_link').css('display','block').attr('href','/app_dev.php/notes/list/'+layer.data.circleId+'/'+layer.data.id+'/');\n    },\n  });\n}\n\nfunction setHightMoveLayerToLayer(){\n  // Returns an array containing all draggable layers\n  var dragLayers = $('canvas').getLayers(function(layer) {\n    return (layer.draggable === true);\n  });\n\n  function setMoveLayerToLayer(layer, index, array) {\n    $('canvas').moveLayer(layer.name, 100);\n  }\n  dragLayers.forEach(setMoveLayerToLayer);\n}\n\nfunction setLinkLabelsByRadiusAndAngle(radius, angle, label_id){\n  var labels = $('canvas').getLayerGroup('note_labels');\n  var radiusBorderMin = radius - 0.05;\n  var radiusBorderMax = radius + 0.05;\n  var angleBorderMin = angle - 10;\n  var angleBorderMax = angle + 10;\n  // console.log(radiusBorderMin,radiusBorderMax,angleBorderMin,angleBorderMax);\n\n  function setFillStyleToLayer(layer, index, array) {\n    if(layer.id !== label_id){\n      if((layer.label_angle > angleBorderMin && layer.label_angle < angleBorderMax)\n          || (layer.label_radius > radiusBorderMin && layer.label_radius < radiusBorderMax) ){\n        // console.log(layer.label_angle,layer.label_radius);\n        createNamePopUpLabel(layer.label_id,layer.x,layer.y,layer.data.name);\n        layer.fillStyle = colorSelectLabel;\n      }\n    }\n  }\n  labels.forEach(setFillStyleToLayer);\n}\n\nfunction removeLinkLabelsByRadiusAndAngle(radius, angle, label_id){\n  var labels = $('canvas').getLayerGroup('note_labels');\n  var radiusBorderMin = radius - 0.03;\n  var radiusBorderMax = radius + 0.03;\n  var angleBorderMin = angle - 10;\n  var angleBorderMax = angle + 10;\n  // console.log(radiusBorderMin,radiusBorderMax,angleBorderMin,angleBorderMax);\n\n  function deleteFillStyleToLayer(layer, index, array) {\n    if(layer.label_id !== label_id){\n      if((layer.label_angle > angleBorderMin && layer.label_angle < angleBorderMax)\n          || (layer.label_radius > radiusBorderMin && layer.label_radius < radiusBorderMax) ){\n        // console.log(layer.label_angle,layer.label_radius);\n        layer.fillStyle = colorLabel;\n        delNamePopUpByLabel(layer.label_id);\n      }\n    }\n  }\n  labels.forEach(deleteFillStyleToLayer);\n}\n\nfunction updateLabelPositionByChangingSector(border,coefficientLeft,coefficientRight,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle) {\n  var sector_left = $('canvas').getLayer('main_sector_'+border.sectorLeftId);\n  var sector_right = $('canvas').getLayer('main_sector_'+border.sectorRightId);\n  var labels = $('canvas').getLayerGroup('note_labels');\n\n  if(typeof labels !== 'undefined'){\n    function updateLabelPosition(label, index, array) {\n\n      if(label.label_angle > sector_left.start && label.label_angle < sector_left.end){\n        var newAngle = (label.label_angle-oldLeftSectorMinAngle)*coefficientLeft+newLeftSectorMinAngle;\n        var LabelCoord = cartesian2Dec(label.label_radius*bigRadius, newAngle);\n        label.x = LabelCoord.X;\n        label.y = LabelCoord.Y;\n        console.log(label.name,label.label_angle,newAngle,sector_left,newLeftSectorMinAngle,newRightSectorMinAngle,oldLeftSectorMinAngle,oldRightSectorMinAngle,coefficientLeft);\n        label.label_angle = newAngle;\n      }else if(label.label_angle > sector_right.start && label.label_angle < sector_right.end){\n        var newAngle = (label.label_angle-oldRightSectorMinAngle)*coefficientRight+newRightSectorMinAngle;\n        var LabelCoord = cartesian2Dec(label.label_radius*bigRadius, newAngle);\n        label.x = LabelCoord.X;\n        label.y = LabelCoord.Y;\n        label.label_angle = newAngle;\n      }\n    }\n    labels.forEach(updateLabelPosition);\n  }\n\n  // console.log(sector_left,sector_right);\n}\n\n\nfunction updateCoordinateLabel(circleId,labelId,radius,angle) {\n  $.post(\n      \"/app_dev.php/circle/editLabelAjax\",\n      {\n        circleId: circleId,\n        labelId:labelId,\n        radius:radius,\n        angle:angle\n      }).done(\n      function (data) {\n        console.log(data);\n\n      })\n}\n\nfunction delRayNamePopUpAndCircleByLabel(id) {\n  $('canvas').removeLayer('circleByLabel'+id);\n  $('canvas').removeLayer('lineByLabel'+id);\n  $('canvas').removeLayer('nameLabelPopup'+id);\n  $('canvas').removeLayer('nameLabelPopupText'+id);\n}\n\nfunction delNamePopUpByLabel(id) {\n  $('canvas').removeLayer('nameLabelPopup'+id);\n  $('canvas').removeLayer('nameLabelPopupText'+id);\n}\n\nfunction delRayNamePopUpAndCircleAllLabels() {\n  $('canvas').removeLayerGroup('circleByLabel');\n  $('canvas').removeLayerGroup('lineByLabel');\n  $('canvas').removeLayerGroup('nameLabelPopup');\n  $('canvas').removeLayerGroup('nameLabelPopupText');\n}","/*\n* block for creating sectors\n* */\n\n// setup an \"add a tag\" link\n//btn btn-primary btn-block\nvar $addTagLink = $('<a href=\"#\" class=\"btn btn-primary btn-block\"> </a>');\nvar $newLinkLi = $('<div></div>').append($addTagLink);\n\njQuery(document).ready(function() {\n  // Get the ul that holds the collection of tags\n  var $collectionHolder = $('div.sectors');\n\n  if (typeof $collectionHolder.html() !== 'undefined'){\n    // add the \"add a tag\" anchor and li to the tags ul\n    $collectionHolder.append($newLinkLi);\n\n// TODO add when logic for delete sector will be ready\n//         // add a delete link to all of the existing tag form li elements\n//         $collectionHolder.find('li').each(function() {\n//           addTagFormDeleteLink($(this));\n//         });\n\n    // count the current form inputs we have (e.g. 2), use that as the new\n    // index when inserting a new item (e.g. 2)\n    $collectionHolder.data('index', $collectionHolder.find(':input').length);\n\n    $addTagLink.on('click', function(e) {\n      // prevent the link from creating a \"#\" on the URL\n      e.preventDefault();\n\n      // add a new tag form (see code block below)\n      addTagForm($collectionHolder, $newLinkLi);\n    });\n  }\n\n});\n\nfunction addTagForm($collectionHolder, $newLinkLi) {\n  // Get the data-prototype explained earlier\n  var prototype = $collectionHolder.data('prototype');\n\n  // get the new index\n  var index = $collectionHolder.data('index');\n\n  // Replace '$$name$$' in the prototype's HTML to\n  // instead be a number based on how many items we have\n  var newForm = prototype.replace(/__name__/g, index);\n\n  // increase the index with one for the next item\n  $collectionHolder.data('index', index + 1);\n\n  // Display the form in the page in an li, before the \"Add a tag\" link li\n  var $newFormLi = $(newForm);\n\n  // also add a remove button, just for this example\n  $newFormLi.append('<button class=\"remove-tag btn btn-danger\"><i class=\"fa fa-remove fa-lg\"></i></button>');\n\n  $newLinkLi.before($newFormLi);\n\n  // handle the removal, just for this example\n  $('.remove-tag').click(function(e) {\n    e.preventDefault();\n\n    $(this).parent().remove();\n\n    return false;\n  });\n\n//         // add a delete link to the new form\n//         addTagFormDeleteLink($newFormLi);\n}\n\nfunction addTagFormDeleteLink($tagFormLi) {\n  var $removeFormA = $('<a href=\"#\">delete this tag</a>');\n  $tagFormLi.append($removeFormA);\n\n  $removeFormA.on('click', function(e) {\n    // prevent the link from creating a \"#\" on the URL\n    e.preventDefault();\n\n    // remove the li for the tag form\n    $tagFormLi.remove();\n  });\n}","function getNoteContent(noteId) {\n  var host = \"http://\" + window.location.hostname + ':' + window.location.port;\n  $.ajax({\n    url: typeof isLocalDev !== \"undefined\" ? host + \"/note/api/data.json\" : host + \"/note/api/\"+noteId+\"/\",\n    type: 'get',\n    success:   function (data) {\n      document.getElementById('note_view_title').innerHTML = data.title;\n      document.getElementById('note_view_text').innerHTML = data.text;\n      document.getElementById('note_edit_link').href = typeof isLocalDev !== \"undefined\" ? host + \"/notes_edit.html\" : host + \"/note/view/\"+data.id+\"/\";\n    },\n    error: function (err) {\n\n    }\n  });\n}","/*!\n *\n *  Web Starter Kit\n *  Copyright 2015 Google Inc. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License\n *\n */\n/* eslint-env browser */\n(function() {\n  'use strict';\n\n  // Check to make sure service workers are supported in the current browser,\n  // and that the current page is accessed from a secure origin. Using a\n  // service worker from an insecure origin will trigger JS console errors. See\n  // http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features\n  var isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n    );\n\n  if ('serviceWorker' in navigator &&\n      (window.location.protocol === 'https:' || isLocalhost)) {\n    navigator.serviceWorker.register('service-worker.js')\n    .then(function(registration) {\n      // updatefound is fired if service-worker.js changes.\n      registration.onupdatefound = function() {\n        // updatefound is also fired the very first time the SW is installed,\n        // and there's no need to prompt for a reload at that point.\n        // So check here to see if the page is already controlled,\n        // i.e. whether there's an existing service worker.\n        if (navigator.serviceWorker.controller) {\n          // The updatefound event implies that registration.installing is set:\n          // https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-container-updatefound-event\n          var installingWorker = registration.installing;\n\n          installingWorker.onstatechange = function() {\n            switch (installingWorker.state) {\n              case 'installed':\n                // At this point, the old content will have been purged and the\n                // fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in the page's interface.\n                break;\n\n              case 'redundant':\n                throw new Error('The installing ' +\n                                'service worker became redundant.');\n\n              default:\n                // Ignore\n            }\n          };\n        }\n      };\n    }).catch(function(e) {\n      console.error('Error during service worker registration:', e);\n    });\n  }\n\n  // Your custom JavaScript goes here\n})();\n","/**\n * @license jCanvas v20.1.4\n * Copyright 2017 Caleb Evans\n * Released under the MIT license\n */\n(function (jQuery, global, factory) {\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = function (jQuery, w) {\n      return factory(jQuery, w);\n    };\n  } else {\n    factory(jQuery, global);\n  }\n\n// Pass this if window is not defined yet\n}(typeof window !== 'undefined' ? window.jQuery : {}, typeof window !== 'undefined' ? window : this, function ($, window) {\n  'use strict';\n\n  var document = window.document,\n      Image = window.Image,\n      Array = window.Array,\n      getComputedStyle = window.getComputedStyle,\n      Math = window.Math,\n      Number = window.Number,\n      parseFloat = window.parseFloat;\n\n// Define local aliases to frequently used properties\n  var defaults,\n      // Aliases to jQuery methods\n      extendObject = $.extend,\n      inArray = $.inArray,\n      typeOf = function (operand) {\n        return Object.prototype.toString.call(operand)\n            .slice(8, -1).toLowerCase();\n      },\n      isFunction = $.isFunction,\n      isPlainObject = $.isPlainObject,\n      // Math constants and functions\n      PI = Math.PI,\n      round = Math.round,\n      abs = Math.abs,\n      sin = Math.sin,\n      cos = Math.cos,\n      atan2 = Math.atan2,\n      // The Array slice() method\n      arraySlice = Array.prototype.slice,\n      // jQuery's internal event normalization function\n      jQueryEventFix = $.event.fix,\n      // Object for storing a number of internal property maps\n      maps = {},\n      // jQuery internal caches\n      caches = {\n        dataCache: {},\n        propCache: {},\n        imageCache: {}\n      },\n      // Base transformations\n      baseTransforms = {\n        rotate: 0,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        // Store all previous masks\n        masks: []\n      },\n      // Object for storing CSS-related properties\n      css = {},\n      tangibleEvents = [\n        'mousedown',\n        'mousemove',\n        'mouseup',\n        'mouseover',\n        'mouseout',\n        'touchstart',\n        'touchmove',\n        'touchend'\n      ];\n\n// Constructor for creating objects that inherit from jCanvas preferences and defaults\n  function jCanvasObject(args) {\n    var params = this,\n        propName;\n    // Copy the given parameters into new object\n    for (propName in args) {\n      // Do not merge defaults into parameters\n      if (Object.prototype.hasOwnProperty.call(args, propName)) {\n        params[propName] = args[propName];\n      }\n    }\n    return params;\n  }\n\n// jCanvas object in which global settings are other data are stored\n  var jCanvas = {\n    // Events object for storing jCanvas event initiation functions\n    events: {},\n    // Object containing all jCanvas event hooks\n    eventHooks: {},\n    // Settings for enabling future jCanvas features\n    future: {}\n  };\n\n// jCanvas default property values\n  function jCanvasDefaults() {\n    extendObject(this, jCanvasDefaults.baseDefaults);\n  }\n  jCanvasDefaults.baseDefaults = {\n    align: 'center',\n    arrowAngle: 90,\n    arrowRadius: 0,\n    autosave: true,\n    baseline: 'middle',\n    bringToFront: false,\n    ccw: false,\n    closed: false,\n    compositing: 'source-over',\n    concavity: 0,\n    cornerRadius: 0,\n    count: 1,\n    cropFromCenter: true,\n    crossOrigin: null,\n    cursors: null,\n    disableEvents: false,\n    draggable: false,\n    dragGroups: null,\n    groups: null,\n    data: null,\n    dx: null,\n    dy: null,\n    end: 360,\n    eventX: null,\n    eventY: null,\n    fillStyle: 'transparent',\n    fontStyle: 'normal',\n    fontSize: '12pt',\n    fontFamily: 'sans-serif',\n    fromCenter: true,\n    height: null,\n    imageSmoothing: true,\n    inDegrees: true,\n    intangible: false,\n    index: null,\n    letterSpacing: null,\n    lineHeight: 1,\n    layer: false,\n    mask: false,\n    maxWidth: null,\n    miterLimit: 10,\n    name: null,\n    opacity: 1,\n    r1: null,\n    r2: null,\n    radius: 0,\n    repeat: 'repeat',\n    respectAlign: false,\n    restrictDragToAxis: null,\n    rotate: 0,\n    rounded: false,\n    scale: 1,\n    scaleX: 1,\n    scaleY: 1,\n    shadowBlur: 0,\n    shadowColor: 'transparent',\n    shadowStroke: false,\n    shadowX: 0,\n    shadowY: 0,\n    sHeight: null,\n    sides: 0,\n    source: '',\n    spread: 0,\n    start: 0,\n    strokeCap: 'butt',\n    strokeDash: null,\n    strokeDashOffset: 0,\n    strokeJoin: 'miter',\n    strokeStyle: 'transparent',\n    strokeWidth: 1,\n    sWidth: null,\n    sx: null,\n    sy: null,\n    text: '',\n    translate: 0,\n    translateX: 0,\n    translateY: 0,\n    type: null,\n    visible: true,\n    width: null,\n    x: 0,\n    y: 0\n  };\n  defaults = new jCanvasDefaults();\n  jCanvasObject.prototype = defaults;\n\n  /* Internal helper methods */\n\n// Determines if the given operand is a string\n  function isString(operand) {\n    return (typeOf(operand) === 'string');\n  }\n\n// Determines if the given operand is numeric\n  function isNumeric(operand) {\n    return !isNaN(Number(operand)) && !isNaN(parseFloat(operand));\n  }\n\n// Get 2D context for the given canvas\n  function _getContext(canvas) {\n    return (canvas && canvas.getContext ? canvas.getContext('2d') : null);\n  }\n\n// Coerce designated number properties from strings to numbers\n  function _coerceNumericProps(props) {\n    var propName, propType, propValue;\n    // Loop through all properties in given property map\n    for (propName in props) {\n      if (Object.prototype.hasOwnProperty.call(props, propName)) {\n        propValue = props[propName];\n        propType = typeOf(propValue);\n        // If property is non-empty string and value is numeric\n        if (propType === 'string' && isNumeric(propValue) && propName !== 'text') {\n          // Convert value to number\n          props[propName] = parseFloat(propValue);\n        }\n      }\n    }\n    // Ensure value of text property is always a string\n    if (props.text !== undefined) {\n      props.text = String(props.text);\n    }\n  }\n\n// Clone the given transformations object\n  function _cloneTransforms(transforms) {\n    // Clone the object itself\n    transforms = extendObject({}, transforms);\n    // Clone the object's masks array\n    transforms.masks = transforms.masks.slice(0);\n    return transforms;\n  }\n\n// Save canvas context and update transformation stack\n  function _saveCanvas(ctx, data) {\n    var transforms;\n    ctx.save();\n    transforms = _cloneTransforms(data.transforms);\n    data.savedTransforms.push(transforms);\n  }\n\n// Restore canvas context update transformation stack\n  function _restoreCanvas(ctx, data) {\n    if (data.savedTransforms.length === 0) {\n      // Reset transformation state if it can't be restored any more\n      data.transforms = _cloneTransforms(baseTransforms);\n    } else {\n      // Restore canvas context\n      ctx.restore();\n      // Restore current transform state to the last saved state\n      data.transforms = data.savedTransforms.pop();\n    }\n  }\n\n// Set the style with the given name\n  function _setStyle(canvas, ctx, params, styleName) {\n    if (params[styleName]) {\n      if (isFunction(params[styleName])) {\n        // Handle functions\n        ctx[styleName] = params[styleName].call(canvas, params);\n      } else {\n        // Handle string values\n        ctx[styleName] = params[styleName];\n      }\n    }\n  }\n\n// Set canvas context properties\n  function _setGlobalProps(canvas, ctx, params) {\n    _setStyle(canvas, ctx, params, 'fillStyle');\n    _setStyle(canvas, ctx, params, 'strokeStyle');\n    ctx.lineWidth = params.strokeWidth;\n    // Optionally round corners for paths\n    if (params.rounded) {\n      ctx.lineCap = ctx.lineJoin = 'round';\n    } else {\n      ctx.lineCap = params.strokeCap;\n      ctx.lineJoin = params.strokeJoin;\n      ctx.miterLimit = params.miterLimit;\n    }\n    // Reset strokeDash if null\n    if (!params.strokeDash) {\n      params.strokeDash = [];\n    }\n    // Dashed lines\n    if (ctx.setLineDash) {\n      ctx.setLineDash(params.strokeDash);\n    }\n    ctx.webkitLineDash = params.strokeDash;\n    ctx.lineDashOffset = ctx.webkitLineDashOffset = ctx.mozDashOffset = params.strokeDashOffset;\n    // Drop shadow\n    ctx.shadowOffsetX = params.shadowX;\n    ctx.shadowOffsetY = params.shadowY;\n    ctx.shadowBlur = params.shadowBlur;\n    ctx.shadowColor = params.shadowColor;\n    // Opacity and composite operation\n    ctx.globalAlpha = params.opacity;\n    ctx.globalCompositeOperation = params.compositing;\n    // Support cross-browser toggling of image smoothing\n    if (params.imageSmoothing) {\n      ctx.imageSmoothingEnabled = params.imageSmoothing;\n    }\n  }\n\n// Optionally enable masking support for this path\n  function _enableMasking(ctx, data, params) {\n    if (params.mask) {\n      // If jCanvas autosave is enabled\n      if (params.autosave) {\n        // Automatically save transformation state by default\n        _saveCanvas(ctx, data);\n      }\n      // Clip the current path\n      ctx.clip();\n      // Keep track of current masks\n      data.transforms.masks.push(params._args);\n    }\n  }\n\n// Restore individual shape transformation\n  function _restoreTransform(ctx, params) {\n    // If shape has been transformed by jCanvas\n    if (params._transformed) {\n      // Restore canvas context\n      ctx.restore();\n    }\n  }\n\n// Close current canvas path\n  function _closePath(canvas, ctx, params) {\n    var data;\n\n    // Optionally close path\n    if (params.closed) {\n      ctx.closePath();\n    }\n\n    if (params.shadowStroke && params.strokeWidth !== 0) {\n      // Extend the shadow to include the stroke of a drawing\n\n      // Add a stroke shadow by stroking before filling\n      ctx.stroke();\n      ctx.fill();\n      // Ensure the below stroking does not inherit a shadow\n      ctx.shadowColor = 'transparent';\n      ctx.shadowBlur = 0;\n      // Stroke over fill as usual\n      ctx.stroke();\n\n    } else {\n      // If shadowStroke is not enabled, stroke & fill as usual\n\n      ctx.fill();\n      // Prevent extra shadow created by stroke (but only when fill is present)\n      if (params.fillStyle !== 'transparent') {\n        ctx.shadowColor = 'transparent';\n      }\n      if (params.strokeWidth !== 0) {\n        // Only stroke if the stroke is not 0\n        ctx.stroke();\n      }\n\n    }\n\n    // Optionally close path\n    if (!params.closed) {\n      ctx.closePath();\n    }\n\n    // Restore individual shape transformation\n    _restoreTransform(ctx, params);\n\n    // Mask shape if chosen\n    if (params.mask) {\n      // Retrieve canvas data\n      data = _getCanvasData(canvas);\n      _enableMasking(ctx, data, params);\n    }\n\n  }\n\n// Transform (translate, scale, or rotate) shape\n  function _transformShape(canvas, ctx, params, width, height) {\n\n    // Get conversion factor for radians\n    params._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n    params._transformed = true;\n    ctx.save();\n\n    // Optionally measure (x, y) position from top-left corner\n    if (!params.fromCenter && !params._centered && width !== undefined) {\n      // Always draw from center unless otherwise specified\n      if (height === undefined) {\n        height = width;\n      }\n      params.x += width / 2;\n      params.y += height / 2;\n      params._centered = true;\n    }\n    // Optionally rotate shape\n    if (params.rotate) {\n      _rotateCanvas(ctx, params, null);\n    }\n    // Optionally scale shape\n    if (params.scale !== 1 || params.scaleX !== 1 || params.scaleY !== 1) {\n      _scaleCanvas(ctx, params, null);\n    }\n    // Optionally translate shape\n    if (params.translate || params.translateX || params.translateY) {\n      _translateCanvas(ctx, params, null);\n    }\n\n  }\n\n  /* Plugin API */\n\n// Extend jCanvas with a user-defined method\n  jCanvas.extend = function extend(plugin) {\n\n    // Create plugin\n    if (plugin.name) {\n      // Merge properties with defaults\n      if (plugin.props) {\n        extendObject(defaults, plugin.props);\n      }\n      // Define plugin method\n      $.fn[plugin.name] = function self(args) {\n        var $canvases = this, canvas, e, ctx,\n            params;\n\n        for (e = 0; e < $canvases.length; e += 1) {\n          canvas = $canvases[e];\n          ctx = _getContext(canvas);\n          if (ctx) {\n\n            params = new jCanvasObject(args);\n            _addLayer(canvas, params, args, self);\n\n            _setGlobalProps(canvas, ctx, params);\n            plugin.fn.call(canvas, ctx, params);\n\n          }\n        }\n        return $canvases;\n      };\n      // Add drawing type to drawing map\n      if (plugin.type) {\n        maps.drawings[plugin.type] = plugin.name;\n      }\n    }\n    return $.fn[plugin.name];\n  };\n\n  /* Layer API */\n\n// Retrieved the stored jCanvas data for a canvas element\n  function _getCanvasData(canvas) {\n    var dataCache = caches.dataCache, data;\n    if (dataCache._canvas === canvas && dataCache._data) {\n\n      // Retrieve canvas data from cache if possible\n      data = dataCache._data;\n\n    } else {\n\n      // Retrieve canvas data from jQuery's internal data storage\n      data = $.data(canvas, 'jCanvas');\n      if (!data) {\n\n        // Create canvas data object if it does not already exist\n        data = {\n          // The associated canvas element\n          canvas: canvas,\n          // Layers array\n          layers: [],\n          // Layer maps\n          layer: {\n            names: {},\n            groups: {}\n          },\n          eventHooks: {},\n          // All layers that intersect with the event coordinates (regardless of visibility)\n          intersecting: [],\n          // The topmost layer whose area contains the event coordinates\n          lastIntersected: null,\n          cursor: $(canvas).css('cursor'),\n          // Properties for the current drag event\n          drag: {\n            layer: null,\n            dragging: false\n          },\n          // Data for the current event\n          event: {\n            type: null,\n            x: null,\n            y: null\n          },\n          // Events which already have been bound to the canvas\n          events: {},\n          // The canvas's current transformation state\n          transforms: _cloneTransforms(baseTransforms),\n          savedTransforms: [],\n          // Whether a layer is being animated or not\n          animating: false,\n          // The layer currently being animated\n          animated: null,\n          // The device pixel ratio\n          pixelRatio: 1,\n          // Whether pixel ratio transformations have been applied\n          scaled: false,\n          // Whether the canvas should be redrawn when a layer mousemove\n          // event triggers (either directly, or indirectly via dragging)\n          redrawOnMousemove: false\n        };\n        // Use jQuery to store canvas data\n        $.data(canvas, 'jCanvas', data);\n\n      }\n      // Cache canvas data for faster retrieval\n      dataCache._canvas = canvas;\n      dataCache._data = data;\n\n    }\n    return data;\n  }\n\n// Initialize all of a layer's associated jCanvas events\n  function _addLayerEvents($canvas, data, layer) {\n    var eventName;\n    // Determine which jCanvas events need to be bound to this layer\n    for (eventName in jCanvas.events) {\n      if (Object.prototype.hasOwnProperty.call(jCanvas.events, eventName)) {\n        // If layer has callback function to complement it\n        if (layer[eventName] || (layer.cursors && layer.cursors[eventName])) {\n          // Bind event to layer\n          _addExplicitLayerEvent($canvas, data, layer, eventName);\n        }\n      }\n    }\n    if (!data.events.mouseout) {\n      $canvas.bind('mouseout.jCanvas', function () {\n        // Retrieve the layer whose drag event was canceled\n        var layer = data.drag.layer, l;\n        // If cursor mouses out of canvas while dragging\n        if (layer) {\n          // Cancel drag\n          data.drag = {};\n          _triggerLayerEvent($canvas, data, layer, 'dragcancel');\n        }\n        // Loop through all layers\n        for (l = 0; l < data.layers.length; l += 1) {\n          layer = data.layers[l];\n          // If layer thinks it's still being moused over\n          if (layer._hovered) {\n            // Trigger mouseout on layer\n            $canvas.triggerLayerEvent(data.layers[l], 'mouseout');\n          }\n        }\n        // Redraw layers\n        $canvas.drawLayers();\n      });\n      // Indicate that an event handler has been bound\n      data.events.mouseout = true;\n    }\n  }\n\n// Initialize the given event on the given layer\n  function _addLayerEvent($canvas, data, layer, eventName) {\n    // Use touch events if appropriate\n    // eventName = _getMouseEventName(eventName);\n    // Bind event to layer\n    jCanvas.events[eventName]($canvas, data);\n    layer._event = true;\n  }\n\n// Add a layer event that was explicitly declared in the layer's parameter map,\n// excluding events added implicitly (e.g. mousemove event required by draggable\n// layers)\n  function _addExplicitLayerEvent($canvas, data, layer, eventName) {\n    _addLayerEvent($canvas, data, layer, eventName);\n    if (eventName === 'mouseover' || eventName === 'mouseout' || eventName === 'mousemove') {\n      data.redrawOnMousemove = true;\n    }\n  }\n\n// Enable drag support for this layer\n  function _enableDrag($canvas, data, layer) {\n    var dragHelperEvents, eventName, i;\n    // Only make layer draggable if necessary\n    if (layer.draggable || layer.cursors) {\n\n      // Organize helper events which enable drag support\n      dragHelperEvents = ['mousedown', 'mousemove', 'mouseup'];\n\n      // Bind each helper event to the canvas\n      for (i = 0; i < dragHelperEvents.length; i += 1) {\n        // Use touch events if appropriate\n        eventName = dragHelperEvents[i];\n        // Bind event\n        _addLayerEvent($canvas, data, layer, eventName);\n      }\n      // Indicate that this layer has events bound to it\n      layer._event = true;\n\n    }\n  }\n\n// Update a layer property map if property is changed\n  function _updateLayerName($canvas, data, layer, props) {\n    var nameMap = data.layer.names;\n\n    // If layer name is being added, not changed\n    if (!props) {\n\n      props = layer;\n\n    } else {\n\n      // Remove old layer name entry because layer name has changed\n      if (props.name !== undefined && isString(layer.name) && layer.name !== props.name) {\n        delete nameMap[layer.name];\n      }\n\n    }\n\n    // Add new entry to layer name map with new name\n    if (isString(props.name)) {\n      nameMap[props.name] = layer;\n    }\n  }\n\n// Create or update the data map for the given layer and group type\n  function _updateLayerGroups($canvas, data, layer, props) {\n    var groupMap = data.layer.groups,\n        group, groupName, g,\n        index, l;\n\n    // If group name is not changing\n    if (!props) {\n\n      props = layer;\n\n    } else {\n\n      // Remove layer from all of its associated groups\n      if (props.groups !== undefined && layer.groups !== null) {\n        for (g = 0; g < layer.groups.length; g += 1) {\n          groupName = layer.groups[g];\n          group = groupMap[groupName];\n          if (group) {\n            // Remove layer from its old layer group entry\n            for (l = 0; l < group.length; l += 1) {\n              if (group[l] === layer) {\n                // Keep track of the layer's initial index\n                index = l;\n                // Remove layer once found\n                group.splice(l, 1);\n                break;\n              }\n            }\n            // Remove layer group entry if group is empty\n            if (group.length === 0) {\n              delete groupMap[groupName];\n            }\n          }\n        }\n      }\n\n    }\n\n    // Add layer to new group if a new group name is given\n    if (props.groups !== undefined && props.groups !== null) {\n\n      for (g = 0; g < props.groups.length; g += 1) {\n\n        groupName = props.groups[g];\n\n        group = groupMap[groupName];\n        if (!group) {\n          // Create new group entry if it doesn't exist\n          group = groupMap[groupName] = [];\n          group.name = groupName;\n        }\n        if (index === undefined) {\n          // Add layer to end of group unless otherwise stated\n          index = group.length;\n        }\n        // Add layer to its new layer group\n        group.splice(index, 0, layer);\n\n      }\n\n    }\n  }\n\n// Get event hooks object for the first selected canvas\n  $.fn.getEventHooks = function getEventHooks() {\n    var $canvases = this, canvas, data,\n        eventHooks = {};\n\n    if ($canvases.length !== 0) {\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      eventHooks = data.eventHooks;\n    }\n    return eventHooks;\n  };\n\n// Set event hooks for the selected canvases\n  $.fn.setEventHooks = function setEventHooks(eventHooks) {\n    var $canvases = this, e,\n        data;\n    for (e = 0; e < $canvases.length; e += 1) {\n      data = _getCanvasData($canvases[e]);\n      extendObject(data.eventHooks, eventHooks);\n    }\n    return $canvases;\n  };\n\n// Get jCanvas layers array\n  $.fn.getLayers = function getLayers(callback) {\n    var $canvases = this, canvas, data,\n        layers, layer, l,\n        matching = [];\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      // Retrieve layers array for this canvas\n      layers = data.layers;\n\n      // If a callback function is given\n      if (isFunction(callback)) {\n\n        // Filter the layers array using the callback\n        for (l = 0; l < layers.length; l += 1) {\n          layer = layers[l];\n          if (callback.call(canvas, layer)) {\n            // Add layer to array of matching layers if test passes\n            matching.push(layer);\n          }\n        }\n\n      } else {\n        // Otherwise, get all layers\n\n        matching = layers;\n\n      }\n\n    }\n    return matching;\n  };\n\n// Get a single jCanvas layer object\n  $.fn.getLayer = function getLayer(layerId) {\n    var $canvases = this, canvas,\n        data, layers, layer, l,\n        idType;\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n      data = _getCanvasData(canvas);\n      layers = data.layers;\n      idType = typeOf(layerId);\n\n      if (layerId && layerId.layer) {\n\n        // Return the actual layer object if given\n        layer = layerId;\n\n      } else if (idType === 'number') {\n\n        // Retrieve the layer using the given index\n\n        // Allow for negative indices\n        if (layerId < 0) {\n          layerId = layers.length + layerId;\n        }\n        // Get layer with the given index\n        layer = layers[layerId];\n\n      } else if (idType === 'regexp') {\n\n        // Get layer with the name that matches the given regex\n        for (l = 0; l < layers.length; l += 1) {\n          // Check if layer matches name\n          if (isString(layers[l].name) && layers[l].name.match(layerId)) {\n            layer = layers[l];\n            break;\n          }\n        }\n\n      } else {\n\n        // Get layer with the given name\n        layer = data.layer.names[layerId];\n\n      }\n\n    }\n    return layer;\n  };\n\n// Get all layers in the given group\n  $.fn.getLayerGroup = function getLayerGroup(groupId) {\n    var $canvases = this, canvas, data,\n        groups, groupName, group,\n        idType = typeOf(groupId);\n\n    if ($canvases.length !== 0) {\n\n      canvas = $canvases[0];\n\n      if (idType === 'array') {\n\n        // Return layer group if given\n        group = groupId;\n\n      } else if (idType === 'regexp') {\n\n        // Get canvas data\n        data = _getCanvasData(canvas);\n        groups = data.layer.groups;\n        // Loop through all layers groups for this canvas\n        for (groupName in groups) {\n          // Find a group whose name matches the given regex\n          if (groupName.match(groupId)) {\n            group = groups[groupName];\n            // Stop after finding the first matching group\n            break;\n          }\n        }\n\n      } else {\n\n        // Find layer group with the given group name\n        data = _getCanvasData(canvas);\n        group = data.layer.groups[groupId];\n      }\n\n    }\n    return group;\n  };\n\n// Get index of layer in layers array\n  $.fn.getLayerIndex = function getLayerIndex(layerId) {\n    var $canvases = this,\n        layers = $canvases.getLayers(),\n        layer = $canvases.getLayer(layerId);\n\n    return inArray(layer, layers);\n  };\n\n// Set properties of a layer\n  $.fn.setLayer = function setLayer(layerId, props) {\n    var $canvases = this, $canvas, e,\n        data, layer,\n        propName, propValue, propType;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      layer = $($canvases[e]).getLayer(layerId);\n      if (layer) {\n\n        // Update layer property maps\n        _updateLayerName($canvas, data, layer, props);\n        _updateLayerGroups($canvas, data, layer, props);\n\n        _coerceNumericProps(props);\n\n        // Merge properties with layer\n        for (propName in props) {\n          if (Object.prototype.hasOwnProperty.call(props, propName)) {\n            propValue = props[propName];\n            propType = typeOf(propValue);\n            if (propType === 'object' && isPlainObject(propValue)) {\n              // Clone objects\n              layer[propName] = extendObject({}, propValue);\n              _coerceNumericProps(layer[propName]);\n            } else if (propType === 'array') {\n              // Clone arrays\n              layer[propName] = propValue.slice(0);\n            } else if (propType === 'string') {\n              if (propValue.indexOf('+=') === 0) {\n                // Increment numbers prefixed with +=\n                layer[propName] += parseFloat(propValue.substr(2));\n              } else if (propValue.indexOf('-=') === 0) {\n                // Decrement numbers prefixed with -=\n                layer[propName] -= parseFloat(propValue.substr(2));\n              } else if (!isNaN(propValue) && isNumeric(propValue) && propName !== 'text') {\n                // Convert numeric values as strings to numbers\n                layer[propName] = parseFloat(propValue);\n              } else {\n                // Otherwise, set given string value\n                layer[propName] = propValue;\n              }\n            } else {\n              // Otherwise, set given value\n              layer[propName] = propValue;\n            }\n          }\n        }\n\n        // Update layer events\n        _addLayerEvents($canvas, data, layer);\n        _enableDrag($canvas, data, layer);\n\n        // If layer's properties were changed\n        if ($.isEmptyObject(props) === false) {\n          _triggerLayerEvent($canvas, data, layer, 'change', props);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Set properties of all layers (optionally filtered by a callback)\n  $.fn.setLayers = function setLayers(props, callback) {\n    var $canvases = this, $canvas, e,\n        layers, l;\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      layers = $canvas.getLayers(callback);\n      // Loop through all layers\n      for (l = 0; l < layers.length; l += 1) {\n        // Set properties of each layer\n        $canvas.setLayer(layers[l], props);\n      }\n    }\n    return $canvases;\n  };\n\n// Set properties of all layers in the given group\n  $.fn.setLayerGroup = function setLayerGroup(groupId, props) {\n    var $canvases = this, $canvas, e,\n        group, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      // Get layer group\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // If group exists\n      if (group) {\n\n        // Loop through layers in group\n        for (l = 0; l < group.length; l += 1) {\n          // Merge given properties with layer\n          $canvas.setLayer(group[l], props);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Move a layer to the given index in the layers array\n  $.fn.moveLayer = function moveLayer(layerId, index) {\n    var $canvases = this, $canvas, e,\n        data, layers, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      // Retrieve layers array and desired layer\n      layers = data.layers;\n      layer = $canvas.getLayer(layerId);\n      if (layer) {\n\n        // Ensure layer index is accurate\n        layer.index = inArray(layer, layers);\n\n        // Remove layer from its current placement\n        layers.splice(layer.index, 1);\n        // Add layer in its new placement\n        layers.splice(index, 0, layer);\n\n        // Handle negative indices\n        if (index < 0) {\n          index = layers.length + index;\n        }\n        // Update layer's stored index\n        layer.index = index;\n\n        _triggerLayerEvent($canvas, data, layer, 'move');\n\n      }\n    }\n    return $canvases;\n  };\n\n// Remove a jCanvas layer\n  $.fn.removeLayer = function removeLayer(layerId) {\n    var $canvases = this, $canvas, e, data,\n        layers, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n\n      // Retrieve layers array and desired layer\n      layers = $canvas.getLayers();\n      layer = $canvas.getLayer(layerId);\n      // Remove layer if found\n      if (layer) {\n\n        // Ensure layer index is accurate\n        layer.index = inArray(layer, layers);\n        // Remove layer and allow it to be re-added later\n        layers.splice(layer.index, 1);\n        delete layer._layer;\n\n        // Update layer name map\n        _updateLayerName($canvas, data, layer, {\n          name: null\n        });\n        // Update layer group map\n        _updateLayerGroups($canvas, data, layer, {\n          groups: null\n        });\n\n        // Trigger 'remove' event\n        _triggerLayerEvent($canvas, data, layer, 'remove');\n\n      }\n    }\n    return $canvases;\n  };\n\n// Remove all layers\n  $.fn.removeLayers = function removeLayers(callback) {\n    var $canvases = this, $canvas, e,\n        data, layers, layer, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layers = $canvas.getLayers(callback);\n      // Remove all layers individually\n      for (l = 0; l < layers.length; l += 1) {\n        layer = layers[l];\n        $canvas.removeLayer(layer);\n        // Ensure no layer is skipped over\n        l -= 1;\n      }\n      // Update layer maps\n      data.layer.names = {};\n      data.layer.groups = {};\n    }\n    return $canvases;\n  };\n\n// Remove all layers in the group with the given ID\n  $.fn.removeLayerGroup = function removeLayerGroup(groupId) {\n    var $canvases = this, $canvas, e, group, l;\n\n    if (groupId !== undefined) {\n      for (e = 0; e < $canvases.length; e += 1) {\n        $canvas = $($canvases[e]);\n\n        group = $canvas.getLayerGroup(groupId);\n        // Remove layer group using given group name\n        if (group) {\n\n          // Clone groups array\n          group = group.slice(0);\n\n          // Loop through layers in group\n          for (l = 0; l < group.length; l += 1) {\n            $canvas.removeLayer(group[l]);\n          }\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Add an existing layer to a layer group\n  $.fn.addLayerToGroup = function addLayerToGroup(layerId, groupName) {\n    var $canvases = this, $canvas, e,\n        layer, groups = [groupName];\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n\n      // If layer is not already in group\n      if (layer.groups) {\n        // Clone groups list\n        groups = layer.groups.slice(0);\n        // If layer is not already in group\n        if (inArray(groupName, layer.groups) === -1) {\n          // Add layer to group\n          groups.push(groupName);\n        }\n      }\n      // Update layer group maps\n      $canvas.setLayer(layer, {\n        groups: groups\n      });\n\n    }\n    return $canvases;\n  };\n\n// Remove an existing layer from a layer group\n  $.fn.removeLayerFromGroup = function removeLayerFromGroup(layerId, groupName) {\n    var $canvases = this, $canvas, e,\n        layer, groups = [],\n        index;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n\n      if (layer.groups) {\n\n        // Find index of layer in group\n        index = inArray(groupName, layer.groups);\n\n        // If layer is in group\n        if (index !== -1) {\n\n          // Clone groups list\n          groups = layer.groups.slice(0);\n\n          // Remove layer from group\n          groups.splice(index, 1);\n\n          // Update layer group maps\n          $canvas.setLayer(layer, {\n            groups: groups\n          });\n\n        }\n\n      }\n\n    }\n    return $canvases;\n  };\n\n// Get topmost layer that intersects with event coordinates\n  function _getIntersectingLayer(data) {\n    var layer, i,\n        mask, m;\n\n    // Store the topmost layer\n    layer = null;\n\n    // Get the topmost layer whose visible area intersects event coordinates\n    for (i = data.intersecting.length - 1; i >= 0; i -= 1) {\n\n      // Get current layer\n      layer = data.intersecting[i];\n\n      // If layer has previous masks\n      if (layer._masks) {\n\n        // Search previous masks to ensure\n        // layer is visible at event coordinates\n        for (m = layer._masks.length - 1; m >= 0; m -= 1) {\n          mask = layer._masks[m];\n          // If mask does not intersect event coordinates\n          if (!mask.intersects) {\n            // Indicate that the mask does not\n            // intersect event coordinates\n            layer.intersects = false;\n            // Stop searching previous masks\n            break;\n          }\n\n        }\n\n        // If event coordinates intersect all previous masks\n        // and layer is not intangible\n        if (layer.intersects && !layer.intangible) {\n          // Stop searching for topmost layer\n          break;\n        }\n\n      }\n\n    }\n    // If resulting layer is intangible\n    if (layer && layer.intangible) {\n      // Cursor does not intersect this layer\n      layer = null;\n    }\n    return layer;\n  }\n\n// Draw individual layer (internal)\n  function _drawLayer($canvas, ctx, layer, nextLayerIndex) {\n    if (layer && layer.visible && layer._method) {\n      if (nextLayerIndex) {\n        layer._next = nextLayerIndex;\n      } else {\n        layer._next = null;\n      }\n      // If layer is an object, call its respective method\n      if (layer._method) {\n        layer._method.call($canvas, layer);\n      }\n    }\n  }\n\n// Handle dragging of the currently-dragged layer\n  function _handleLayerDrag($canvas, data, eventType) {\n    var layers, layer, l,\n        drag, dragGroups,\n        group, groupName, g,\n        newX, newY;\n\n    drag = data.drag;\n    layer = drag.layer;\n    dragGroups = (layer && layer.dragGroups) || [];\n    layers = data.layers;\n\n    if (eventType === 'mousemove' || eventType === 'touchmove') {\n      // Detect when user is currently dragging layer\n\n      if (!drag.dragging) {\n        // Detect when user starts dragging layer\n\n        // Signify that a layer on the canvas is being dragged\n        drag.dragging = true;\n        layer.dragging = true;\n\n        // Optionally bring layer to front when drag starts\n        if (layer.bringToFront) {\n          // Remove layer from its original position\n          layers.splice(layer.index, 1);\n          // Bring layer to front\n          // push() returns the new array length\n          layer.index = layers.push(layer);\n        }\n\n        // Set drag properties for this layer\n        layer._startX = layer.x;\n        layer._startY = layer.y;\n        layer._endX = layer._eventX;\n        layer._endY = layer._eventY;\n\n        // Trigger dragstart event\n        _triggerLayerEvent($canvas, data, layer, 'dragstart');\n\n      }\n\n      if (drag.dragging) {\n\n        // Calculate position after drag\n        newX = layer._eventX - (layer._endX - layer._startX);\n        newY = layer._eventY - (layer._endY - layer._startY);\n        if (layer.updateDragX) {\n          newX = layer.updateDragX.call($canvas[0], layer, newX);\n        }\n        if (layer.updateDragY) {\n          newY = layer.updateDragY.call($canvas[0], layer, newY);\n        }\n        layer.dx = newX - layer.x;\n        layer.dy = newY - layer.y;\n\n        if (layer.restrictDragToAxis !== 'y') {\n          layer.x = newX;\n        }\n        if (layer.restrictDragToAxis !== 'x') {\n          layer.y = newY;\n        }\n\n        if(layer.circlePath === true){\n          var centerX = layer.circleCenterX;\n          var centerY = layer.circleCenterY;\n          var r = layer.circleRadius;\n          var x1 = layer.x - centerX;\n          var y1 = layer.y - centerY;\n          var k = y1/x1;\n\n          if(x1<0){\n            var tempX = -Math.sqrt(Math.pow(r,2)/(1+Math.pow((k),2)));\n          }else{\n            var tempX = Math.sqrt(Math.pow(r,2)/(1+Math.pow((k),2)));\n          }\n          var tempY = tempX*k;\n\n          var px = layer.xMin;\n          var py = layer.yMin;\n          var qx = layer.xMax;\n          var qy = layer.yMax;\n          var rx = newX;\n          var ry = newY;\n          var Result = (Math.pow(px,2) + Math.pow(py,2)) * (qx * ry - qy * rx) -\n              (Math.pow(qx,2) + Math.pow(qy,2)) * (px * ry - py * rx) +\n              (Math.pow(rx,2) + Math.pow(ry,2)) * (px * qy - py * qx);\n\n          if(Result <= 0){\n            var absSumMin = Math.abs(layer.xMin - newX) + Math.abs(layer.yMin - newY);\n            var absSumMax = Math.abs(layer.xMax - newX) + Math.abs(layer.yMax - newY);\n            if(absSumMin < absSumMax){\n              tempX = layer.xMin - centerX;\n              tempY = layer.yMin - centerY;\n            }else{\n              tempX = layer.xMax - centerX;\n              tempY = layer.yMax - centerY;\n            }\n          }\n\n          var newX = tempX + centerX;\n          var newY = tempY + centerY;\n\n          layer.x = newX;\n          layer.y = newY;\n\n        }\n\n        // Trigger drag event\n        _triggerLayerEvent($canvas, data, layer, 'drag');\n\n        // Move groups with layer on drag\n        for (g = 0; g < dragGroups.length; g += 1) {\n\n          groupName = dragGroups[g];\n          group = data.layer.groups[groupName];\n          if (layer.groups && group) {\n\n            for (l = 0; l < group.length; l += 1) {\n              if (group[l] !== layer) {\n                if (layer.restrictDragToAxis !== 'y' && group[l].restrictDragToAxis !== 'y') {\n                  group[l].x += layer.dx;\n                }\n                if (layer.restrictDragToAxis !== 'x' && group[l].restrictDragToAxis !== 'x') {\n                  group[l].y += layer.dy;\n                }\n              }\n            }\n\n          }\n\n        }\n\n      }\n\n    } else if (eventType === 'mouseup' || eventType === 'touchend') {\n      // Detect when user stops dragging layer\n\n      if (drag.dragging) {\n        layer.dragging = false;\n        drag.dragging = false;\n        data.redrawOnMousemove = data.originalRedrawOnMousemove;\n        // Trigger dragstop event\n        _triggerLayerEvent($canvas, data, layer, 'dragstop');\n      }\n\n      // Cancel dragging\n      data.drag = {};\n\n    }\n  }\n\n\n// List of CSS3 cursors that need to be prefixed\n  css.cursors = ['grab', 'grabbing', 'zoom-in', 'zoom-out'];\n\n// Function to detect vendor prefix\n// Modified version of David Walsh's implementation\n// https://davidwalsh.name/vendor-prefix\n  css.prefix = (function () {\n    var styles = getComputedStyle(document.documentElement, ''),\n        pre = (arraySlice\n                .call(styles)\n                .join('')\n                .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])\n        )[1];\n    return '-' + pre + '-';\n  })();\n\n// Set cursor on canvas\n  function _setCursor($canvas, layer, eventType) {\n    var cursor;\n    if (layer.cursors) {\n      // Retrieve cursor from cursors object if it exists\n      cursor = layer.cursors[eventType];\n    }\n    // Prefix any CSS3 cursor\n    if ($.inArray(cursor, css.cursors) !== -1) {\n      cursor = css.prefix + cursor;\n    }\n    // If cursor is defined\n    if (cursor) {\n      // Set canvas cursor\n      $canvas.css({\n        cursor: cursor\n      });\n    }\n  }\n\n// Reset cursor on canvas\n  function _resetCursor($canvas, data) {\n    $canvas.css({\n      cursor: data.cursor\n    });\n  }\n\n// Run the given event callback with the given arguments\n  function _runEventCallback($canvas, layer, eventType, callbacks, arg) {\n    // Prevent callback from firing recursively\n    if (callbacks[eventType] && layer._running && !layer._running[eventType]) {\n      // Signify the start of callback execution for this event\n      layer._running[eventType] = true;\n      // Run event callback with the given arguments\n      callbacks[eventType].call($canvas[0], layer, arg);\n      // Signify the end of callback execution for this event\n      layer._running[eventType] = false;\n    }\n  }\n\n// Determine if the given layer can \"legally\" fire the given event\n  function _layerCanFireEvent(layer, eventType) {\n    // If events are disable and if\n    // layer is tangible or event is not tangible\n    return (!layer.disableEvents &&\n        (!layer.intangible || $.inArray(eventType, tangibleEvents) === -1));\n  }\n\n// Trigger the given event on the given layer\n  function _triggerLayerEvent($canvas, data, layer, eventType, arg) {\n    // If layer can legally fire this event type\n    if (_layerCanFireEvent(layer, eventType)) {\n\n      // Do not set a custom cursor on layer mouseout\n      if (eventType !== 'mouseout') {\n        // Update cursor if one is defined for this event\n        _setCursor($canvas, layer, eventType);\n      }\n\n      // Trigger the user-defined event callback\n      _runEventCallback($canvas, layer, eventType, layer, arg);\n      // Trigger the canvas-bound event hook\n      _runEventCallback($canvas, layer, eventType, data.eventHooks, arg);\n      // Trigger the global event hook\n      _runEventCallback($canvas, layer, eventType, jCanvas.eventHooks, arg);\n\n    }\n  }\n\n// Manually trigger a layer event\n  $.fn.triggerLayerEvent = function (layer, eventType) {\n    var $canvases = this, $canvas, e,\n        data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layer);\n      if (layer) {\n        _triggerLayerEvent($canvas, data, layer, eventType);\n      }\n    }\n    return $canvases;\n  };\n\n// Draw layer with the given ID\n  $.fn.drawLayer = function drawLayer(layerId) {\n    var $canvases = this, e, ctx,\n        $canvas, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n        layer = $canvas.getLayer(layerId);\n        _drawLayer($canvas, ctx, layer);\n      }\n    }\n    return $canvases;\n  };\n\n// Draw all layers (or, if given, only layers starting at an index)\n  $.fn.drawLayers = function drawLayers(args) {\n    var $canvases = this, $canvas, e, ctx,\n        // Internal parameters for redrawing the canvas\n        params = args || {},\n        // Other variables\n        layers, layer, lastLayer, l, index, lastIndex,\n        data, eventCache, eventType, isImageLayer;\n\n    // The layer index from which to start redrawing the canvas\n    index = params.index;\n    if (!index) {\n      index = 0;\n    }\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        // Clear canvas first unless otherwise directed\n        if (params.clear !== false) {\n          $canvas.clearCanvas();\n        }\n\n        // Cache the layers array\n        layers = data.layers;\n\n        // Draw layers from first to last (bottom to top)\n        for (l = index; l < layers.length; l += 1) {\n          layer = layers[l];\n\n          // Ensure layer index is up-to-date\n          layer.index = l;\n\n          // Prevent any one event from firing excessively\n          if (params.resetFire) {\n            layer._fired = false;\n          }\n          // Draw layer\n          _drawLayer($canvas, ctx, layer, l + 1);\n          // Store list of previous masks for each layer\n          layer._masks = data.transforms.masks.slice(0);\n\n          // Allow image layers to load before drawing successive layers\n          if (layer._method === $.fn.drawImage && layer.visible) {\n            isImageLayer = true;\n            break;\n          }\n\n        }\n\n        // If layer is an image layer\n        if (isImageLayer) {\n          // Stop and wait for drawImage() to resume drawLayers()\n          break;\n        }\n\n        // Store the latest\n        lastIndex = l;\n\n        // Get first layer that intersects with event coordinates\n        layer = _getIntersectingLayer(data);\n\n        eventCache = data.event;\n        eventType = eventCache.type;\n\n        // If jCanvas has detected a dragstart\n        if (data.drag.layer) {\n          // Handle dragging of layer\n          _handleLayerDrag($canvas, data, eventType);\n        }\n\n        // Manage mouseout event\n        lastLayer = data.lastIntersected;\n        if (lastLayer !== null && layer !== lastLayer && lastLayer._hovered && !lastLayer._fired && !data.drag.dragging) {\n\n          data.lastIntersected = null;\n          lastLayer._fired = true;\n          lastLayer._hovered = false;\n          _triggerLayerEvent($canvas, data, lastLayer, 'mouseout');\n          _resetCursor($canvas, data);\n\n        }\n\n        if (layer) {\n\n          // Use mouse event callbacks if no touch event callbacks are given\n          if (!layer[eventType]) {\n            eventType = _getMouseEventName(eventType);\n          }\n\n          // Check events for intersecting layer\n          if (layer._event && layer.intersects) {\n\n            data.lastIntersected = layer;\n\n            // Detect mouseover events\n            if ((layer.mouseover || layer.mouseout || layer.cursors) && !data.drag.dragging) {\n\n              if (!layer._hovered && !layer._fired) {\n\n                // Prevent events from firing excessively\n                layer._fired = true;\n                layer._hovered = true;\n                _triggerLayerEvent($canvas, data, layer, 'mouseover');\n\n              }\n\n            }\n\n            // Detect any other mouse event\n            if (!layer._fired) {\n\n              // Prevent event from firing twice unintentionally\n              layer._fired = true;\n              eventCache.type = null;\n\n              _triggerLayerEvent($canvas, data, layer, eventType);\n\n            }\n\n            // Use the mousedown event to start drag\n            if (layer.draggable && !layer.disableEvents && (eventType === 'mousedown' || eventType === 'touchstart')) {\n\n              // Keep track of drag state\n              data.drag.layer = layer;\n              data.originalRedrawOnMousemove = data.redrawOnMousemove;\n              data.redrawOnMousemove = true;\n\n            }\n\n          }\n\n        }\n\n        // If cursor is not intersecting with any layer\n        if (layer === null && !data.drag.dragging) {\n          // Reset cursor to previous state\n          _resetCursor($canvas, data);\n        }\n\n        // If the last layer has been drawn\n        if (lastIndex === layers.length) {\n\n          // Reset list of intersecting layers\n          data.intersecting.length = 0;\n          // Reset transformation stack\n          data.transforms = _cloneTransforms(baseTransforms);\n          data.savedTransforms.length = 0;\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Add a jCanvas layer (internal)\n  function _addLayer(canvas, params, args, method) {\n    var $canvas, data,\n        layers, layer = (params._layer ? args : params);\n\n    // Store arguments object for later use\n    params._args = args;\n\n    // Convert all draggable drawings into jCanvas layers\n    if (params.draggable || params.dragGroups) {\n      params.layer = true;\n      params.draggable = true;\n    }\n\n    // Determine the layer's type using the available information\n    if (!params._method) {\n      if (method) {\n        params._method = method;\n      } else if (params.method) {\n        params._method = $.fn[params.method];\n      } else if (params.type) {\n        params._method = $.fn[maps.drawings[params.type]];\n      }\n    }\n\n    // If layer hasn't been added yet\n    if (params.layer && !params._layer) {\n      // Add layer to canvas\n\n      $canvas = $(canvas);\n\n      data = _getCanvasData(canvas);\n      layers = data.layers;\n\n      // Do not add duplicate layers of same name\n      if (layer.name === null || (isString(layer.name) && data.layer.names[layer.name] === undefined)) {\n\n        // Convert number properties to numbers\n        _coerceNumericProps(params);\n\n        // Ensure layers are unique across canvases by cloning them\n        layer = new jCanvasObject(params);\n        layer.canvas = canvas;\n        // Indicate that this is a layer for future checks\n        layer.layer = true;\n        layer._layer = true;\n        layer._running = {};\n        // If layer stores user-defined data\n        if (layer.data !== null) {\n          // Clone object\n          layer.data = extendObject({}, layer.data);\n        } else {\n          // Otherwise, create data object\n          layer.data = {};\n        }\n        // If layer stores a list of associated groups\n        if (layer.groups !== null) {\n          // Clone list\n          layer.groups = layer.groups.slice(0);\n        } else {\n          // Otherwise, create empty list\n          layer.groups = [];\n        }\n\n        // Update layer group maps\n        _updateLayerName($canvas, data, layer);\n        _updateLayerGroups($canvas, data, layer);\n\n        // Check for any associated jCanvas events and enable them\n        _addLayerEvents($canvas, data, layer);\n\n        // Optionally enable drag-and-drop support and cursor support\n        _enableDrag($canvas, data, layer);\n\n        // Copy _event property to parameters object\n        params._event = layer._event;\n\n        // Calculate width/height for text layers\n        if (layer._method === $.fn.drawText) {\n          $canvas.measureText(layer);\n        }\n\n        // Add layer to end of array if no index is specified\n        if (layer.index === null) {\n          layer.index = layers.length;\n        }\n\n        // Add layer to layers array at specified index\n        layers.splice(layer.index, 0, layer);\n\n        // Store layer on parameters object\n        params._args = layer;\n\n        // Trigger an 'add' event\n        _triggerLayerEvent($canvas, data, layer, 'add');\n\n      }\n\n    } else if (!params.layer) {\n      _coerceNumericProps(params);\n    }\n\n    return layer;\n  }\n\n// Add a jCanvas layer\n  $.fn.addLayer = function addLayer(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        params.layer = true;\n        _addLayer($canvases[e], params, args);\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Animation API */\n\n// Define properties used in both CSS and jCanvas\n  css.props = [\n    'width',\n    'height',\n    'opacity',\n    'lineHeight'\n  ];\n  css.propsObj = {};\n\n// Hide/show jCanvas/CSS properties so they can be animated using jQuery\n  function _showProps(obj) {\n    var cssProp, p;\n    for (p = 0; p < css.props.length; p += 1) {\n      cssProp = css.props[p];\n      obj[cssProp] = obj['_' + cssProp];\n    }\n  }\n  function _hideProps(obj, reset) {\n    var cssProp, p;\n    for (p = 0; p < css.props.length; p += 1) {\n      cssProp = css.props[p];\n      // Hide property using same name with leading underscore\n      if (obj[cssProp] !== undefined) {\n        obj['_' + cssProp] = obj[cssProp];\n        css.propsObj[cssProp] = true;\n        if (reset) {\n          delete obj[cssProp];\n        }\n      }\n    }\n  }\n\n// Evaluate property values that are functions\n  function _parseEndValues(canvas, layer, endValues) {\n    var propName, propValue,\n        subPropName, subPropValue;\n    // Loop through all properties in map of end values\n    for (propName in endValues) {\n      if (Object.prototype.hasOwnProperty.call(endValues, propName)) {\n        propValue = endValues[propName];\n        // If end value is function\n        if (isFunction(propValue)) {\n          // Call function and use its value as the end value\n          endValues[propName] = propValue.call(canvas, layer, propName);\n        }\n        // If end value is an object\n        if (typeOf(propValue) === 'object' && isPlainObject(propValue)) {\n          // Prepare to animate properties in object\n          for (subPropName in propValue) {\n            if (Object.prototype.hasOwnProperty.call(propValue, subPropName)) {\n              subPropValue = propValue[subPropName];\n              // Store property's start value at top-level of layer\n              if (layer[propName] !== undefined) {\n                layer[propName + '.' + subPropName] = layer[propName][subPropName];\n                // Store property's end value at top-level of end values map\n                endValues[propName + '.' + subPropName] = subPropValue;\n              }\n            }\n          }\n          // Delete sub-property of object as it's no longer needed\n          delete endValues[propName];\n        }\n      }\n    }\n    return endValues;\n  }\n\n// Remove sub-property aliases from layer object\n  function _removeSubPropAliases(layer) {\n    var propName;\n    for (propName in layer) {\n      if (Object.prototype.hasOwnProperty.call(layer, propName)) {\n        if (propName.indexOf('.') !== -1) {\n          delete layer[propName];\n        }\n      }\n    }\n  }\n\n// Convert a color value to an array of RGB values\n  function _colorToRgbArray(color) {\n    var originalColor, elem,\n        rgb = [],\n        multiple = 1;\n\n    // Deal with complete transparency\n    if (color === 'transparent') {\n      color = 'rgba(0, 0, 0, 0)';\n    } else if (color.match(/^([a-z]+|#[0-9a-f]+)$/gi)) {\n      // Deal with hexadecimal colors and color names\n      elem = document.head;\n      originalColor = elem.style.color;\n      elem.style.color = color;\n      color = $.css(elem, 'color');\n      elem.style.color = originalColor;\n    }\n    // Parse RGB string\n    if (color.match(/^rgb/gi)) {\n      rgb = color.match(/(\\d+(\\.\\d+)?)/gi);\n      // Deal with RGB percentages\n      if (color.match(/%/gi)) {\n        multiple = 2.55;\n      }\n      rgb[0] *= multiple;\n      rgb[1] *= multiple;\n      rgb[2] *= multiple;\n      // Ad alpha channel if given\n      if (rgb[3] !== undefined) {\n        rgb[3] = parseFloat(rgb[3]);\n      } else {\n        rgb[3] = 1;\n      }\n    }\n    return rgb;\n  }\n\n// Animate a hex or RGB color\n  function _animateColor(fx) {\n    var n = 3,\n        i;\n    // Only parse start and end colors once\n    if (typeOf(fx.start) !== 'array') {\n      fx.start = _colorToRgbArray(fx.start);\n      fx.end = _colorToRgbArray(fx.end);\n    }\n    fx.now = [];\n\n    // If colors are RGBA, animate transparency\n    if (fx.start[3] !== 1 || fx.end[3] !== 1) {\n      n = 4;\n    }\n\n    // Calculate current frame for red, green, blue, and alpha\n    for (i = 0; i < n; i += 1) {\n      fx.now[i] = fx.start[i] + ((fx.end[i] - fx.start[i]) * fx.pos);\n      // Only the red, green, and blue values must be integers\n      if (i < 3) {\n        fx.now[i] = round(fx.now[i]);\n      }\n    }\n    if (fx.start[3] !== 1 || fx.end[3] !== 1) {\n      // Only use RGBA if RGBA colors are given\n      fx.now = 'rgba(' + fx.now.join(',') + ')';\n    } else {\n      // Otherwise, animate as solid colors\n      fx.now.slice(0, 3);\n      fx.now = 'rgb(' + fx.now.join(',') + ')';\n    }\n    // Animate colors for both canvas layers and DOM elements\n    if (fx.elem.nodeName) {\n      fx.elem.style[fx.prop] = fx.now;\n    } else {\n      fx.elem[fx.prop] = fx.now;\n    }\n  }\n\n// Animate jCanvas layer\n  $.fn.animateLayer = function animateLayer() {\n    var $canvases = this, $canvas, e, ctx,\n        args = arraySlice.call(arguments, 0),\n        data, layer, props;\n\n    // Deal with all cases of argument placement\n    /*\n\t\t0. layer name/index\n\t\t1. properties\n\t\t2. duration/options\n\t\t3. easing\n\t\t4. complete function\n\t\t5. step function\n\t*/\n\n    if (typeOf(args[2]) === 'object') {\n\n      // Accept an options object for animation\n      args.splice(2, 0, args[2].duration || null);\n      args.splice(3, 0, args[3].easing || null);\n      args.splice(4, 0, args[4].complete || null);\n      args.splice(5, 0, args[5].step || null);\n\n    } else {\n\n      if (args[2] === undefined) {\n        // If object is the last argument\n        args.splice(2, 0, null);\n        args.splice(3, 0, null);\n        args.splice(4, 0, null);\n      } else if (isFunction(args[2])) {\n        // If callback comes after object\n        args.splice(2, 0, null);\n        args.splice(3, 0, null);\n      }\n      if (args[3] === undefined) {\n        // If duration is the last argument\n        args[3] = null;\n        args.splice(4, 0, null);\n      } else if (isFunction(args[3])) {\n        // If callback comes after duration\n        args.splice(3, 0, null);\n      }\n\n    }\n\n    // Run callback function when animation completes\n    function complete($canvas, data, layer) {\n\n      return function () {\n\n        _showProps(layer);\n        _removeSubPropAliases(layer);\n\n        // Prevent multiple redraw loops\n        if (!data.animating || data.animated === layer) {\n          // Redraw layers on last frame\n          $canvas.drawLayers();\n        }\n\n        // Signify the end of an animation loop\n        layer._animating = false;\n        data.animating = false;\n        data.animated = null;\n\n        // If callback is defined\n        if (args[4]) {\n          // Run callback at the end of the animation\n          args[4].call($canvas[0], layer);\n        }\n\n        _triggerLayerEvent($canvas, data, layer, 'animateend');\n\n      };\n\n    }\n\n    // Redraw layers on every frame of the animation\n    function step($canvas, data, layer) {\n\n      return function (now, fx) {\n        var parts, propName, subPropName,\n            hidden = false;\n\n        // If animated property has been hidden\n        if (fx.prop[0] === '_') {\n          hidden = true;\n          // Unhide property temporarily\n          fx.prop = fx.prop.replace('_', '');\n          layer[fx.prop] = layer['_' + fx.prop];\n        }\n\n        // If animating property of sub-object\n        if (fx.prop.indexOf('.') !== -1) {\n          parts = fx.prop.split('.');\n          propName = parts[0];\n          subPropName = parts[1];\n          if (layer[propName]) {\n            layer[propName][subPropName] = fx.now;\n          }\n        }\n\n        // Throttle animation to improve efficiency\n        if (layer._pos !== fx.pos) {\n\n          layer._pos = fx.pos;\n\n          // Signify the start of an animation loop\n          if (!layer._animating && !data.animating) {\n            layer._animating = true;\n            data.animating = true;\n            data.animated = layer;\n          }\n\n          // Prevent multiple redraw loops\n          if (!data.animating || data.animated === layer) {\n            // Redraw layers for every frame\n            $canvas.drawLayers();\n          }\n\n        }\n\n        // If callback is defined\n        if (args[5]) {\n          // Run callback for each step of animation\n          args[5].call($canvas[0], now, fx, layer);\n        }\n\n        _triggerLayerEvent($canvas, data, layer, 'animate', fx);\n\n        // If property should be hidden during animation\n        if (hidden) {\n          // Hide property again\n          fx.prop = '_' + fx.prop;\n        }\n\n      };\n\n    }\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        // If a layer object was passed, use it the layer to be animated\n        layer = $canvas.getLayer(args[0]);\n\n        // Ignore layers that are functions\n        if (layer && layer._method !== $.fn.draw) {\n\n          // Do not modify original object\n          props = extendObject({}, args[1]);\n\n          props = _parseEndValues($canvases[e], layer, props);\n\n          // Bypass jQuery CSS Hooks for CSS properties (width, opacity, etc.)\n          _hideProps(props, true);\n          _hideProps(layer);\n\n          // Fix for jQuery's vendor prefixing support, which affects how width/height/opacity are animated\n          layer.style = css.propsObj;\n\n          // Animate layer\n          $(layer).animate(props, {\n            duration: args[2],\n            easing: ($.easing[args[3]] ? args[3] : null),\n            // When animation completes\n            complete: complete($canvas, data, layer),\n            // Redraw canvas for every animation frame\n            step: step($canvas, data, layer)\n          });\n          _triggerLayerEvent($canvas, data, layer, 'animatestart');\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Animate all layers in a layer group\n  $.fn.animateLayerGroup = function animateLayerGroup(groupId) {\n    var $canvases = this, $canvas, e,\n        args = arraySlice.call(arguments, 0),\n        group, l;\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      group = $canvas.getLayerGroup(groupId);\n      if (group) {\n\n        // Animate all layers in the group\n        for (l = 0; l < group.length; l += 1) {\n\n          // Replace first argument with layer\n          args[0] = group[l];\n          $canvas.animateLayer.apply($canvas, args);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Delay layer animation by a given number of milliseconds\n  $.fn.delayLayer = function delayLayer(layerId, duration) {\n    var $canvases = this, $canvas, e,\n        data, layer;\n    duration = duration || 0;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n      // If layer exists\n      if (layer) {\n        // Delay animation\n        $(layer).delay(duration);\n        _triggerLayerEvent($canvas, data, layer, 'delay');\n      }\n    }\n    return $canvases;\n  };\n\n// Delay animation all layers in a layer group\n  $.fn.delayLayerGroup = function delayLayerGroup(groupId, duration) {\n    var $canvases = this, $canvas, e,\n        group, layer, l;\n    duration = duration || 0;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // Delay all layers in the group\n      if (group) {\n\n        for (l = 0; l < group.length; l += 1) {\n          // Delay each layer in the group\n          layer = group[l];\n          $canvas.delayLayer(layer, duration);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Stop layer animation\n  $.fn.stopLayer = function stopLayer(layerId, clearQueue) {\n    var $canvases = this, $canvas, e,\n        data, layer;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n      data = _getCanvasData($canvases[e]);\n      layer = $canvas.getLayer(layerId);\n      // If layer exists\n      if (layer) {\n        // Stop animation\n        $(layer).stop(clearQueue);\n        _triggerLayerEvent($canvas, data, layer, 'stop');\n      }\n    }\n    return $canvases;\n  };\n\n// Stop animation of all layers in a layer group\n  $.fn.stopLayerGroup = function stopLayerGroup(groupId, clearQueue) {\n    var $canvases = this, $canvas, e,\n        group, layer, l;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      $canvas = $($canvases[e]);\n\n      group = $canvas.getLayerGroup(groupId);\n      // Stop all layers in the group\n      if (group) {\n\n        for (l = 0; l < group.length; l += 1) {\n          // Stop each layer in the group\n          layer = group[l];\n          $canvas.stopLayer(layer, clearQueue);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Enable animation for color properties\n  function _supportColorProps(props) {\n    var p;\n    for (p = 0; p < props.length; p += 1) {\n      $.fx.step[props[p]] = _animateColor;\n    }\n  }\n\n// Enable animation for color properties\n  _supportColorProps([\n    'color',\n    'backgroundColor',\n    'borderColor',\n    'borderTopColor',\n    'borderRightColor',\n    'borderBottomColor',\n    'borderLeftColor',\n    'fillStyle',\n    'outlineColor',\n    'strokeStyle',\n    'shadowColor'\n  ]);\n\n  /* Event API */\n\n// Map standard mouse events to touch events\n  maps.touchEvents = {\n    'mousedown': 'touchstart',\n    'mouseup': 'touchend',\n    'mousemove': 'touchmove'\n  };\n// Map standard touch events to mouse events\n  maps.mouseEvents = {\n    'touchstart': 'mousedown',\n    'touchend': 'mouseup',\n    'touchmove': 'mousemove'\n  };\n\n// Convert mouse event name to a corresponding touch event name (if possible)\n  function _getTouchEventName(eventName) {\n    // Detect touch event support\n    if (maps.touchEvents[eventName]) {\n      eventName = maps.touchEvents[eventName];\n    }\n    return eventName;\n  }\n// Convert touch event name to a corresponding mouse event name\n  function _getMouseEventName(eventName) {\n    if (maps.mouseEvents[eventName]) {\n      eventName = maps.mouseEvents[eventName];\n    }\n    return eventName;\n  }\n\n// Bind event to jCanvas layer using standard jQuery events\n  function _createEvent(eventName) {\n\n    jCanvas.events[eventName] = function ($canvas, data) {\n      var helperEventName, touchEventName, eventCache;\n\n      // Retrieve canvas's event cache\n      eventCache = data.event;\n\n      // Both mouseover/mouseout events will be managed by a single mousemove event\n      helperEventName = (eventName === 'mouseover' || eventName === 'mouseout') ? 'mousemove' : eventName;\n      touchEventName = _getTouchEventName(helperEventName);\n\n      function eventCallback(event) {\n        // Cache current mouse position and redraw layers\n        eventCache.x = event.offsetX;\n        eventCache.y = event.offsetY;\n        eventCache.type = helperEventName;\n        eventCache.event = event;\n        // Redraw layers on every trigger of the event; don't redraw if at\n        // least one layer is draggable and there are no layers with\n        // explicit mouseover/mouseout/mousemove events\n        if (event.type !== 'mousemove' || data.redrawOnMousemove || data.drag.dragging) {\n          $canvas.drawLayers({\n            resetFire: true\n          });\n        }\n        // Prevent default event behavior\n        event.preventDefault();\n      }\n\n      // Ensure the event is not bound more than once\n      if (!data.events[helperEventName]) {\n        // Bind one canvas event which handles all layer events of that type\n        if (touchEventName !== helperEventName) {\n          $canvas.bind(helperEventName + '.jCanvas ' + touchEventName + '.jCanvas', eventCallback);\n        } else {\n          $canvas.bind(helperEventName + '.jCanvas', eventCallback);\n        }\n        // Prevent this event from being bound twice\n        data.events[helperEventName] = true;\n      }\n    };\n  }\n  function _createEvents(eventNames) {\n    var n;\n    for (n = 0; n < eventNames.length; n += 1) {\n      _createEvent(eventNames[n]);\n    }\n  }\n// Populate jCanvas events object with some standard events\n  _createEvents([\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseup',\n    'mousemove',\n    'mouseover',\n    'mouseout',\n    'touchstart',\n    'touchmove',\n    'touchend',\n    'pointerdown',\n    'pointermove',\n    'pointerup',\n    'contextmenu'\n  ]);\n\n// Check if event fires when a drawing is drawn\n  function _detectEvents(canvas, ctx, params) {\n    var layer, data, eventCache, intersects,\n        transforms, x, y, angle;\n\n    // Use the layer object stored by the given parameters object\n    layer = params._args;\n    // Canvas must have event bindings\n    if (layer) {\n\n      data = _getCanvasData(canvas);\n      eventCache = data.event;\n      if (eventCache.x !== null && eventCache.y !== null) {\n        // Respect user-defined pixel ratio\n        x = eventCache.x * data.pixelRatio;\n        y = eventCache.y * data.pixelRatio;\n        // Determine if the given coordinates are in the current path\n        intersects = ctx.isPointInPath(x, y) || (ctx.isPointInStroke && ctx.isPointInStroke(x, y));\n      }\n      transforms = data.transforms;\n\n      // Allow callback functions to retrieve the mouse coordinates\n      layer.eventX = eventCache.x;\n      layer.eventY = eventCache.y;\n      layer.event = eventCache.event;\n\n      // Adjust coordinates to match current canvas transformation\n\n      // Keep track of some transformation values\n      angle = data.transforms.rotate;\n      x = layer.eventX;\n      y = layer.eventY;\n\n      if (angle !== 0) {\n        // Rotate coordinates if coordinate space has been rotated\n        layer._eventX = (x * cos(-angle)) - (y * sin(-angle));\n        layer._eventY = (y * cos(-angle)) + (x * sin(-angle));\n      } else {\n        // Otherwise, no calculations need to be made\n        layer._eventX = x;\n        layer._eventY = y;\n      }\n\n      // Scale coordinates\n      layer._eventX /= transforms.scaleX;\n      layer._eventY /= transforms.scaleY;\n\n      // If layer intersects with cursor\n      if (intersects) {\n        // Add it to a list of layers that intersect with cursor\n        data.intersecting.push(layer);\n      }\n      layer.intersects = Boolean(intersects);\n    }\n  }\n\n// Normalize offsetX and offsetY for all browsers\n  $.event.fix = function (event) {\n    var offset, originalEvent, touches;\n\n    event = jQueryEventFix.call($.event, event);\n    originalEvent = event.originalEvent;\n\n    // originalEvent does not exist for manually-triggered events\n    if (originalEvent) {\n\n      touches = originalEvent.changedTouches;\n\n      // If offsetX and offsetY are not supported, define them\n      if (event.pageX !== undefined && event.offsetX === undefined) {\n        try {\n          offset = $(event.currentTarget).offset();\n          if (offset) {\n            event.offsetX = event.pageX - offset.left;\n            event.offsetY = event.pageY - offset.top;\n          }\n        } catch (error) {\n          // Fail silently\n        }\n      } else if (touches) {\n        try {\n          // Enable offsetX and offsetY for mobile devices\n          offset = $(event.currentTarget).offset();\n          if (offset) {\n            event.offsetX = touches[0].pageX - offset.left;\n            event.offsetY = touches[0].pageY - offset.top;\n          }\n        } catch (error) {\n          // Fail silently\n        }\n      }\n\n    }\n    return event;\n  };\n\n  /* Drawing API */\n\n// Map drawing names with their respective method names\n  maps.drawings = {\n    'arc': 'drawArc',\n    'bezier': 'drawBezier',\n    'ellipse': 'drawEllipse',\n    'function': 'draw',\n    'image': 'drawImage',\n    'line': 'drawLine',\n    'path': 'drawPath',\n    'polygon': 'drawPolygon',\n    'slice': 'drawSlice',\n    'quadratic': 'drawQuadratic',\n    'rectangle': 'drawRect',\n    'text': 'drawText',\n    'vector': 'drawVector',\n    'save': 'saveCanvas',\n    'restore': 'restoreCanvas',\n    'rotate': 'rotateCanvas',\n    'scale': 'scaleCanvas',\n    'translate': 'translateCanvas'\n  };\n\n// Draws on canvas using a function\n  $.fn.draw = function draw(args) {\n    var $canvases = this, e, ctx,\n        params = new jCanvasObject(args);\n\n    // Draw using any other method\n    if (maps.drawings[params.type] && params.type !== 'function') {\n\n      $canvases[maps.drawings[params.type]](args);\n\n    } else {\n\n      for (e = 0; e < $canvases.length; e += 1) {\n        ctx = _getContext($canvases[e]);\n        if (ctx) {\n\n          params = new jCanvasObject(args);\n          _addLayer($canvases[e], params, args, draw);\n          if (params.visible) {\n\n            if (params.fn) {\n              // Call the given user-defined function\n              params.fn.call($canvases[e], ctx, params);\n            }\n\n          }\n\n        }\n      }\n\n    }\n    return $canvases;\n  };\n\n// Clears canvas\n  $.fn.clearCanvas = function clearCanvas(args) {\n    var $canvases = this, e, ctx,\n        params = new jCanvasObject(args);\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        if (params.width === null || params.height === null) {\n          // Clear entire canvas if width/height is not given\n\n          // Reset current transformation temporarily to ensure that the entire canvas is cleared\n          ctx.save();\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.clearRect(0, 0, $canvases[e].width, $canvases[e].height);\n          ctx.restore();\n\n        } else {\n          // Otherwise, clear the defined section of the canvas\n\n          // Transform clear rectangle\n          _addLayer($canvases[e], params, args, clearCanvas);\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          ctx.clearRect(params.x - (params.width / 2), params.y - (params.height / 2), params.width, params.height);\n          // Restore previous transformation\n          _restoreTransform(ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Transformation API */\n\n// Restores canvas\n  $.fn.saveCanvas = function saveCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, saveCanvas);\n\n        // Restore a number of times using the given count\n        for (i = 0; i < params.count; i += 1) {\n          _saveCanvas(ctx, data);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Restores canvas\n  $.fn.restoreCanvas = function restoreCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, restoreCanvas);\n\n        // Restore a number of times using the given count\n        for (i = 0; i < params.count; i += 1) {\n          _restoreCanvas(ctx, data);\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Rotates canvas (internal)\n  function _rotateCanvas(ctx, params, transforms) {\n\n    // Get conversion factor for radians\n    params._toRad = (params.inDegrees ? (PI / 180) : 1);\n\n    // Rotate canvas using shape as center of rotation\n    ctx.translate(params.x, params.y);\n    ctx.rotate(params.rotate * params._toRad);\n    ctx.translate(-params.x, -params.y);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.rotate += (params.rotate * params._toRad);\n    }\n  }\n\n// Scales canvas (internal)\n  function _scaleCanvas(ctx, params, transforms) {\n\n    // Scale both the x- and y- axis using the 'scale' property\n    if (params.scale !== 1) {\n      params.scaleX = params.scaleY = params.scale;\n    }\n\n    // Scale canvas using shape as center of rotation\n    ctx.translate(params.x, params.y);\n    ctx.scale(params.scaleX, params.scaleY);\n    ctx.translate(-params.x, -params.y);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.scaleX *= params.scaleX;\n      transforms.scaleY *= params.scaleY;\n    }\n  }\n\n// Translates canvas (internal)\n  function _translateCanvas(ctx, params, transforms) {\n\n    // Translate both the x- and y-axis using the 'translate' property\n    if (params.translate) {\n      params.translateX = params.translateY = params.translate;\n    }\n\n    // Translate canvas\n    ctx.translate(params.translateX, params.translateY);\n\n    // If transformation data was given\n    if (transforms) {\n      // Update transformation data\n      transforms.translateX += params.translateX;\n      transforms.translateY += params.translateY;\n    }\n  }\n\n// Rotates canvas\n  $.fn.rotateCanvas = function rotateCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, rotateCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _rotateCanvas(ctx, params, data.transforms);\n      }\n\n    }\n    return $canvases;\n  };\n\n// Scales canvas\n  $.fn.scaleCanvas = function scaleCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, scaleCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _scaleCanvas(ctx, params, data.transforms);\n\n      }\n    }\n    return $canvases;\n  };\n\n// Translates canvas\n  $.fn.translateCanvas = function translateCanvas(args) {\n    var $canvases = this, e, ctx,\n        params, data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, translateCanvas);\n\n        // Autosave transformation state by default\n        if (params.autosave) {\n          // Automatically save transformation state by default\n          _saveCanvas(ctx, data);\n        }\n        _translateCanvas(ctx, params, data.transforms);\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Shape API */\n\n// Draws rectangle\n  $.fn.drawRect = function drawRect(args) {\n    var $canvases = this, e, ctx,\n        params,\n        x1, y1,\n        x2, y2,\n        r, temp;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawRect);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          if (params.width && params.height) {\n            x1 = params.x - (params.width / 2);\n            y1 = params.y - (params.height / 2);\n            r = abs(params.cornerRadius);\n            // If corner radius is defined and is not zero\n            if (r) {\n              // Draw rectangle with rounded corners if cornerRadius is defined\n\n              x2 = params.x + (params.width / 2);\n              y2 = params.y + (params.height / 2);\n\n              // Handle negative width\n              if (params.width < 0) {\n                temp = x1;\n                x1 = x2;\n                x2 = temp;\n              }\n              // Handle negative height\n              if (params.height < 0) {\n                temp = y1;\n                y1 = y2;\n                y2 = temp;\n              }\n\n              // Prevent over-rounded corners\n              if ((x2 - x1) - (2 * r) < 0) {\n                r = (x2 - x1) / 2;\n              }\n              if ((y2 - y1) - (2 * r) < 0) {\n                r = (y2 - y1) / 2;\n              }\n\n              // Draw rectangle\n              ctx.moveTo(x1 + r, y1);\n              ctx.lineTo(x2 - r, y1);\n              ctx.arc(x2 - r, y1 + r, r, 3 * PI / 2, PI * 2, false);\n              ctx.lineTo(x2, y2 - r);\n              ctx.arc(x2 - r, y2 - r, r, 0, PI / 2, false);\n              ctx.lineTo(x1 + r, y2);\n              ctx.arc(x1 + r, y2 - r, r, PI / 2, PI, false);\n              ctx.lineTo(x1, y1 + r);\n              ctx.arc(x1 + r, y1 + r, r, PI, 3 * PI / 2, false);\n              // Always close path\n              params.closed = true;\n\n            } else {\n\n              // Otherwise, draw rectangle with square corners\n              ctx.rect(x1, y1, params.width, params.height);\n\n            }\n          }\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Close rectangle path\n          _closePath($canvases[e], ctx, params);\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves a coterminal angle between 0 and 2pi for the given angle\n  function _getCoterminal(angle) {\n    while (angle < 0) {\n      angle += (2 * PI);\n    }\n    return angle;\n  }\n\n// Retrieves the x-coordinate for the given angle in a circle\n  function _getArcX(params, angle) {\n    return params.x + (params.radius * cos(angle));\n  }\n// Retrieves the y-coordinate for the given angle in a circle\n  function _getArcY(params, angle) {\n    return params.y + (params.radius * sin(angle));\n  }\n\n// Draws arc (internal)\n  function _drawArc(canvas, ctx, params, path) {\n    var x1, y1, x2, y2,\n        x3, y3, x4, y4,\n        offsetX, offsetY,\n        diff;\n\n    // Determine offset from dragging\n    if (params === path) {\n      offsetX = 0;\n      offsetY = 0;\n    } else {\n      offsetX = params.x;\n      offsetY = params.y;\n    }\n\n    // Convert default end angle to radians\n    if (!path.inDegrees && path.end === 360) {\n      path.end = PI * 2;\n    }\n\n    // Convert angles to radians\n    path.start *= params._toRad;\n    path.end *= params._toRad;\n    // Consider 0deg due north of arc\n    path.start -= (PI / 2);\n    path.end -= (PI / 2);\n\n    // Ensure arrows are pointed correctly for CCW arcs\n    diff = PI / 180;\n    if (path.ccw) {\n      diff *= -1;\n    }\n\n    // Calculate coordinates for start arrow\n    x1 = _getArcX(path, path.start + diff);\n    y1 = _getArcY(path, path.start + diff);\n    x2 = _getArcX(path, path.start);\n    y2 = _getArcY(path, path.start);\n\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        x1, y1,\n        x2, y2\n    );\n\n    // Draw arc\n    ctx.arc(path.x + offsetX, path.y + offsetY, path.radius, path.start, path.end, path.ccw);\n\n    // Calculate coordinates for end arrow\n    x3 = _getArcX(path, path.end + diff);\n    y3 = _getArcY(path, path.end + diff);\n    x4 = _getArcX(path, path.end);\n    y4 = _getArcY(path, path.end);\n\n    _addEndArrow(\n        canvas, ctx,\n        params, path,\n        x4, y4,\n        x3, y3\n    );\n  }\n\n// Draws arc or circle\n  $.fn.drawArc = function drawArc(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawArc);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          _drawArc($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Draws ellipse\n  $.fn.drawEllipse = function drawEllipse(args) {\n    var $canvases = this, e, ctx,\n        params,\n        controlW,\n        controlH;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawEllipse);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Calculate control width and height\n          controlW = params.width * (4 / 3);\n          controlH = params.height;\n\n          // Create ellipse using curves\n          ctx.beginPath();\n          ctx.moveTo(params.x, params.y - (controlH / 2));\n          // Left side\n          ctx.bezierCurveTo(params.x - (controlW / 2), params.y - (controlH / 2), params.x - (controlW / 2), params.y + (controlH / 2), params.x, params.y + (controlH / 2));\n          // Right side\n          ctx.bezierCurveTo(params.x + (controlW / 2), params.y + (controlH / 2), params.x + (controlW / 2), params.y - (controlH / 2), params.x, params.y - (controlH / 2));\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws a regular (equal-angled) polygon\n  $.fn.drawPolygon = function drawPolygon(args) {\n    var $canvases = this, e, ctx,\n        params,\n        theta, dtheta, hdtheta,\n        apothem,\n        x, y, i;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawPolygon);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Polygon's central angle\n          dtheta = (2 * PI) / params.sides;\n          // Half of dtheta\n          hdtheta = dtheta / 2;\n          // Polygon's starting angle\n          theta = hdtheta + (PI / 2);\n          // Distance from polygon's center to the middle of its side\n          apothem = params.radius * cos(hdtheta);\n\n          // Calculate path and draw\n          ctx.beginPath();\n          for (i = 0; i < params.sides; i += 1) {\n\n            // Draw side of polygon\n            x = params.x + (params.radius * cos(theta));\n            y = params.y + (params.radius * sin(theta));\n\n            // Plot point on polygon\n            ctx.lineTo(x, y);\n\n            // Project side if chosen\n            if (params.concavity) {\n              // Sides are projected from the polygon's apothem\n              x = params.x + ((apothem + (-apothem * params.concavity)) * cos(theta + hdtheta));\n              y = params.y + ((apothem + (-apothem * params.concavity)) * sin(theta + hdtheta));\n              ctx.lineTo(x, y);\n            }\n\n            // Increment theta by delta theta\n            theta += dtheta;\n\n          }\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws pie-shaped slice\n  $.fn.drawSlice = function drawSlice(args) {\n    var $canvases = this, e, ctx,\n        params,\n        angle, dx, dy;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawSlice);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params, params.radius * 2);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Perform extra calculations\n\n          // Convert angles to radians\n          params.start *= params._toRad;\n          params.end *= params._toRad;\n          // Consider 0deg at north of arc\n          params.start -= (PI / 2);\n          params.end -= (PI / 2);\n\n          // Find positive equivalents of angles\n          params.start = _getCoterminal(params.start);\n          params.end = _getCoterminal(params.end);\n          // Ensure start angle is less than end angle\n          if (params.end < params.start) {\n            params.end += (2 * PI);\n          }\n\n          // Calculate angular position of slice\n          angle = ((params.start + params.end) / 2);\n\n          // Calculate ratios for slice's angle\n          dx = (params.radius * params.spread * cos(angle));\n          dy = (params.radius * params.spread * sin(angle));\n\n          // Adjust position of slice\n          params.x += dx;\n          params.y += dy;\n\n          // Draw slice\n          ctx.beginPath();\n          ctx.arc(params.x, params.y, params.radius, params.start, params.end, params.ccw);\n          ctx.lineTo(params.x, params.y);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Always close path\n          params.closed = true;\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Path API */\n\n// Adds arrow to path using the given properties\n  function _addArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    var leftX, leftY,\n        rightX, rightY,\n        offsetX, offsetY,\n        angle;\n\n    // If arrow radius is given and path is not closed\n    if (path.arrowRadius && !params.closed) {\n\n      // Calculate angle\n      angle = atan2((y2 - y1), (x2 - x1));\n      // Adjust angle correctly\n      angle -= PI;\n      // Calculate offset to place arrow at edge of path\n      offsetX = (params.strokeWidth * cos(angle));\n      offsetY = (params.strokeWidth * sin(angle));\n\n      // Calculate coordinates for left half of arrow\n      leftX = x2 + (path.arrowRadius * cos(angle + (path.arrowAngle / 2)));\n      leftY = y2 + (path.arrowRadius * sin(angle + (path.arrowAngle / 2)));\n      // Calculate coordinates for right half of arrow\n      rightX = x2 + (path.arrowRadius * cos(angle - (path.arrowAngle / 2)));\n      rightY = y2 + (path.arrowRadius * sin(angle - (path.arrowAngle / 2)));\n\n      // Draw left half of arrow\n      ctx.moveTo(leftX - offsetX, leftY - offsetY);\n      ctx.lineTo(x2 - offsetX, y2 - offsetY);\n      // Draw right half of arrow\n      ctx.lineTo(rightX - offsetX, rightY - offsetY);\n\n      // Visually connect arrow to path\n      ctx.moveTo(x2 - offsetX, y2 - offsetY);\n      ctx.lineTo(x2 + offsetX, y2 + offsetY);\n      // Move back to end of path\n      ctx.moveTo(x2, y2);\n\n    }\n  }\n\n// Optionally adds arrow to start of path\n  function _addStartArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    if (!path._arrowAngleConverted) {\n      path.arrowAngle *= params._toRad;\n      path._arrowAngleConverted = true;\n    }\n    if (path.startArrow) {\n      _addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n    }\n  }\n\n// Optionally adds arrow to end of path\n  function _addEndArrow(canvas, ctx, params, path, x1, y1, x2, y2) {\n    if (!path._arrowAngleConverted) {\n      path.arrowAngle *= params._toRad;\n      path._arrowAngleConverted = true;\n    }\n    if (path.endArrow) {\n      _addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n    }\n  }\n\n// Draws line (internal)\n  function _drawLine(canvas, ctx, params, path) {\n    var l,\n        lx, ly;\n    l = 2;\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        path.x2 + params.x,\n        path.y2 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      // If coordinates are given\n      if (lx !== undefined && ly !== undefined) {\n        // Draw next line\n        ctx.lineTo(lx + params.x, ly + params.y);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    // Optionally add arrows to path\n    _addEndArrow(\n        canvas, ctx,\n        params,\n        path,\n        path['x' + (l - 1)] + params.x,\n        path['y' + (l - 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws line\n  $.fn.drawLine = function drawLine(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawLine);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawLine($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Draws quadratic curve (internal)\n  function _drawQuadratic(canvas, ctx, params, path) {\n    var l,\n        lx, ly,\n        lcx, lcy;\n\n    l = 2;\n\n    _addStartArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path.cx1 + params.x,\n        path.cy1 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      lcx = path['cx' + (l - 1)];\n      lcy = path['cy' + (l - 1)];\n      // If coordinates are given\n      if (lx !== undefined && ly !== undefined && lcx !== undefined && lcy !== undefined) {\n        // Draw next curve\n        ctx.quadraticCurveTo(lcx + params.x, lcy + params.y, lx + params.x, ly + params.y);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    _addEndArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path['cx' + (l - 1)] + params.x,\n        path['cy' + (l - 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws quadratic curve\n  $.fn.drawQuadratic = function drawQuadratic(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawQuadratic);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawQuadratic($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws Bezier curve (internal)\n  function _drawBezier(canvas, ctx, params, path) {\n    var l, lc,\n        lx, ly,\n        lcx1, lcy1,\n        lcx2, lcy2;\n\n    l = 2;\n    lc = 1;\n\n    _addStartArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path.cx1 + params.x,\n        path.cy1 + params.y,\n        path.x1 + params.x,\n        path.y1 + params.y\n    );\n\n    if (path.x1 !== undefined && path.y1 !== undefined) {\n      ctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n    }\n    while (true) {\n      // Calculate next coordinates\n      lx = path['x' + l];\n      ly = path['y' + l];\n      lcx1 = path['cx' + lc];\n      lcy1 = path['cy' + lc];\n      lcx2 = path['cx' + (lc + 1)];\n      lcy2 = path['cy' + (lc + 1)];\n      // If next coordinates are given\n      if (lx !== undefined && ly !== undefined && lcx1 !== undefined && lcy1 !== undefined && lcx2 !== undefined && lcy2 !== undefined) {\n        // Draw next curve\n        ctx.bezierCurveTo(lcx1 + params.x, lcy1 + params.y, lcx2 + params.x, lcy2 + params.y, lx + params.x, ly + params.y);\n        l += 1;\n        lc += 2;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n    }\n    l -= 1;\n    lc -= 2;\n    _addEndArrow(\n        canvas,\n        ctx,\n        params,\n        path,\n        path['cx' + (lc + 1)] + params.x,\n        path['cy' + (lc + 1)] + params.y,\n        path['x' + l] + params.x,\n        path['y' + l] + params.y\n    );\n  }\n\n// Draws Bezier curve\n  $.fn.drawBezier = function drawBezier(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawBezier);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawBezier($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves the x-coordinate for the given vector angle and length\n  function _getVectorX(params, angle, length) {\n    angle *= params._toRad;\n    angle -= (PI / 2);\n    return (length * cos(angle));\n  }\n// Retrieves the y-coordinate for the given vector angle and length\n  function _getVectorY(params, angle, length) {\n    angle *= params._toRad;\n    angle -= (PI / 2);\n    return (length * sin(angle));\n  }\n\n// Draws vector (internal) #2\n  function _drawVector(canvas, ctx, params, path) {\n    var l, angle, length,\n        offsetX, offsetY,\n        x, y,\n        x3, y3,\n        x4, y4;\n\n    // Determine offset from dragging\n    if (params === path) {\n      offsetX = 0;\n      offsetY = 0;\n    } else {\n      offsetX = params.x;\n      offsetY = params.y;\n    }\n\n    l = 1;\n    x = x3 = x4 = path.x + offsetX;\n    y = y3 = y4 = path.y + offsetY;\n\n    _addStartArrow(\n        canvas, ctx,\n        params, path,\n        x + _getVectorX(params, path.a1, path.l1),\n        y + _getVectorY(params, path.a1, path.l1),\n        x,\n        y\n    );\n\n    // The vector starts at the given (x, y) coordinates\n    if (path.x !== undefined && path.y !== undefined) {\n      ctx.moveTo(x, y);\n    }\n    while (true) {\n\n      angle = path['a' + l];\n      length = path['l' + l];\n\n      if (angle !== undefined && length !== undefined) {\n        // Convert the angle to radians with 0 degrees starting at north\n        // Keep track of last two coordinates\n        x3 = x4;\n        y3 = y4;\n        // Compute (x, y) coordinates from angle and length\n        x4 += _getVectorX(params, angle, length);\n        y4 += _getVectorY(params, angle, length);\n        ctx.lineTo(x4, y4);\n        l += 1;\n      } else {\n        // Otherwise, stop drawing\n        break;\n      }\n\n    }\n    _addEndArrow(\n        canvas, ctx,\n        params, path,\n        x3, y3,\n        x4, y4\n    );\n  }\n\n// Draws vector\n  $.fn.drawVector = function drawVector(args) {\n    var $canvases = this, e, ctx,\n        params;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawVector);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Draw each point\n          ctx.beginPath();\n          _drawVector($canvases[e], ctx, params, params);\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Draws a path consisting of one or more subpaths\n  $.fn.drawPath = function drawPath(args) {\n    var $canvases = this, e, ctx,\n        params,\n        l, lp;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawPath);\n        if (params.visible) {\n\n          _transformShape($canvases[e], ctx, params);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          ctx.beginPath();\n          l = 1;\n          while (true) {\n            lp = params['p' + l];\n            if (lp !== undefined) {\n              lp = new jCanvasObject(lp);\n              if (lp.type === 'line') {\n                _drawLine($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'quadratic') {\n                _drawQuadratic($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'bezier') {\n                _drawBezier($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'vector') {\n                _drawVector($canvases[e], ctx, params, lp);\n              } else if (lp.type === 'arc') {\n                _drawArc($canvases[e], ctx, params, lp);\n              }\n              l += 1;\n            } else {\n              break;\n            }\n          }\n\n          // Check for jCanvas events\n          _detectEvents($canvases[e], ctx, params);\n          // Optionally close path\n          _closePath($canvases[e], ctx, params);\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n  /* Text API */\n\n// Calculates font string and set it as the canvas font\n  function _setCanvasFont(canvas, ctx, params) {\n    // Otherwise, use the given font attributes\n    if (!isNaN(Number(params.fontSize))) {\n      // Give font size units if it doesn't have any\n      params.fontSize += 'px';\n    }\n    // Set font using given font properties\n    ctx.font = params.fontStyle + ' ' + params.fontSize + ' ' + params.fontFamily;\n  }\n\n// Measures canvas text\n  function _measureText(canvas, ctx, params, lines) {\n    var originalSize, curWidth, l,\n        propCache = caches.propCache;\n\n    // Used cached width/height if possible\n    if (propCache.text === params.text && propCache.fontStyle === params.fontStyle && propCache.fontSize === params.fontSize && propCache.fontFamily === params.fontFamily && propCache.maxWidth === params.maxWidth && propCache.lineHeight === params.lineHeight) {\n\n      params.width = propCache.width;\n      params.height = propCache.height;\n\n    } else {\n      // Calculate text dimensions only once\n\n      // Calculate width of first line (for comparison)\n      params.width = ctx.measureText(lines[0]).width;\n\n      // Get width of longest line\n      for (l = 1; l < lines.length; l += 1) {\n\n        curWidth = ctx.measureText(lines[l]).width;\n        // Ensure text's width is the width of its longest line\n        if (curWidth > params.width) {\n          params.width = curWidth;\n        }\n\n      }\n\n      // Save original font size\n      originalSize = canvas.style.fontSize;\n      // Temporarily set canvas font size to retrieve size in pixels\n      canvas.style.fontSize = params.fontSize;\n      // Save text width and height in parameters object\n      params.height = parseFloat($.css(canvas, 'fontSize')) * lines.length * params.lineHeight;\n      // Reset font size to original size\n      canvas.style.fontSize = originalSize;\n    }\n  }\n\n// Wraps a string of text within a defined width\n  function _wrapText(ctx, params) {\n    var allText = String(params.text),\n        // Maximum line width (optional)\n        maxWidth = params.maxWidth,\n        // Lines created by manual line breaks (\\n)\n        manualLines = allText.split('\\n'),\n        // All lines created manually and by wrapping\n        allLines = [],\n        // Other variables\n        lines, line, l,\n        text, words, w;\n\n    // Loop through manually-broken lines\n    for (l = 0; l < manualLines.length; l += 1) {\n\n      text = manualLines[l];\n      // Split line into list of words\n      words = text.split(' ');\n      lines = [];\n      line = '';\n\n      // If text is short enough initially\n      // Or, if the text consists of only one word\n      if (words.length === 1 || ctx.measureText(text).width < maxWidth) {\n\n        // No need to wrap text\n        lines = [text];\n\n      } else {\n\n        // Wrap lines\n        for (w = 0; w < words.length; w += 1) {\n\n          // Once line gets too wide, push word to next line\n          if (ctx.measureText(line + words[w]).width > maxWidth) {\n            // This check prevents empty lines from being created\n            if (line !== '') {\n              lines.push(line);\n            }\n            // Start new line and repeat process\n            line = '';\n          }\n          // Add words to line until the line is too wide\n          line += words[w];\n          // Do not add a space after the last word\n          if (w !== (words.length - 1)) {\n            line += ' ';\n          }\n        }\n        // The last word should always be pushed\n        lines.push(line);\n\n      }\n      // Remove extra space at the end of each line\n      allLines = allLines.concat(\n          lines\n              .join('\\n')\n              .replace(/((\\n))|($)/gi, '$2')\n              .split('\\n')\n      );\n\n    }\n\n    return allLines;\n  }\n\n// Draws text on canvas\n  $.fn.drawText = function drawText(args) {\n    var $canvases = this, e, ctx,\n        params, layer,\n        lines, line, l,\n        fontSize, constantCloseness = 500,\n        nchars, chars, ch, c,\n        x, y;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer($canvases[e], params, args, drawText);\n        if (params.visible) {\n\n          // Set text-specific properties\n          ctx.textBaseline = params.baseline;\n          ctx.textAlign = params.align;\n\n          // Set canvas font using given properties\n          _setCanvasFont($canvases[e], ctx, params);\n\n          if (params.maxWidth !== null) {\n            // Wrap text using an internal function\n            lines = _wrapText(ctx, params);\n          } else {\n            // Convert string of text to list of lines\n            lines = params.text\n                .toString()\n                .split('\\n');\n          }\n\n          // Calculate text's width and height\n          _measureText($canvases[e], ctx, params, lines);\n\n          // If text is a layer\n          if (layer) {\n            // Copy calculated width/height to layer object\n            layer.width = params.width;\n            layer.height = params.height;\n          }\n\n          _transformShape($canvases[e], ctx, params, params.width, params.height);\n          _setGlobalProps($canvases[e], ctx, params);\n\n          // Adjust text position to accomodate different horizontal alignments\n          x = params.x;\n          if (params.align === 'left') {\n            if (params.respectAlign) {\n              // Realign text to the left if chosen\n              params.x += params.width / 2;\n            } else {\n              // Center text block by default\n              x -= params.width / 2;\n            }\n          } else if (params.align === 'right') {\n            if (params.respectAlign) {\n              // Realign text to the right if chosen\n              params.x -= params.width / 2;\n            } else {\n              // Center text block by default\n              x += params.width / 2;\n            }\n          }\n\n          if (params.radius) {\n\n            fontSize = parseFloat(params.fontSize);\n\n            // Greater values move clockwise\n            if (params.letterSpacing === null) {\n              params.letterSpacing = fontSize / constantCloseness;\n            }\n\n            // Loop through each line of text\n            for (l = 0; l < lines.length; l += 1) {\n              ctx.save();\n              ctx.translate(params.x, params.y);\n              line = lines[l];\n              if (params.flipArcText) {\n                chars = line.split('');\n                chars.reverse();\n                line = chars.join('');\n              }\n              nchars = line.length;\n              ctx.rotate(-(PI * params.letterSpacing * (nchars - 1)) / 2);\n              // Loop through characters on each line\n              for (c = 0; c < nchars; c += 1) {\n                ch = line[c];\n                // If character is not the first character\n                if (c !== 0) {\n                  // Rotate character onto arc\n                  ctx.rotate(PI * params.letterSpacing);\n                }\n                ctx.save();\n                ctx.translate(0, -params.radius);\n                if (params.flipArcText) {\n                  ctx.scale(-1, -1);\n                }\n                ctx.fillText(ch, 0, 0);\n                // Prevent extra shadow created by stroke (but only when fill is present)\n                if (params.fillStyle !== 'transparent') {\n                  ctx.shadowColor = 'transparent';\n                }\n                if (params.strokeWidth !== 0) {\n                  // Only stroke if the stroke is not 0\n                  ctx.strokeText(ch, 0, 0);\n                }\n                ctx.restore();\n              }\n              params.radius -= fontSize;\n              params.letterSpacing += fontSize / (constantCloseness * 2 * PI);\n              ctx.restore();\n            }\n\n          } else {\n\n            // Draw each line of text separately\n            for (l = 0; l < lines.length; l += 1) {\n              line = lines[l];\n              // Add line offset to center point, but subtract some to center everything\n              y = params.y + (l * params.height / lines.length) - (((lines.length - 1) * params.height / lines.length) / 2);\n\n              ctx.shadowColor = params.shadowColor;\n\n              // Fill & stroke text\n              ctx.fillText(line, x, y);\n              // Prevent extra shadow created by stroke (but only when fill is present)\n              if (params.fillStyle !== 'transparent') {\n                ctx.shadowColor = 'transparent';\n              }\n              if (params.strokeWidth !== 0) {\n                // Only stroke if the stroke is not 0\n                ctx.strokeText(line, x, y);\n              }\n\n            }\n\n          }\n\n          // Adjust bounding box according to text baseline\n          y = 0;\n          if (params.baseline === 'top') {\n            y += params.height / 2;\n          } else if (params.baseline === 'bottom') {\n            y -= params.height / 2;\n          }\n\n          // Detect jCanvas events\n          if (params._event) {\n            ctx.beginPath();\n            ctx.rect(\n                params.x - (params.width / 2),\n                params.y - (params.height / 2) + y,\n                params.width,\n                params.height\n            );\n            _detectEvents($canvases[e], ctx, params);\n            // Close path and configure masking\n            ctx.closePath();\n          }\n          _restoreTransform(ctx, params);\n\n        }\n      }\n    }\n    // Cache jCanvas parameters object for efficiency\n    caches.propCache = params;\n    return $canvases;\n  };\n\n// Measures text width/height using the given parameters\n  $.fn.measureText = function measureText(args) {\n    var $canvases = this, ctx,\n        params, lines;\n\n    // Attempt to retrieve layer\n    params = $canvases.getLayer(args);\n    // If layer does not exist or if returned object is not a jCanvas layer\n    if (!params || (params && !params._layer)) {\n      params = new jCanvasObject(args);\n    }\n\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      // Set canvas font using given properties\n      _setCanvasFont($canvases[0], ctx, params);\n      // Calculate width and height of text\n      if (params.maxWidth !== null) {\n        lines = _wrapText(ctx, params);\n      } else {\n        lines = params.text.split('\\n');\n      }\n      _measureText($canvases[0], ctx, params, lines);\n\n\n    }\n\n    return params;\n  };\n\n  /* Image API */\n\n// Draws image on canvas\n  $.fn.drawImage = function drawImage(args) {\n    var $canvases = this, canvas, e, ctx, data,\n        params, layer,\n        img, imgCtx, source,\n        imageCache = caches.imageCache;\n\n    // Draw image function\n    function draw(canvas, ctx, data, params, layer) {\n\n      // If width and sWidth are not defined, use image width\n      if (params.width === null && params.sWidth === null) {\n        params.width = params.sWidth = img.width;\n      }\n      // If width and sHeight are not defined, use image height\n      if (params.height === null && params.sHeight === null) {\n        params.height = params.sHeight = img.height;\n      }\n\n      // Ensure image layer's width and height are accurate\n      if (layer) {\n        layer.width = params.width;\n        layer.height = params.height;\n      }\n\n      // Only crop image if all cropping properties are given\n      if (params.sWidth !== null && params.sHeight !== null && params.sx !== null && params.sy !== null) {\n\n        // If width is not defined, use the given sWidth\n        if (params.width === null) {\n          params.width = params.sWidth;\n        }\n        // If height is not defined, use the given sHeight\n        if (params.height === null) {\n          params.height = params.sHeight;\n        }\n\n        // Optionally crop from top-left corner of region\n        if (params.cropFromCenter) {\n          params.sx += params.sWidth / 2;\n          params.sy += params.sHeight / 2;\n        }\n\n        // Ensure cropped region does not escape image boundaries\n\n        // Top\n        if ((params.sy - (params.sHeight / 2)) < 0) {\n          params.sy = (params.sHeight / 2);\n        }\n        // Bottom\n        if ((params.sy + (params.sHeight / 2)) > img.height) {\n          params.sy = img.height - (params.sHeight / 2);\n        }\n        // Left\n        if ((params.sx - (params.sWidth / 2)) < 0) {\n          params.sx = (params.sWidth / 2);\n        }\n        // Right\n        if ((params.sx + (params.sWidth / 2)) > img.width) {\n          params.sx = img.width - (params.sWidth / 2);\n        }\n\n        _transformShape(canvas, ctx, params, params.width, params.height);\n        _setGlobalProps(canvas, ctx, params);\n\n        // Draw image\n        ctx.drawImage(\n            img,\n            params.sx - (params.sWidth / 2),\n            params.sy - (params.sHeight / 2),\n            params.sWidth,\n            params.sHeight,\n            params.x - (params.width / 2),\n            params.y - (params.height / 2),\n            params.width,\n            params.height\n        );\n\n      } else {\n        // Show entire image if no crop region is defined\n\n        _transformShape(canvas, ctx, params, params.width, params.height);\n        _setGlobalProps(canvas, ctx, params);\n\n        // Draw image on canvas\n        ctx.drawImage(\n            img,\n            params.x - (params.width / 2),\n            params.y - (params.height / 2),\n            params.width,\n            params.height\n        );\n\n      }\n\n      // Draw invisible rectangle to allow for events and masking\n      ctx.beginPath();\n      ctx.rect(\n          params.x - (params.width / 2),\n          params.y - (params.height / 2),\n          params.width,\n          params.height\n      );\n      // Check for jCanvas events\n      _detectEvents(canvas, ctx, params);\n      // Close path and configure masking\n      ctx.closePath();\n      _restoreTransform(ctx, params);\n      _enableMasking(ctx, data, params);\n    }\n    // On load function\n    function onload(canvas, ctx, data, params, layer) {\n      return function () {\n        var $canvas = $(canvas);\n        draw(canvas, ctx, data, params, layer);\n        if (params.layer) {\n          // Trigger 'load' event for layers\n          _triggerLayerEvent($canvas, data, layer, 'load');\n        } else if (params.load) {\n          // Run 'load' callback for non-layers\n          params.load.call($canvas[0], layer);\n        }\n        // Continue drawing successive layers after this image layer has loaded\n        if (params.layer) {\n          // Store list of previous masks for each layer\n          layer._masks = data.transforms.masks.slice(0);\n          if (params._next) {\n            // Draw successive layers\n            $canvas.drawLayers({\n              clear: false,\n              resetFire: true,\n              index: params._next\n            });\n          }\n        }\n      };\n    }\n    for (e = 0; e < $canvases.length; e += 1) {\n      canvas = $canvases[e];\n      ctx = _getContext($canvases[e]);\n      if (ctx) {\n\n        data = _getCanvasData($canvases[e]);\n        params = new jCanvasObject(args);\n        layer = _addLayer($canvases[e], params, args, drawImage);\n        if (params.visible) {\n\n          // Cache the given source\n          source = params.source;\n\n          imgCtx = source.getContext;\n          if (source.src || imgCtx) {\n            // Use image or canvas element if given\n            img = source;\n          } else if (source) {\n            if (imageCache[source] && imageCache[source].complete) {\n              // Get the image element from the cache if possible\n              img = imageCache[source];\n            } else {\n              // Otherwise, get the image from the given source URL\n              img = new Image();\n              // If source URL is not a data URL\n              if (!source.match(/^data:/i)) {\n                // Set crossOrigin for this image\n                img.crossOrigin = params.crossOrigin;\n              }\n              img.src = source;\n              // Save image in cache for improved performance\n              imageCache[source] = img;\n            }\n          }\n\n          if (img) {\n            if (img.complete || imgCtx) {\n              // Draw image if already loaded\n              onload(canvas, ctx, data, params, layer)();\n            } else {\n              // Otherwise, draw image when it loads\n              img.onload = onload(canvas, ctx, data, params, layer);\n              // Fix onload() bug in IE9\n              img.src = img.src;\n            }\n          }\n\n        }\n      }\n    }\n    return $canvases;\n  };\n\n// Creates a canvas pattern object\n  $.fn.createPattern = function createPattern(args) {\n    var $canvases = this, ctx,\n        params,\n        img, imgCtx,\n        pattern, source;\n\n    // Function to be called when pattern loads\n    function onload() {\n      // Create pattern\n      pattern = ctx.createPattern(img, params.repeat);\n      // Run callback function if defined\n      if (params.load) {\n        params.load.call($canvases[0], pattern);\n      }\n    }\n\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      params = new jCanvasObject(args);\n\n      // Cache the given source\n      source = params.source;\n\n      // Draw when image is loaded (if load() callback function is defined)\n\n      if (isFunction(source)) {\n        // Draw pattern using function if given\n\n        img = $('<canvas />')[0];\n        img.width = params.width;\n        img.height = params.height;\n        imgCtx = _getContext(img);\n        source.call(img, imgCtx);\n        onload();\n\n      } else {\n        // Otherwise, draw pattern using source image\n\n        imgCtx = source.getContext;\n        if (source.src || imgCtx) {\n          // Use image element if given\n          img = source;\n        } else {\n          // Use URL if given to get the image\n          img = new Image();\n          // If source URL is not a data URL\n          if (!source.match(/^data:/i)) {\n            // Set crossOrigin for this image\n            img.crossOrigin = params.crossOrigin;\n          }\n          img.src = source;\n        }\n\n        // Create pattern if already loaded\n        if (img.complete || imgCtx) {\n          onload();\n        } else {\n          img.onload = onload;\n          // Fix onload() bug in IE9\n          img.src = img.src;\n        }\n\n      }\n\n    } else {\n\n      pattern = null;\n\n    }\n    return pattern;\n  };\n\n// Creates a canvas gradient object\n  $.fn.createGradient = function createGradient(args) {\n    var $canvases = this, ctx,\n        params,\n        gradient,\n        stops = [], nstops,\n        start, end,\n        i, a, n, p;\n\n    params = new jCanvasObject(args);\n    ctx = _getContext($canvases[0]);\n    if (ctx) {\n\n      // Gradient coordinates must be defined\n      params.x1 = params.x1 || 0;\n      params.y1 = params.y1 || 0;\n      params.x2 = params.x2 || 0;\n      params.y2 = params.y2 || 0;\n\n      if (params.r1 !== null && params.r2 !== null) {\n        // Create radial gradient if chosen\n        gradient = ctx.createRadialGradient(params.x1, params.y1, params.r1, params.x2, params.y2, params.r2);\n      } else {\n        // Otherwise, create a linear gradient by default\n        gradient = ctx.createLinearGradient(params.x1, params.y1, params.x2, params.y2);\n      }\n\n      // Count number of color stops\n      for (i = 1; params['c' + i] !== undefined; i += 1) {\n        if (params['s' + i] !== undefined) {\n          stops.push(params['s' + i]);\n        } else {\n          stops.push(null);\n        }\n      }\n      nstops = stops.length;\n\n      // Define start stop if not already defined\n      if (stops[0] === null) {\n        stops[0] = 0;\n      }\n      // Define end stop if not already defined\n      if (stops[nstops - 1] === null) {\n        stops[nstops - 1] = 1;\n      }\n\n      // Loop through color stops to fill in the blanks\n      for (i = 0; i < nstops; i += 1) {\n        // A progression, in this context, is defined as all of the color stops between and including two known color stops\n\n        if (stops[i] !== null) {\n          // Start a new progression if stop is a number\n\n          // Number of stops in current progression\n          n = 1;\n          // Current iteration in current progression\n          p = 0;\n          start = stops[i];\n\n          // Look ahead to find end stop\n          for (a = (i + 1); a < nstops; a += 1) {\n            if (stops[a] !== null) {\n              // If this future stop is a number, make it the end stop for this progression\n              end = stops[a];\n              break;\n            } else {\n              // Otherwise, keep looking ahead\n              n += 1;\n            }\n          }\n\n          // Ensure start stop is not greater than end stop\n          if (start > end) {\n            stops[a] = stops[i];\n          }\n\n        } else if (stops[i] === null) {\n          // Calculate stop if not initially given\n          p += 1;\n          stops[i] = start + (p * ((end - start) / n));\n        }\n        // Add color stop to gradient object\n        gradient.addColorStop(stops[i], params['c' + (i + 1)]);\n      }\n\n    } else {\n      gradient = null;\n    }\n    return gradient;\n  };\n\n// Manipulates pixels on the canvas\n  $.fn.setPixels = function setPixels(args) {\n    var $canvases = this,\n        canvas, e, ctx, canvasData,\n        params,\n        px,\n        imgData, pixelData, i, len;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      canvas = $canvases[e];\n      ctx = _getContext(canvas);\n      canvasData = _getCanvasData($canvases[e]);\n      if (ctx) {\n\n        params = new jCanvasObject(args);\n        _addLayer(canvas, params, args, setPixels);\n        _transformShape($canvases[e], ctx, params, params.width, params.height);\n\n        // Use entire canvas of x, y, width, or height is not defined\n        if (params.width === null || params.height === null) {\n          params.width = canvas.width;\n          params.height = canvas.height;\n          params.x = params.width / 2;\n          params.y = params.height / 2;\n        }\n\n        if (params.width !== 0 && params.height !== 0) {\n          // Only set pixels if width and height are not zero\n\n          imgData = ctx.getImageData(\n              (params.x - (params.width / 2)) * canvasData.pixelRatio,\n              (params.y - (params.height / 2)) * canvasData.pixelRatio,\n              params.width * canvasData.pixelRatio,\n              params.height * canvasData.pixelRatio\n          );\n          pixelData = imgData.data;\n          len = pixelData.length;\n\n          // Loop through pixels with the \"each\" callback function\n          if (params.each) {\n            for (i = 0; i < len; i += 4) {\n              px = {\n                r: pixelData[i],\n                g: pixelData[i + 1],\n                b: pixelData[i + 2],\n                a: pixelData[i + 3]\n              };\n              params.each.call(canvas, px, params);\n              pixelData[i] = px.r;\n              pixelData[i + 1] = px.g;\n              pixelData[i + 2] = px.b;\n              pixelData[i + 3] = px.a;\n            }\n          }\n          // Put pixels on canvas\n          ctx.putImageData(\n              imgData,\n              (params.x - (params.width / 2)) * canvasData.pixelRatio,\n              (params.y - (params.height / 2)) * canvasData.pixelRatio\n          );\n          // Restore transformation\n          ctx.restore();\n\n        }\n\n      }\n    }\n    return $canvases;\n  };\n\n// Retrieves canvas image as data URL\n  $.fn.getCanvasImage = function getCanvasImage(type, quality) {\n    var $canvases = this, canvas,\n        dataURL = null;\n    if ($canvases.length !== 0) {\n      canvas = $canvases[0];\n      if (canvas.toDataURL) {\n        // JPEG quality defaults to 1\n        if (quality === undefined) {\n          quality = 1;\n        }\n        dataURL = canvas.toDataURL('image/' + type, quality);\n      }\n    }\n    return dataURL;\n  };\n\n// Scales canvas based on the device's pixel ratio\n  $.fn.detectPixelRatio = function detectPixelRatio(callback) {\n    var $canvases = this,\n        canvas, e, ctx,\n        devicePixelRatio, backingStoreRatio, ratio,\n        oldWidth, oldHeight,\n        data;\n\n    for (e = 0; e < $canvases.length; e += 1) {\n      // Get canvas and its associated data\n      canvas = $canvases[e];\n      ctx = _getContext(canvas);\n      data = _getCanvasData($canvases[e]);\n\n      // If canvas has not already been scaled with this method\n      if (!data.scaled) {\n\n        // Determine device pixel ratios\n        devicePixelRatio = window.devicePixelRatio || 1;\n        backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n            ctx.mozBackingStorePixelRatio ||\n            ctx.msBackingStorePixelRatio ||\n            ctx.oBackingStorePixelRatio ||\n            ctx.backingStorePixelRatio || 1;\n\n        // Calculate general ratio based on the two given ratios\n        ratio = devicePixelRatio / backingStoreRatio;\n\n        if (ratio !== 1) {\n          // Scale canvas relative to ratio\n\n          // Get the current canvas dimensions for future use\n          oldWidth = canvas.width;\n          oldHeight = canvas.height;\n\n          // Resize canvas relative to the determined ratio\n          canvas.width = oldWidth * ratio;\n          canvas.height = oldHeight * ratio;\n\n          // Scale canvas back to original dimensions via CSS\n          canvas.style.width = oldWidth + 'px';\n          canvas.style.height = oldHeight + 'px';\n\n          // Scale context to counter the manual scaling of canvas\n          ctx.scale(ratio, ratio);\n\n        }\n\n        // Set pixel ratio on canvas data object\n        data.pixelRatio = ratio;\n        // Ensure that this method can only be called once for any given canvas\n        data.scaled = true;\n\n        // Call the given callback function with the ratio as its only argument\n        if (callback) {\n          callback.call(canvas, ratio);\n        }\n\n      }\n\n    }\n    return $canvases;\n  };\n\n// Clears the jCanvas cache\n  jCanvas.clearCache = function clearCache() {\n    var cacheName;\n    for (cacheName in caches) {\n      if (Object.prototype.hasOwnProperty.call(caches, cacheName)) {\n        caches[cacheName] = {};\n      }\n    }\n  };\n\n// Enable canvas feature detection with $.support\n  $.support.canvas = ($('<canvas />')[0].getContext !== undefined);\n\n// Export jCanvas functions\n  extendObject(jCanvas, {\n    defaults: defaults,\n    setGlobalProps: _setGlobalProps,\n    transformShape: _transformShape,\n    detectEvents: _detectEvents,\n    closePath: _closePath,\n    setCanvasFont: _setCanvasFont,\n    measureText: _measureText\n  });\n  $.jCanvas = jCanvas;\n  $.jCanvasObject = jCanvasObject;\n\n}));"]}